import {$ as ui, $a as So, $b as s4, $d as fc, $e as Fh, A as J8, Ab as Ph, Ac as me, Ad as Pv, Af as Qv, B as Z8, Ba as Yp, Bd as M5, Be as qv, Bf as p4, Ca as ov, Cb as i4, Cd as k5, Da as Oh, Db as gv, Dd as Mv, Df as Jv, E as ev, Ea as Vt, Eb as Mh, Ec as cn, Ed as A5, Eg as r_, Fa as In, Fb as Q, Fc as Ah, Fd as kv, Ff as Zv, Fg as s_, G as $e, Ga as Ge, Gb as Pt, Gc as Qe, Gd as Av, Ge as N5, H as ll, Hb as mv, Hc as Te, Hd as Nn, Hf as e_, I as ci, Ib as y5, Ic as C5, Id as Iv, J as qp, Ja as L0, Jb as vv, Jc as E5, Jd as Rh, Je as F5, Jg as V5, K as I0, Ka as hi, Kb as _v, Kc as H0, Kd as Rv, L as R0, La as ic, Lb as b5, Ld as Dv, Lf as t_, Ma as av, Mb as sc, Md as Dh, Mg as o_, N as sn, Na as re, Nc as Ih, Nd as Nv, O as li, Oa as nr, Oc as Cv, Od as rr, P as ul, Pa as cv, Pc as G0, Pe as zv, Q as nc, Qa as Ze, Qb as oc, Qc as V0, Qe as Xv, R as hl, Ra as Qp, Rb as yv, Re as L5, S as mt, Sa as xe, Sb as r4, Sc as cc, Se as B5, T as zp, Ta as z, Tb as Ye, Tc as lc, U as m5, Ua as Jp, Ub as ir, Uc as uc, Ud as Fv, Va as v5, Vb as as, Vc as oe, Vd as Lv, Wa as lv, Wb as ac, Wc as Pn, Wd as Bv, We as Kv, Xa as B0, Xb as xo, Xc as Zn, Xe as Nh, Y as on, Yb as bv, Ye as gc, Z as tv, Za as uv, Zb as at, Zd as Uv, _a as rc, a as C, ab as qs, ac as Sv, ae as Hv, af as U5, b as ve, bb as yt, bc as S5, be as pc, bf as gl, c as z8, ca as Xp, cb as bt, cc as x5, cd as c4, ce as u4, cf as h4, cg as n_, d as tr, da as Lt, db as dl, dc as o4, de as Gv, e as GM, ec as xv, ed as Dn, ee as Vv, f as X8, fa as ss, fb as On, fc as kh, fd as l4, fe as Wv, g as p5, gb as Zp, gc as a4, h as Th, ha as D0, hb as an, hc as ua, i as ue, ie as $v, if as d4, ja as nv, jb as hv, k as K8, kb as os, kd as ha, l as g5, la as gr, lb as Rn, lc as U0, ld as da, m as bo, ma as Jn, mb as e4, mc as ye, me as $t, mg as i_, n as $p, nb as Wt, nc as w5, nf as H5, o as jp, oa as Kp, ob as Ee, oc as wo, od as hc, oe as jv, p as lt, pa as iv, pb as Os, pc as wv, pd as T5, pe as wi, q as Ne, qb as wt, qc as mr, qd as O5, qe as Fn, rb as dv, rc as cs, sb as t4, sd as Ev, t as Y8, ta as rv, tb as fv, tc as tt, td as dc, tg as VM, ua as sv, ub as zs, uc as ls, ue as I5, uf as Yv, v as Ur, vd as Tv, ve as pl, vf as f4, w as Q8, wa as N0, wb as n4, wc as us, wd as Ov, we as R5, wf as G5, x as Qn, xb as pv, xc as hs, xd as P5, xe as D5, y as Be, ya as F0, yb as _5, yc as H, z as Hr, zb as fl, zc as W, zd as W0} from "./chunk-CBTQCYGN.js";
var vT = GM( (B2e, W2) => {
    (function(e, t, n) {
        if (!e)
            return;
        for (var i = {
            8: "backspace",
            9: "tab",
            13: "enter",
            16: "shift",
            17: "ctrl",
            18: "alt",
            20: "capslock",
            27: "esc",
            32: "space",
            33: "pageup",
            34: "pagedown",
            35: "end",
            36: "home",
            37: "left",
            38: "up",
            39: "right",
            40: "down",
            45: "ins",
            46: "del",
            91: "meta",
            93: "meta",
            224: "meta"
        }, r = {
            106: "*",
            107: "+",
            109: "-",
            110: ".",
            111: "/",
            186: ";",
            187: "=",
            188: ",",
            189: "-",
            190: ".",
            191: "/",
            192: "`",
            219: "[",
            220: "\\",
            221: "]",
            222: "'"
        }, s = {
            "~": "`",
            "!": "1",
            "@": "2",
            "#": "3",
            $: "4",
            "%": "5",
            "^": "6",
            "&": "7",
            "*": "8",
            "(": "9",
            ")": "0",
            _: "-",
            "+": "=",
            ":": ";",
            '"': "'",
            "<": ",",
            ">": ".",
            "?": "/",
            "|": "\\"
        }, o = {
            option: "alt",
            command: "meta",
            return: "enter",
            escape: "esc",
            plus: "+",
            mod: /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? "meta" : "ctrl"
        }, a, c = 1; c < 20; ++c)
            i[111 + c] = "f" + c;
        for (c = 0; c <= 9; ++c)
            i[c + 96] = c.toString();
        function l(N, E, F) {
            if (N.addEventListener) {
                N.addEventListener(E, F, !1);
                return
            }
            N.attachEvent("on" + E, F)
        }
        function u(N) {
            if (N.type == "keypress") {
                var E = String.fromCharCode(N.which);
                return N.shiftKey || (E = E.toLowerCase()),
                E
            }
            return i[N.which] ? i[N.which] : r[N.which] ? r[N.which] : String.fromCharCode(N.which).toLowerCase()
        }
        function h(N, E) {
            return N.sort().join(",") === E.sort().join(",")
        }
        function d(N) {
            var E = [];
            return N.shiftKey && E.push("shift"),
            N.altKey && E.push("alt"),
            N.ctrlKey && E.push("ctrl"),
            N.metaKey && E.push("meta"),
            E
        }
        function f(N) {
            if (N.preventDefault) {
                N.preventDefault();
                return
            }
            N.returnValue = !1
        }
        function g(N) {
            if (N.stopPropagation) {
                N.stopPropagation();
                return
            }
            N.cancelBubble = !0
        }
        function p(N) {
            return N == "shift" || N == "ctrl" || N == "alt" || N == "meta"
        }
        function v() {
            if (!a) {
                a = {};
                for (var N in i)
                    N > 95 && N < 112 || i.hasOwnProperty(N) && (a[i[N]] = N)
            }
            return a
        }
        function b(N, E, F) {
            return F || (F = v()[N] ? "keydown" : "keypress"),
            F == "keypress" && E.length && (F = "keydown"),
            F
        }
        function S(N) {
            return N === "+" ? ["+"] : (N = N.replace(/\+{2}/g, "+plus"),
            N.split("+"))
        }
        function w(N, E) {
            var F, O, V, X = [];
            for (F = S(N),
            V = 0; V < F.length; ++V)
                O = F[V],
                o[O] && (O = o[O]),
                E && E != "keypress" && s[O] && (O = s[O],
                X.push("shift")),
                p(O) && X.push(O);
            return E = b(O, X, E),
            {
                key: O,
                modifiers: X,
                action: E
            }
        }
        function k(N, E) {
            return N === null || N === t ? !1 : N === E ? !0 : k(N.parentNode, E)
        }
        function B(N) {
            var E = this;
            if (N = N || t,
            !(E instanceof B))
                return new B(N);
            E.target = N,
            E._callbacks = {},
            E._directMap = {};
            var F = {}, O, V = !1, X = !1, x = !1;
            function j(de) {
                de = de || {};
                var Ue = !1, A;
                for (A in F) {
                    if (de[A]) {
                        Ue = !0;
                        continue
                    }
                    F[A] = 0
                }
                Ue || (x = !1)
            }
            function fe(de, Ue, A, q, L, U) {
                var te, Ce, Ve = [], De = A.type;
                if (!E._callbacks[de])
                    return [];
                for (De == "keyup" && p(de) && (Ue = [de]),
                te = 0; te < E._callbacks[de].length; ++te)
                    if (Ce = E._callbacks[de][te],
                    !(!q && Ce.seq && F[Ce.seq] != Ce.level) && De == Ce.action && (De == "keypress" && !A.metaKey && !A.ctrlKey || h(Ue, Ce.modifiers))) {
                        var ge = !q && Ce.combo == L
                          , kt = q && Ce.seq == q && Ce.level == U;
                        (ge || kt) && E._callbacks[de].splice(te, 1),
                        Ve.push(Ce)
                    }
                return Ve
            }
            function he(de, Ue, A, q) {
                E.stopCallback(Ue, Ue.target || Ue.srcElement, A, q) || de(Ue, A) === !1 && (f(Ue),
                g(Ue))
            }
            E._handleKey = function(de, Ue, A) {
                var q = fe(de, Ue, A), L, U = {}, te = 0, Ce = !1;
                for (L = 0; L < q.length; ++L)
                    q[L].seq && (te = Math.max(te, q[L].level));
                for (L = 0; L < q.length; ++L) {
                    if (q[L].seq) {
                        if (q[L].level != te)
                            continue;
                        Ce = !0,
                        U[q[L].seq] = 1,
                        he(q[L].callback, A, q[L].combo, q[L].seq);
                        continue
                    }
                    Ce || he(q[L].callback, A, q[L].combo)
                }
                var Ve = A.type == "keypress" && X;
                A.type == x && !p(de) && !Ve && j(U),
                X = Ce && A.type == "keydown"
            }
            ;
            function Re(de) {
                typeof de.which != "number" && (de.which = de.keyCode);
                var Ue = u(de);
                if (Ue) {
                    if (de.type == "keyup" && V === Ue) {
                        V = !1;
                        return
                    }
                    E.handleKey(Ue, d(de), de)
                }
            }
            function Xe() {
                clearTimeout(O),
                O = setTimeout(j, 1e3)
            }
            function pt(de, Ue, A, q) {
                F[de] = 0;
                function L(De) {
                    return function() {
                        x = De,
                        ++F[de],
                        Xe()
                    }
                }
                function U(De) {
                    he(A, De, de),
                    q !== "keyup" && (V = u(De)),
                    setTimeout(j, 10)
                }
                for (var te = 0; te < Ue.length; ++te) {
                    var Ce = te + 1 === Ue.length
                      , Ve = Ce ? U : L(q || w(Ue[te + 1]).action);
                    it(Ue[te], Ve, q, de, te)
                }
            }
            function it(de, Ue, A, q, L) {
                E._directMap[de + ":" + A] = Ue,
                de = de.replace(/\s+/g, " ");
                var U = de.split(" "), te;
                if (U.length > 1) {
                    pt(de, U, Ue, A);
                    return
                }
                te = w(de, A),
                E._callbacks[te.key] = E._callbacks[te.key] || [],
                fe(te.key, te.modifiers, {
                    type: te.action
                }, q, de, L),
                E._callbacks[te.key][q ? "unshift" : "push"]({
                    callback: Ue,
                    modifiers: te.modifiers,
                    action: te.action,
                    seq: q,
                    level: L,
                    combo: de
                })
            }
            E._bindMultiple = function(de, Ue, A) {
                for (var q = 0; q < de.length; ++q)
                    it(de[q], Ue, A)
            }
            ,
            l(N, "keypress", Re),
            l(N, "keydown", Re),
            l(N, "keyup", Re)
        }
        B.prototype.bind = function(N, E, F) {
            var O = this;
            return N = N instanceof Array ? N : [N],
            O._bindMultiple.call(O, N, E, F),
            O
        }
        ,
        B.prototype.unbind = function(N, E) {
            var F = this;
            return F.bind.call(F, N, function() {}, E)
        }
        ,
        B.prototype.trigger = function(N, E) {
            var F = this;
            return F._directMap[N + ":" + E] && F._directMap[N + ":" + E]({}, N),
            F
        }
        ,
        B.prototype.reset = function() {
            var N = this;
            return N._callbacks = {},
            N._directMap = {},
            N
        }
        ,
        B.prototype.stopCallback = function(N, E) {
            var F = this;
            if ((" " + E.className + " ").indexOf(" mousetrap ") > -1 || k(E, F.target))
                return !1;
            if ("composedPath"in N && typeof N.composedPath == "function") {
                var O = N.composedPath()[0];
                O !== N.target && (E = O)
            }
            return E.tagName == "INPUT" || E.tagName == "SELECT" || E.tagName == "TEXTAREA" || E.isContentEditable
        }
        ,
        B.prototype.handleKey = function() {
            var N = this;
            return N._handleKey.apply(N, arguments)
        }
        ,
        B.addKeycodes = function(N) {
            for (var E in N)
                N.hasOwnProperty(E) && (i[E] = N[E]);
            a = null
        }
        ,
        B.init = function() {
            var N = B(t);
            for (var E in N)
                E.charAt(0) !== "_" && (B[E] = function(F) {
                    return function() {
                        return N[F].apply(N, arguments)
                    }
                }(E))
        }
        ,
        B.init(),
        e.Mousetrap = B,
        typeof W2 < "u" && W2.exports && (W2.exports = B),
        typeof define == "function" && define.amd && define(function() {
            return B
        })
    }
    )(typeof window < "u" ? window : null, typeof window < "u" ? document : null)
}
);
var a_ = Object.prototype.toString;
function Lh(e) {
    switch (a_.call(e)) {
    case "[object Error]":
    case "[object Exception]":
    case "[object DOMException]":
        return !0;
    default:
        return Eo(e, Error)
    }
}
function $0(e, t) {
    return a_.call(e) === `[object ${t}]`
}
function j0(e) {
    return $0(e, "ErrorEvent")
}
function W5(e) {
    return $0(e, "DOMError")
}
function g4(e) {
    return $0(e, "DOMException")
}
function vr(e) {
    return $0(e, "String")
}
function q0(e) {
    return typeof e == "object" && e !== null && "__sentry_template_string__"in e && "__sentry_template_values__"in e
}
function ml(e) {
    return e === null || q0(e) || typeof e != "object" && typeof e != "function"
}
function Xs(e) {
    return $0(e, "Object")
}
function vl(e) {
    return typeof Event < "u" && Eo(e, Event)
}
function m4(e) {
    return typeof Element < "u" && Eo(e, Element)
}
function v4(e) {
    return $0(e, "RegExp")
}
function Co(e) {
    return !!(e && e.then && typeof e.then == "function")
}
function _4(e) {
    return Xs(e) && "nativeEvent"in e && "preventDefault"in e && "stopPropagation"in e
}
function y4(e) {
    return typeof e == "number" && e !== e
}
function Eo(e, t) {
    try {
        return e instanceof t
    } catch {
        return !1
    }
}
function Bh(e) {
    return !!(typeof e == "object" && e !== null && (e.__isVue || e._isVue))
}
function To(e, t=0) {
    return typeof e != "string" || t === 0 || e.length <= t ? e : `${e.slice(0, t)}...`
}
function $5(e, t) {
    if (!Array.isArray(e))
        return "";
    let n = [];
    for (let i = 0; i < e.length; i++) {
        let r = e[i];
        try {
            Bh(r) ? n.push("[VueViewModel]") : n.push(String(r))
        } catch {
            n.push("[value cannot be serialized]")
        }
    }
    return n.join(t)
}
function c_(e, t, n=!1) {
    return vr(e) ? v4(t) ? t.test(e) : vr(t) ? n ? e === t : e.includes(t) : !1 : !1
}
function z0(e, t=[], n=!1) {
    return t.some(i => c_(e, i, n))
}
function Uh(e, t, n=250, i, r, s, o) {
    if (!s.exception || !s.exception.values || !o || !Eo(o.originalException, Error))
        return;
    let a = s.exception.values.length > 0 ? s.exception.values[s.exception.values.length - 1] : void 0;
    a && (s.exception.values = WM(b4(e, t, r, o.originalException, i, s.exception.values, a, 0), n))
}
function b4(e, t, n, i, r, s, o, a) {
    if (s.length >= n + 1)
        return s;
    let c = [...s];
    if (Eo(i[r], Error)) {
        l_(o, a);
        let l = e(t, i[r])
          , u = c.length;
        u_(l, r, u, a),
        c = b4(e, t, n, i[r], r, [l, ...c], l, u)
    }
    return Array.isArray(i.errors) && i.errors.forEach( (l, u) => {
        if (Eo(l, Error)) {
            l_(o, a);
            let h = e(t, l)
              , d = c.length;
            u_(h, `errors[${u}]`, d, a),
            c = b4(e, t, n, l, r, [h, ...c], h, d)
        }
    }
    ),
    c
}
function l_(e, t) {
    e.mechanism = e.mechanism || {
        type: "generic",
        handled: !0
    },
    e.mechanism = ve(C(C({}, e.mechanism), e.type === "AggregateError" && {
        is_exception_group: !0
    }), {
        exception_id: t
    })
}
function u_(e, t, n, i) {
    e.mechanism = e.mechanism || {
        type: "generic",
        handled: !0
    },
    e.mechanism = ve(C({}, e.mechanism), {
        type: "chained",
        source: t,
        exception_id: n,
        parent_id: i
    })
}
function WM(e, t) {
    return e.map(n => (n.value && (n.value = To(n.value, t)),
    n))
}
function j5(e) {
    return e && e.Math == Math ? e : void 0
}
var ft = typeof globalThis == "object" && j5(globalThis) || typeof window == "object" && j5(window) || typeof self == "object" && j5(self) || typeof global == "object" && j5(global) || function() {
    return this
}() || {};
function _l() {
    return ft
}
function Hh(e, t, n) {
    let i = n || ft
      , r = i.__SENTRY__ = i.__SENTRY__ || {};
    return r[e] || (r[e] = t())
}
var S4 = _l()
  , $M = 80;
function Gh(e, t={}) {
    if (!e)
        return "<unknown>";
    try {
        let n = e, i = 5, r = [], s = 0, o = 0, a = " > ", c = a.length, l, u = Array.isArray(t) ? t : t.keyAttrs, h = !Array.isArray(t) && t.maxStringLength || $M;
        for (; n && s++ < i && (l = jM(n, u),
        !(l === "html" || s > 1 && o + r.length * c + l.length >= h)); )
            r.push(l),
            o += l.length,
            n = n.parentNode;
        return r.reverse().join(a)
    } catch {
        return "<unknown>"
    }
}
function jM(e, t) {
    let n = e, i = [], r, s, o, a, c;
    if (!n || !n.tagName)
        return "";
    if (S4.HTMLElement && n instanceof HTMLElement && n.dataset && n.dataset.sentryComponent)
        return n.dataset.sentryComponent;
    i.push(n.tagName.toLowerCase());
    let l = t && t.length ? t.filter(h => n.getAttribute(h)).map(h => [h, n.getAttribute(h)]) : null;
    if (l && l.length)
        l.forEach(h => {
            i.push(`[${h[0]}="${h[1]}"]`)
        }
        );
    else if (n.id && i.push(`#${n.id}`),
    r = n.className,
    r && vr(r))
        for (s = r.split(/\s+/),
        c = 0; c < s.length; c++)
            i.push(`.${s[c]}`);
    let u = ["aria-label", "type", "name", "title", "alt"];
    for (c = 0; c < u.length; c++)
        o = u[c],
        a = n.getAttribute(o),
        a && i.push(`[${o}="${a}"]`);
    return i.join("")
}
function x4() {
    try {
        return S4.document.location.href
    } catch {
        return ""
    }
}
function w4(e) {
    if (!S4.HTMLElement)
        return null;
    let t = e
      , n = 5;
    for (let i = 0; i < n; i++) {
        if (!t)
            return null;
        if (t instanceof HTMLElement && t.dataset.sentryComponent)
            return t.dataset.sentryComponent;
        t = t.parentNode
    }
    return null
}
var Oo = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__;
var qM = "Sentry Logger "
  , Vh = ["debug", "info", "warn", "error", "log", "assert", "trace"]
  , X0 = {};
function mc(e) {
    if (!("console"in ft))
        return e();
    let t = ft.console
      , n = {}
      , i = Object.keys(X0);
    i.forEach(r => {
        let s = X0[r];
        n[r] = t[r],
        t[r] = s
    }
    );
    try {
        return e()
    } finally {
        i.forEach(r => {
            t[r] = n[r]
        }
        )
    }
}
function zM() {
    let e = !1
      , t = {
        enable: () => {
            e = !0
        }
        ,
        disable: () => {
            e = !1
        }
        ,
        isEnabled: () => e
    };
    return Oo ? Vh.forEach(n => {
        t[n] = (...i) => {
            e && mc( () => {
                ft.console[n](`${qM}[${n}]:`, ...i)
            }
            )
        }
    }
    ) : Vh.forEach(n => {
        t[n] = () => {}
    }
    ),
    t
}
var We = zM();
var XM = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
function KM(e) {
    return e === "http" || e === "https"
}
function Ps(e, t=!1) {
    let {host: n, path: i, pass: r, port: s, projectId: o, protocol: a, publicKey: c} = e;
    return `${a}://${c}${t && r ? `:${r}` : ""}@${n}${s ? `:${s}` : ""}/${i && `${i}/`}${o}`
}
function h_(e) {
    let t = XM.exec(e);
    if (!t) {
        mc( () => {
            console.error(`Invalid Sentry Dsn: ${e}`)
        }
        );
        return
    }
    let[n,i,r="",s,o="",a] = t.slice(1)
      , c = ""
      , l = a
      , u = l.split("/");
    if (u.length > 1 && (c = u.slice(0, -1).join("/"),
    l = u.pop()),
    l) {
        let h = l.match(/^\d+/);
        h && (l = h[0])
    }
    return d_({
        host: s,
        pass: r,
        path: c,
        projectId: l,
        port: o,
        protocol: n,
        publicKey: i
    })
}
function d_(e) {
    return {
        protocol: e.protocol,
        publicKey: e.publicKey || "",
        pass: e.pass || "",
        host: e.host,
        port: e.port || "",
        path: e.path || "",
        projectId: e.projectId
    }
}
function YM(e) {
    if (!Oo)
        return !0;
    let {port: t, projectId: n, protocol: i} = e;
    return ["protocol", "publicKey", "host", "projectId"].find(o => e[o] ? !1 : (We.error(`Invalid Sentry Dsn: ${o} missing`),
    !0)) ? !1 : n.match(/^\d+$/) ? KM(i) ? t && isNaN(parseInt(t, 10)) ? (We.error(`Invalid Sentry Dsn: Invalid port ${t}`),
    !1) : !0 : (We.error(`Invalid Sentry Dsn: Invalid protocol ${i}`),
    !1) : (We.error(`Invalid Sentry Dsn: Invalid projectId ${n}`),
    !1)
}
function q5(e) {
    let t = typeof e == "string" ? h_(e) : d_(e);
    if (!(!t || !YM(t)))
        return t
}
var sr = class extends Error {
    constructor(t, n="warn") {
        super(t),
        this.message = t,
        this.name = new.target.prototype.constructor.name,
        Object.setPrototypeOf(this, new.target.prototype),
        this.logLevel = n
    }
}
;
function Sn(e, t, n) {
    if (!(t in e))
        return;
    let i = e[t]
      , r = n(i);
    typeof r == "function" && z5(r, i),
    e[t] = r
}
function fa(e, t, n) {
    try {
        Object.defineProperty(e, t, {
            value: n,
            writable: !0,
            configurable: !0
        })
    } catch {
        Oo && We.log(`Failed to add non-enumerable property "${t}" to object`, e)
    }
}
function z5(e, t) {
    try {
        let n = t.prototype || {};
        e.prototype = t.prototype = n,
        fa(e, "__sentry_original__", t)
    } catch {}
}
function yl(e) {
    return e.__sentry_original__
}
function E4(e) {
    return Object.keys(e).map(t => `${encodeURIComponent(t)}=${encodeURIComponent(e[t])}`).join("&")
}
function X5(e) {
    if (Lh(e))
        return C({
            message: e.message,
            name: e.name,
            stack: e.stack
        }, p_(e));
    if (vl(e)) {
        let t = C({
            type: e.type,
            target: f_(e.target),
            currentTarget: f_(e.currentTarget)
        }, p_(e));
        return typeof CustomEvent < "u" && Eo(e, CustomEvent) && (t.detail = e.detail),
        t
    } else
        return e
}
function f_(e) {
    try {
        return m4(e) ? Gh(e) : Object.prototype.toString.call(e)
    } catch {
        return "<unknown>"
    }
}
function p_(e) {
    if (typeof e == "object" && e !== null) {
        let t = {};
        for (let n in e)
            Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
        return t
    } else
        return {}
}
function T4(e, t=40) {
    let n = Object.keys(X5(e));
    if (n.sort(),
    !n.length)
        return "[object has no keys]";
    if (n[0].length >= t)
        return To(n[0], t);
    for (let i = n.length; i > 0; i--) {
        let r = n.slice(0, i).join(", ");
        if (!(r.length > t))
            return i === n.length ? r : To(r, t)
    }
    return ""
}
function _r(e) {
    return C4(e, new Map)
}
function C4(e, t) {
    if (QM(e)) {
        let n = t.get(e);
        if (n !== void 0)
            return n;
        let i = {};
        t.set(e, i);
        for (let r of Object.keys(e))
            typeof e[r] < "u" && (i[r] = C4(e[r], t));
        return i
    }
    if (Array.isArray(e)) {
        let n = t.get(e);
        if (n !== void 0)
            return n;
        let i = [];
        return t.set(e, i),
        e.forEach(r => {
            i.push(C4(r, t))
        }
        ),
        i
    }
    return e
}
function QM(e) {
    if (!Xs(e))
        return !1;
    try {
        let t = Object.getPrototypeOf(e).constructor.name;
        return !t || t === "Object"
    } catch {
        return !0
    }
}
var v_ = 50
  , g_ = /\(error: (.*)\)/
  , m_ = /captureMessage|captureException/;
function K5(...e) {
    let t = e.sort( (n, i) => n[0] - i[0]).map(n => n[1]);
    return (n, i=0) => {
        let r = []
          , s = n.split(`
`);
        for (let o = i; o < s.length; o++) {
            let a = s[o];
            if (a.length > 1024)
                continue;
            let c = g_.test(a) ? a.replace(g_, "$1") : a;
            if (!c.match(/\S*Error: /)) {
                for (let l of t) {
                    let u = l(c);
                    if (u) {
                        r.push(u);
                        break
                    }
                }
                if (r.length >= v_)
                    break
            }
        }
        return __(r)
    }
}
function P4(e) {
    return Array.isArray(e) ? K5(...e) : e
}
function __(e) {
    if (!e.length)
        return [];
    let t = Array.from(e);
    return /sentryWrapped/.test(t[t.length - 1].function || "") && t.pop(),
    t.reverse(),
    m_.test(t[t.length - 1].function || "") && (t.pop(),
    m_.test(t[t.length - 1].function || "") && t.pop()),
    t.slice(0, v_).map(n => ve(C({}, n), {
        filename: n.filename || t[t.length - 1].filename,
        function: n.function || "?"
    }))
}
var O4 = "<anonymous>";
function Ms(e) {
    try {
        return !e || typeof e != "function" ? O4 : e.name || O4
    } catch {
        return O4
    }
}
var Y5 = {}
  , y_ = {};
function Gr(e, t) {
    Y5[e] = Y5[e] || [],
    Y5[e].push(t)
}
function Vr(e, t) {
    y_[e] || (t(),
    y_[e] = !0)
}
function Ci(e, t) {
    let n = e && Y5[e];
    if (n)
        for (let i of n)
            try {
                i(t)
            } catch (r) {
                Oo && We.error(`Error while triggering instrumentation handler.
Type: ${e}
Name: ${Ms(i)}
Error:`, r)
            }
}
function M4(e) {
    let t = "console";
    Gr(t, e),
    Vr(t, JM)
}
function JM() {
    "console"in ft && Vh.forEach(function(e) {
        e in ft.console && Sn(ft.console, e, function(t) {
            return X0[e] = t,
            function(...n) {
                Ci("console", {
                    args: n,
                    level: e
                });
                let r = X0[e];
                r && r.apply(ft.console, n)
            }
        })
    })
}
function di() {
    let e = ft
      , t = e.crypto || e.msCrypto
      , n = () => Math.random() * 16;
    try {
        if (t && t.randomUUID)
            return t.randomUUID().replace(/-/g, "");
        t && t.getRandomValues && (n = () => {
            let i = new Uint8Array(1);
            return t.getRandomValues(i),
            i[0]
        }
        )
    } catch {}
    return ("10000000100040008000" + 1e11).replace(/[018]/g, i => (i ^ (n() & 15) >> i / 4).toString(16))
}
function b_(e) {
    return e.exception && e.exception.values ? e.exception.values[0] : void 0
}
function Ks(e) {
    let {message: t, event_id: n} = e;
    if (t)
        return t;
    let i = b_(e);
    return i ? i.type && i.value ? `${i.type}: ${i.value}` : i.type || i.value || n || "<unknown>" : n || "<unknown>"
}
function K0(e, t, n) {
    let i = e.exception = e.exception || {}
      , r = i.values = i.values || []
      , s = r[0] = r[0] || {};
    s.value || (s.value = t || ""),
    s.type || (s.type = n || "Error")
}
function pa(e, t) {
    let n = b_(e);
    if (!n)
        return;
    let i = {
        type: "generic",
        handled: !0
    }
      , r = n.mechanism;
    if (n.mechanism = C(C(C({}, i), r), t),
    t && "data"in t) {
        let s = C(C({}, r && r.data), t.data);
        n.mechanism.data = s
    }
}
function Q5(e) {
    if (e && e.__sentry_captured__)
        return !0;
    try {
        fa(e, "__sentry_captured__", !0)
    } catch {}
    return !1
}
function Wh(e) {
    return Array.isArray(e) ? e : [e]
}
var Y0 = ft, ZM = 1e3, S_, k4, A4;
function I4(e) {
    let t = "dom";
    Gr(t, e),
    Vr(t, ek)
}
function ek() {
    if (!Y0.document)
        return;
    let e = Ci.bind(null, "dom")
      , t = x_(e, !0);
    Y0.document.addEventListener("click", t, !1),
    Y0.document.addEventListener("keypress", t, !1),
    ["EventTarget", "Node"].forEach(n => {
        let i = Y0[n] && Y0[n].prototype;
        !i || !i.hasOwnProperty || !i.hasOwnProperty("addEventListener") || (Sn(i, "addEventListener", function(r) {
            return function(s, o, a) {
                if (s === "click" || s == "keypress")
                    try {
                        let c = this
                          , l = c.__sentry_instrumentation_handlers__ = c.__sentry_instrumentation_handlers__ || {}
                          , u = l[s] = l[s] || {
                            refCount: 0
                        };
                        if (!u.handler) {
                            let h = x_(e);
                            u.handler = h,
                            r.call(this, s, h, a)
                        }
                        u.refCount++
                    } catch {}
                return r.call(this, s, o, a)
            }
        }),
        Sn(i, "removeEventListener", function(r) {
            return function(s, o, a) {
                if (s === "click" || s == "keypress")
                    try {
                        let c = this
                          , l = c.__sentry_instrumentation_handlers__ || {}
                          , u = l[s];
                        u && (u.refCount--,
                        u.refCount <= 0 && (r.call(this, s, u.handler, a),
                        u.handler = void 0,
                        delete l[s]),
                        Object.keys(l).length === 0 && delete c.__sentry_instrumentation_handlers__)
                    } catch {}
                return r.call(this, s, o, a)
            }
        }))
    }
    )
}
function tk(e) {
    if (e.type !== k4)
        return !1;
    try {
        if (!e.target || e.target._sentryId !== A4)
            return !1
    } catch {}
    return !0
}
function nk(e, t) {
    return e !== "keypress" ? !1 : !t || !t.tagName ? !0 : !(t.tagName === "INPUT" || t.tagName === "TEXTAREA" || t.isContentEditable)
}
function x_(e, t=!1) {
    return n => {
        if (!n || n._sentryCaptured)
            return;
        let i = ik(n);
        if (nk(n.type, i))
            return;
        fa(n, "_sentryCaptured", !0),
        i && !i._sentryId && fa(i, "_sentryId", di());
        let r = n.type === "keypress" ? "input" : n.type;
        tk(n) || (e({
            event: n,
            name: r,
            global: t
        }),
        k4 = n.type,
        A4 = i ? i._sentryId : void 0),
        clearTimeout(S_),
        S_ = Y0.setTimeout( () => {
            A4 = void 0,
            k4 = void 0
        }
        , ZM)
    }
}
function ik(e) {
    try {
        return e.target
    } catch {
        return null
    }
}
var R4 = _l();
function J5() {
    if (!("fetch"in R4))
        return !1;
    try {
        return new Headers,
        new Request("http://www.example.com"),
        new Response,
        !0
    } catch {
        return !1
    }
}
function $h(e) {
    return e && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(e.toString())
}
function D4() {
    if (typeof EdgeRuntime == "string")
        return !0;
    if (!J5())
        return !1;
    if ($h(R4.fetch))
        return !0;
    let e = !1
      , t = R4.document;
    if (t && typeof t.createElement == "function")
        try {
            let n = t.createElement("iframe");
            n.hidden = !0,
            t.head.appendChild(n),
            n.contentWindow && n.contentWindow.fetch && (e = $h(n.contentWindow.fetch)),
            t.head.removeChild(n)
        } catch (n) {
            Oo && We.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", n)
        }
    return e
}
function F4(e) {
    let t = "fetch";
    Gr(t, e),
    Vr(t, rk)
}
function rk() {
    D4() && Sn(ft, "fetch", function(e) {
        return function(...t) {
            let {method: n, url: i} = sk(t)
              , r = {
                args: t,
                fetchData: {
                    method: n,
                    url: i
                },
                startTimestamp: Date.now()
            };
            return Ci("fetch", C({}, r)),
            e.apply(ft, t).then(s => {
                let o = ve(C({}, r), {
                    endTimestamp: Date.now(),
                    response: s
                });
                return Ci("fetch", o),
                s
            }
            , s => {
                let o = ve(C({}, r), {
                    endTimestamp: Date.now(),
                    error: s
                });
                throw Ci("fetch", o),
                s
            }
            )
        }
    })
}
function N4(e, t) {
    return !!e && typeof e == "object" && !!e[t]
}
function w_(e) {
    return typeof e == "string" ? e : e ? N4(e, "url") ? e.url : e.toString ? e.toString() : "" : ""
}
function sk(e) {
    if (e.length === 0)
        return {
            method: "GET",
            url: ""
        };
    if (e.length === 2) {
        let[n,i] = e;
        return {
            url: w_(n),
            method: N4(i, "method") ? String(i.method).toUpperCase() : "GET"
        }
    }
    let t = e[0];
    return {
        url: w_(t),
        method: N4(t, "method") ? String(t.method).toUpperCase() : "GET"
    }
}
var Z5 = null;
function L4(e) {
    let t = "error";
    Gr(t, e),
    Vr(t, ok)
}
function ok() {
    Z5 = ft.onerror,
    ft.onerror = function(e, t, n, i, r) {
        return Ci("error", {
            column: i,
            error: r,
            line: n,
            msg: e,
            url: t
        }),
        Z5 && !Z5.__SENTRY_LOADER__ ? Z5.apply(this, arguments) : !1
    }
    ,
    ft.onerror.__SENTRY_INSTRUMENTED__ = !0
}
var ef = null;
function B4(e) {
    let t = "unhandledrejection";
    Gr(t, e),
    Vr(t, ak)
}
function ak() {
    ef = ft.onunhandledrejection,
    ft.onunhandledrejection = function(e) {
        return Ci("unhandledrejection", e),
        ef && !ef.__SENTRY_LOADER__ ? ef.apply(this, arguments) : !0
    }
    ,
    ft.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0
}
var tf = _l();
function C_() {
    let e = tf.chrome
      , t = e && e.app && e.app.runtime
      , n = "history"in tf && !!tf.history.pushState && !!tf.history.replaceState;
    return !t && n
}
var jh = ft, nf;
function qh(e) {
    let t = "history";
    Gr(t, e),
    Vr(t, ck)
}
function ck() {
    if (!C_())
        return;
    let e = jh.onpopstate;
    jh.onpopstate = function(...n) {
        let i = jh.location.href
          , r = nf;
        if (nf = i,
        Ci("history", {
            from: r,
            to: i
        }),
        e)
            try {
                return e.apply(this, n)
            } catch {}
    }
    ;
    function t(n) {
        return function(...i) {
            let r = i.length > 2 ? i[2] : void 0;
            if (r) {
                let s = nf
                  , o = String(r);
                nf = o,
                Ci("history", {
                    from: s,
                    to: o
                })
            }
            return n.apply(this, i)
        }
    }
    Sn(jh.history, "pushState", t),
    Sn(jh.history, "replaceState", t)
}
var lk = ft
  , bl = "__sentry_xhr_v3__";
function U4(e) {
    let t = "xhr";
    Gr(t, e),
    Vr(t, uk)
}
function uk() {
    if (!lk.XMLHttpRequest)
        return;
    let e = XMLHttpRequest.prototype;
    Sn(e, "open", function(t) {
        return function(...n) {
            let i = Date.now()
              , r = vr(n[0]) ? n[0].toUpperCase() : void 0
              , s = hk(n[1]);
            if (!r || !s)
                return t.apply(this, n);
            this[bl] = {
                method: r,
                url: s,
                request_headers: {}
            },
            r === "POST" && s.match(/sentry_key/) && (this.__sentry_own_request__ = !0);
            let o = () => {
                let a = this[bl];
                if (a && this.readyState === 4) {
                    try {
                        a.status_code = this.status
                    } catch {}
                    let c = {
                        args: [r, s],
                        endTimestamp: Date.now(),
                        startTimestamp: i,
                        xhr: this
                    };
                    Ci("xhr", c)
                }
            }
            ;
            return "onreadystatechange"in this && typeof this.onreadystatechange == "function" ? Sn(this, "onreadystatechange", function(a) {
                return function(...c) {
                    return o(),
                    a.apply(this, c)
                }
            }) : this.addEventListener("readystatechange", o),
            Sn(this, "setRequestHeader", function(a) {
                return function(...c) {
                    let[l,u] = c
                      , h = this[bl];
                    return h && vr(l) && vr(u) && (h.request_headers[l.toLowerCase()] = u),
                    a.apply(this, c)
                }
            }),
            t.apply(this, n)
        }
    }),
    Sn(e, "send", function(t) {
        return function(...n) {
            let i = this[bl];
            if (!i)
                return t.apply(this, n);
            n[0] !== void 0 && (i.body = n[0]);
            let r = {
                args: [i.method, i.url],
                startTimestamp: Date.now(),
                xhr: this
            };
            return Ci("xhr", r),
            t.apply(this, n)
        }
    })
}
function hk(e) {
    if (vr(e))
        return e;
    try {
        return e.toString()
    } catch {}
}
function H4() {
    return "npm"
}
function E_() {
    let e = typeof WeakSet == "function"
      , t = e ? new WeakSet : [];
    function n(r) {
        if (e)
            return t.has(r) ? !0 : (t.add(r),
            !1);
        for (let s = 0; s < t.length; s++)
            if (t[s] === r)
                return !0;
        return t.push(r),
        !1
    }
    function i(r) {
        if (e)
            t.delete(r);
        else
            for (let s = 0; s < t.length; s++)
                if (t[s] === r) {
                    t.splice(s, 1);
                    break
                }
    }
    return [n, i]
}
function Ys(e, t=100, n=1 / 0) {
    try {
        return rf("", e, t, n)
    } catch (i) {
        return {
            ERROR: `**non-serializable** (${i})`
        }
    }
}
function sf(e, t=3, n=100 * 1024) {
    let i = Ys(e, t);
    return gk(i) > n ? sf(e, t - 1, n) : i
}
function rf(e, t, n=1 / 0, i=1 / 0, r=E_()) {
    let[s,o] = r;
    if (t == null || ["number", "boolean", "string"].includes(typeof t) && !y4(t))
        return t;
    let a = dk(e, t);
    if (!a.startsWith("[object "))
        return a;
    if (t.__sentry_skip_normalization__)
        return t;
    let c = typeof t.__sentry_override_normalization_depth__ == "number" ? t.__sentry_override_normalization_depth__ : n;
    if (c === 0)
        return a.replace("object ", "");
    if (s(t))
        return "[Circular ~]";
    let l = t;
    if (l && typeof l.toJSON == "function")
        try {
            let f = l.toJSON();
            return rf("", f, c - 1, i, r)
        } catch {}
    let u = Array.isArray(t) ? [] : {}
      , h = 0
      , d = X5(t);
    for (let f in d) {
        if (!Object.prototype.hasOwnProperty.call(d, f))
            continue;
        if (h >= i) {
            u[f] = "[MaxProperties ~]";
            break
        }
        let g = d[f];
        u[f] = rf(f, g, c - 1, i, r),
        h++
    }
    return o(t),
    u
}
function dk(e, t) {
    try {
        if (e === "domain" && t && typeof t == "object" && t._events)
            return "[Domain]";
        if (e === "domainEmitter")
            return "[DomainEmitter]";
        if (typeof global < "u" && t === global)
            return "[Global]";
        if (typeof window < "u" && t === window)
            return "[Window]";
        if (typeof document < "u" && t === document)
            return "[Document]";
        if (Bh(t))
            return "[VueViewModel]";
        if (_4(t))
            return "[SyntheticEvent]";
        if (typeof t == "number" && t !== t)
            return "[NaN]";
        if (typeof t == "function")
            return `[Function: ${Ms(t)}]`;
        if (typeof t == "symbol")
            return `[${String(t)}]`;
        if (typeof t == "bigint")
            return `[BigInt: ${String(t)}]`;
        let n = fk(t);
        return /^HTML(\w*)Element$/.test(n) ? `[HTMLElement: ${n}]` : `[object ${n}]`
    } catch (n) {
        return `**non-serializable** (${n})`
    }
}
function fk(e) {
    let t = Object.getPrototypeOf(e);
    return t ? t.constructor.name : "null prototype"
}
function pk(e) {
    return ~-encodeURI(e).split(/%..|./).length
}
function gk(e) {
    return pk(JSON.stringify(e))
}
var ga;
(function(e) {
    e[e.PENDING = 0] = "PENDING";
    let n = 1;
    e[e.RESOLVED = n] = "RESOLVED";
    let i = 2;
    e[e.REJECTED = i] = "REJECTED"
}
)(ga || (ga = {}));
function Qs(e) {
    return new ds(t => {
        t(e)
    }
    )
}
function Sl(e) {
    return new ds( (t, n) => {
        n(e)
    }
    )
}
var ds = class e {
    constructor(t) {
        e.prototype.__init.call(this),
        e.prototype.__init2.call(this),
        e.prototype.__init3.call(this),
        e.prototype.__init4.call(this),
        this._state = ga.PENDING,
        this._handlers = [];
        try {
            t(this._resolve, this._reject)
        } catch (n) {
            this._reject(n)
        }
    }
    then(t, n) {
        return new e( (i, r) => {
            this._handlers.push([!1, s => {
                if (!t)
                    i(s);
                else
                    try {
                        i(t(s))
                    } catch (o) {
                        r(o)
                    }
            }
            , s => {
                if (!n)
                    r(s);
                else
                    try {
                        i(n(s))
                    } catch (o) {
                        r(o)
                    }
            }
            ]),
            this._executeHandlers()
        }
        )
    }
    catch(t) {
        return this.then(n => n, t)
    }
    finally(t) {
        return new e( (n, i) => {
            let r, s;
            return this.then(o => {
                s = !1,
                r = o,
                t && t()
            }
            , o => {
                s = !0,
                r = o,
                t && t()
            }
            ).then( () => {
                if (s) {
                    i(r);
                    return
                }
                n(r)
            }
            )
        }
        )
    }
    __init() {
        this._resolve = t => {
            this._setResult(ga.RESOLVED, t)
        }
    }
    __init2() {
        this._reject = t => {
            this._setResult(ga.REJECTED, t)
        }
    }
    __init3() {
        this._setResult = (t, n) => {
            if (this._state === ga.PENDING) {
                if (Co(n)) {
                    n.then(this._resolve, this._reject);
                    return
                }
                this._state = t,
                this._value = n,
                this._executeHandlers()
            }
        }
    }
    __init4() {
        this._executeHandlers = () => {
            if (this._state === ga.PENDING)
                return;
            let t = this._handlers.slice();
            this._handlers = [],
            t.forEach(n => {
                n[0] || (this._state === ga.RESOLVED && n[1](this._value),
                this._state === ga.REJECTED && n[2](this._value),
                n[0] = !0)
            }
            )
        }
    }
}
;
function G4(e) {
    let t = [];
    function n() {
        return e === void 0 || t.length < e
    }
    function i(o) {
        return t.splice(t.indexOf(o), 1)[0]
    }
    function r(o) {
        if (!n())
            return Sl(new sr("Not adding Promise because buffer limit was reached."));
        let a = o();
        return t.indexOf(a) === -1 && t.push(a),
        a.then( () => i(a)).then(null, () => i(a).then(null, () => {}
        )),
        a
    }
    function s(o) {
        return new ds( (a, c) => {
            let l = t.length;
            if (!l)
                return a(!0);
            let u = setTimeout( () => {
                o && o > 0 && a(!1)
            }
            , o);
            t.forEach(h => {
                Qs(h).then( () => {
                    --l || (clearTimeout(u),
                    a(!0))
                }
                , c)
            }
            )
        }
        )
    }
    return {
        $: t,
        add: r,
        drain: s
    }
}
function zh(e) {
    if (!e)
        return {};
    let t = e.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
    if (!t)
        return {};
    let n = t[6] || ""
      , i = t[8] || "";
    return {
        host: t[4],
        path: t[5],
        protocol: t[2],
        search: n,
        hash: i,
        relative: t[5] + n + i
    }
}
var T_ = ["fatal", "error", "warning", "log", "info", "debug"];
function V4(e) {
    return e === "warn" ? "warning" : T_.includes(e) ? e : "log"
}
var O_ = 1e3;
function Po() {
    return Date.now() / O_
}
function mk() {
    let {performance: e} = ft;
    if (!e || !e.now)
        return Po;
    let t = Date.now() - e.now()
      , n = e.timeOrigin == null ? t : e.timeOrigin;
    return () => (n + e.now()) / O_
}
var xl = mk();
var Xh, vk = ( () => {
    let {performance: e} = ft;
    if (!e || !e.now) {
        Xh = "none";
        return
    }
    let t = 3600 * 1e3
      , n = e.now()
      , i = Date.now()
      , r = e.timeOrigin ? Math.abs(e.timeOrigin + n - i) : t
      , s = r < t
      , o = e.timing && e.timing.navigationStart
      , c = typeof o == "number" ? Math.abs(o + n - i) : t
      , l = c < t;
    return s || l ? r <= c ? (Xh = "timeOrigin",
    e.timeOrigin) : (Xh = "navigationStart",
    o) : (Xh = "dateNow",
    i)
}
)();
function ks(e, t=[]) {
    return [e, t]
}
function $4(e, t) {
    let[n,i] = e;
    return [n, [...i, t]]
}
function of(e, t) {
    let n = e[1];
    for (let i of n) {
        let r = i[0].type;
        if (t(i, r))
            return !0
    }
    return !1
}
function W4(e, t) {
    return (t || new TextEncoder).encode(e)
}
function j4(e, t) {
    let[n,i] = e
      , r = JSON.stringify(n);
    function s(o) {
        typeof r == "string" ? r = typeof o == "string" ? r + o : [W4(r, t), o] : r.push(typeof o == "string" ? W4(o, t) : o)
    }
    for (let o of i) {
        let[a,c] = o;
        if (s(`
${JSON.stringify(a)}
`),
        typeof c == "string" || c instanceof Uint8Array)
            s(c);
        else {
            let l;
            try {
                l = JSON.stringify(c)
            } catch {
                l = JSON.stringify(Ys(c))
            }
            s(l)
        }
    }
    return typeof r == "string" ? r : _k(r)
}
function _k(e) {
    let t = e.reduce( (r, s) => r + s.length, 0)
      , n = new Uint8Array(t)
      , i = 0;
    for (let r of e)
        n.set(r, i),
        i += r.length;
    return n
}
function q4(e, t) {
    let n = typeof e.data == "string" ? W4(e.data, t) : e.data;
    return [_r({
        type: "attachment",
        length: n.length,
        filename: e.filename,
        content_type: e.contentType,
        attachment_type: e.attachmentType
    }), n]
}
var yk = {
    session: "session",
    sessions: "session",
    attachment: "attachment",
    transaction: "transaction",
    event: "error",
    client_report: "internal",
    user_report: "default",
    profile: "profile",
    replay_event: "replay",
    replay_recording: "replay",
    check_in: "monitor",
    feedback: "feedback",
    span: "span",
    statsd: "metric_bucket"
};
function af(e) {
    return yk[e]
}
function cf(e) {
    if (!e || !e.sdk)
        return;
    let {name: t, version: n} = e.sdk;
    return {
        name: t,
        version: n
    }
}
function z4(e, t, n, i) {
    let r = e.sdkProcessingMetadata && e.sdkProcessingMetadata.dynamicSamplingContext;
    return C(C(C({
        event_id: e.event_id,
        sent_at: new Date().toISOString()
    }, t && {
        sdk: t
    }), !!n && i && {
        dsn: Ps(i)
    }), r && {
        trace: _r(C({}, r))
    })
}
function X4(e, t, n) {
    let i = [{
        type: "client_report"
    }, {
        timestamp: n || Po(),
        discarded_events: e
    }];
    return ks(t ? {
        dsn: t
    } : {}, [i])
}
function P_(e, t=Date.now()) {
    let n = parseInt(`${e}`, 10);
    if (!isNaN(n))
        return n * 1e3;
    let i = Date.parse(`${e}`);
    return isNaN(i) ? 6e4 : i - t
}
function M_(e, t) {
    return e[t] || e.all || 0
}
function K4(e, t, n=Date.now()) {
    return M_(e, t) > n
}
function Y4(e, {statusCode: t, headers: n}, i=Date.now()) {
    let r = C({}, e)
      , s = n && n["x-sentry-rate-limits"]
      , o = n && n["retry-after"];
    if (s)
        for (let a of s.trim().split(",")) {
            let[c,l,,,u] = a.split(":", 5)
              , h = parseInt(c, 10)
              , d = (isNaN(h) ? 60 : h) * 1e3;
            if (!l)
                r.all = i + d;
            else
                for (let f of l.split(";"))
                    f === "metric_bucket" ? (!u || u.split(";").includes("custom")) && (r[f] = i + d) : r[f] = i + d
        }
    else
        o ? r.all = i + P_(o, i) : t === 429 && (r.all = i + 60 * 1e3);
    return r
}
function k_(e, t) {
    return e(t.stack || "", 1)
}
function Q4(e, t) {
    let n = {
        type: t.name || t.constructor.name,
        value: t.message
    }
      , i = k_(e, t);
    return i.length && (n.stacktrace = {
        frames: i
    }),
    n
}
var vc = "production";
var Gt = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__;
function Kh() {
    return Hh("globalEventProcessors", () => [])
}
function J4(e) {
    Kh().push(e)
}
function Q0(e, t, n, i=0) {
    return new ds( (r, s) => {
        let o = e[i];
        if (t === null || typeof o != "function")
            r(t);
        else {
            let a = o(C({}, t), n);
            Gt && o.id && a === null && We.log(`Event processor "${o.id}" dropped event`),
            Co(a) ? a.then(c => Q0(e, c, n, i + 1).then(r)).then(null, s) : Q0(e, a, n, i + 1).then(r).then(null, s)
        }
    }
    )
}
function lf(e) {
    let t = xl()
      , n = {
        sid: di(),
        init: !0,
        timestamp: t,
        started: t,
        duration: 0,
        status: "ok",
        errors: 0,
        ignoreDuration: !1,
        toJSON: () => Sk(n)
    };
    return e && Js(n, e),
    n
}
function Js(e, t={}) {
    if (t.user && (!e.ipAddress && t.user.ip_address && (e.ipAddress = t.user.ip_address),
    !e.did && !t.did && (e.did = t.user.id || t.user.email || t.user.username)),
    e.timestamp = t.timestamp || xl(),
    t.abnormal_mechanism && (e.abnormal_mechanism = t.abnormal_mechanism),
    t.ignoreDuration && (e.ignoreDuration = t.ignoreDuration),
    t.sid && (e.sid = t.sid.length === 32 ? t.sid : di()),
    t.init !== void 0 && (e.init = t.init),
    !e.did && t.did && (e.did = `${t.did}`),
    typeof t.started == "number" && (e.started = t.started),
    e.ignoreDuration)
        e.duration = void 0;
    else if (typeof t.duration == "number")
        e.duration = t.duration;
    else {
        let n = e.timestamp - e.started;
        e.duration = n >= 0 ? n : 0
    }
    t.release && (e.release = t.release),
    t.environment && (e.environment = t.environment),
    !e.ipAddress && t.ipAddress && (e.ipAddress = t.ipAddress),
    !e.userAgent && t.userAgent && (e.userAgent = t.userAgent),
    typeof t.errors == "number" && (e.errors = t.errors),
    t.status && (e.status = t.status)
}
function uf(e, t) {
    let n = {};
    t ? n = {
        status: t
    } : e.status === "ok" && (n = {
        status: "exited"
    }),
    Js(e, n)
}
function Sk(e) {
    return _r({
        sid: `${e.sid}`,
        init: e.init,
        started: new Date(e.started * 1e3).toISOString(),
        timestamp: new Date(e.timestamp * 1e3).toISOString(),
        status: e.status,
        errors: e.errors,
        did: typeof e.did == "number" || typeof e.did == "string" ? `${e.did}` : void 0,
        duration: e.duration,
        abnormal_mechanism: e.abnormal_mechanism,
        attrs: {
            release: e.release,
            environment: e.environment,
            ip_address: e.ipAddress,
            user_agent: e.userAgent
        }
    })
}
function hf(e) {
    return e.transaction
}
var xk = 1;
function A_(e) {
    let {spanId: t, traceId: n} = e.spanContext()
      , {data: i, op: r, parent_span_id: s, status: o, tags: a, origin: c} = ma(e);
    return _r({
        data: i,
        op: r,
        parent_span_id: s,
        span_id: t,
        status: o,
        tags: a,
        trace_id: n,
        origin: c
    })
}
function ma(e) {
    return wk(e) ? e.getSpanJSON() : typeof e.toJSON == "function" ? e.toJSON() : {}
}
function wk(e) {
    return typeof e.getSpanJSON == "function"
}
function I_(e) {
    let {traceFlags: t} = e.spanContext();
    return !!(t & xk)
}
function Z4(e, t, n) {
    let i = t.getOptions()
      , {publicKey: r} = t.getDsn() || {}
      , {segment: s} = n && n.getUser() || {}
      , o = _r({
        environment: i.environment || vc,
        release: i.release,
        user_segment: s,
        public_key: r,
        trace_id: e
    });
    return t.emit && t.emit("createDsc", o),
    o
}
function R_(e) {
    let t = Mn();
    if (!t)
        return {};
    let n = Z4(ma(e).trace_id || "", t, Mo())
      , i = hf(e);
    if (!i)
        return n;
    let r = i && i._frozenDynamicSamplingContext;
    if (r)
        return r;
    let {sampleRate: s, source: o} = i.metadata;
    s != null && (n.sample_rate = `${s}`);
    let a = ma(i);
    return o && o !== "url" && (n.transaction = a.description),
    n.sampled = String(I_(i)),
    t.emit && t.emit("createDsc", n),
    n
}
function df(e, t) {
    let {fingerprint: n, span: i, breadcrumbs: r, sdkProcessingMetadata: s} = t;
    Ck(e, t),
    i && Ok(e, i),
    Pk(e, n),
    Ek(e, r),
    Tk(e, s)
}
function e6(e, t) {
    let {extra: n, tags: i, user: r, contexts: s, level: o, sdkProcessingMetadata: a, breadcrumbs: c, fingerprint: l, eventProcessors: u, attachments: h, propagationContext: d, transactionName: f, span: g} = t;
    Yh(e, "extra", n),
    Yh(e, "tags", i),
    Yh(e, "user", r),
    Yh(e, "contexts", s),
    Yh(e, "sdkProcessingMetadata", a),
    o && (e.level = o),
    f && (e.transactionName = f),
    g && (e.span = g),
    c.length && (e.breadcrumbs = [...e.breadcrumbs, ...c]),
    l.length && (e.fingerprint = [...e.fingerprint, ...l]),
    u.length && (e.eventProcessors = [...e.eventProcessors, ...u]),
    h.length && (e.attachments = [...e.attachments, ...h]),
    e.propagationContext = C(C({}, e.propagationContext), d)
}
function Yh(e, t, n) {
    if (n && Object.keys(n).length) {
        e[t] = C({}, e[t]);
        for (let i in n)
            Object.prototype.hasOwnProperty.call(n, i) && (e[t][i] = n[i])
    }
}
function Ck(e, t) {
    let {extra: n, tags: i, user: r, contexts: s, level: o, transactionName: a} = t
      , c = _r(n);
    c && Object.keys(c).length && (e.extra = C(C({}, c), e.extra));
    let l = _r(i);
    l && Object.keys(l).length && (e.tags = C(C({}, l), e.tags));
    let u = _r(r);
    u && Object.keys(u).length && (e.user = C(C({}, u), e.user));
    let h = _r(s);
    h && Object.keys(h).length && (e.contexts = C(C({}, h), e.contexts)),
    o && (e.level = o),
    a && (e.transaction = a)
}
function Ek(e, t) {
    let n = [...e.breadcrumbs || [], ...t];
    e.breadcrumbs = n.length ? n : void 0
}
function Tk(e, t) {
    e.sdkProcessingMetadata = C(C({}, e.sdkProcessingMetadata), t)
}
function Ok(e, t) {
    e.contexts = C({
        trace: A_(t)
    }, e.contexts);
    let n = hf(t);
    if (n) {
        e.sdkProcessingMetadata = C({
            dynamicSamplingContext: R_(t)
        }, e.sdkProcessingMetadata);
        let i = ma(n).description;
        i && (e.tags = C({
            transaction: i
        }, e.tags))
    }
}
function Pk(e, t) {
    e.fingerprint = e.fingerprint ? Wh(e.fingerprint) : [],
    t && (e.fingerprint = e.fingerprint.concat(t)),
    e.fingerprint && !e.fingerprint.length && delete e.fingerprint
}
var Mk = 100, t6, ko = class e {
    constructor() {
        this._notifyingListeners = !1,
        this._scopeListeners = [],
        this._eventProcessors = [],
        this._breadcrumbs = [],
        this._attachments = [],
        this._user = {},
        this._tags = {},
        this._extra = {},
        this._contexts = {},
        this._sdkProcessingMetadata = {},
        this._propagationContext = D_()
    }
    static clone(t) {
        return t ? t.clone() : new e
    }
    clone() {
        let t = new e;
        return t._breadcrumbs = [...this._breadcrumbs],
        t._tags = C({}, this._tags),
        t._extra = C({}, this._extra),
        t._contexts = C({}, this._contexts),
        t._user = this._user,
        t._level = this._level,
        t._span = this._span,
        t._session = this._session,
        t._transactionName = this._transactionName,
        t._fingerprint = this._fingerprint,
        t._eventProcessors = [...this._eventProcessors],
        t._requestSession = this._requestSession,
        t._attachments = [...this._attachments],
        t._sdkProcessingMetadata = C({}, this._sdkProcessingMetadata),
        t._propagationContext = C({}, this._propagationContext),
        t._client = this._client,
        t
    }
    setClient(t) {
        this._client = t
    }
    getClient() {
        return this._client
    }
    addScopeListener(t) {
        this._scopeListeners.push(t)
    }
    addEventProcessor(t) {
        return this._eventProcessors.push(t),
        this
    }
    setUser(t) {
        return this._user = t || {
            email: void 0,
            id: void 0,
            ip_address: void 0,
            segment: void 0,
            username: void 0
        },
        this._session && Js(this._session, {
            user: t
        }),
        this._notifyScopeListeners(),
        this
    }
    getUser() {
        return this._user
    }
    getRequestSession() {
        return this._requestSession
    }
    setRequestSession(t) {
        return this._requestSession = t,
        this
    }
    setTags(t) {
        return this._tags = C(C({}, this._tags), t),
        this._notifyScopeListeners(),
        this
    }
    setTag(t, n) {
        return this._tags = ve(C({}, this._tags), {
            [t]: n
        }),
        this._notifyScopeListeners(),
        this
    }
    setExtras(t) {
        return this._extra = C(C({}, this._extra), t),
        this._notifyScopeListeners(),
        this
    }
    setExtra(t, n) {
        return this._extra = ve(C({}, this._extra), {
            [t]: n
        }),
        this._notifyScopeListeners(),
        this
    }
    setFingerprint(t) {
        return this._fingerprint = t,
        this._notifyScopeListeners(),
        this
    }
    setLevel(t) {
        return this._level = t,
        this._notifyScopeListeners(),
        this
    }
    setTransactionName(t) {
        return this._transactionName = t,
        this._notifyScopeListeners(),
        this
    }
    setContext(t, n) {
        return n === null ? delete this._contexts[t] : this._contexts[t] = n,
        this._notifyScopeListeners(),
        this
    }
    setSpan(t) {
        return this._span = t,
        this._notifyScopeListeners(),
        this
    }
    getSpan() {
        return this._span
    }
    getTransaction() {
        let t = this._span;
        return t && t.transaction
    }
    setSession(t) {
        return t ? this._session = t : delete this._session,
        this._notifyScopeListeners(),
        this
    }
    getSession() {
        return this._session
    }
    update(t) {
        if (!t)
            return this;
        let n = typeof t == "function" ? t(this) : t;
        if (n instanceof e) {
            let i = n.getScopeData();
            this._tags = C(C({}, this._tags), i.tags),
            this._extra = C(C({}, this._extra), i.extra),
            this._contexts = C(C({}, this._contexts), i.contexts),
            i.user && Object.keys(i.user).length && (this._user = i.user),
            i.level && (this._level = i.level),
            i.fingerprint.length && (this._fingerprint = i.fingerprint),
            n.getRequestSession() && (this._requestSession = n.getRequestSession()),
            i.propagationContext && (this._propagationContext = i.propagationContext)
        } else if (Xs(n)) {
            let i = t;
            this._tags = C(C({}, this._tags), i.tags),
            this._extra = C(C({}, this._extra), i.extra),
            this._contexts = C(C({}, this._contexts), i.contexts),
            i.user && (this._user = i.user),
            i.level && (this._level = i.level),
            i.fingerprint && (this._fingerprint = i.fingerprint),
            i.requestSession && (this._requestSession = i.requestSession),
            i.propagationContext && (this._propagationContext = i.propagationContext)
        }
        return this
    }
    clear() {
        return this._breadcrumbs = [],
        this._tags = {},
        this._extra = {},
        this._user = {},
        this._contexts = {},
        this._level = void 0,
        this._transactionName = void 0,
        this._fingerprint = void 0,
        this._requestSession = void 0,
        this._span = void 0,
        this._session = void 0,
        this._notifyScopeListeners(),
        this._attachments = [],
        this._propagationContext = D_(),
        this
    }
    addBreadcrumb(t, n) {
        let i = typeof n == "number" ? n : Mk;
        if (i <= 0)
            return this;
        let r = C({
            timestamp: Po()
        }, t)
          , s = this._breadcrumbs;
        return s.push(r),
        this._breadcrumbs = s.length > i ? s.slice(-i) : s,
        this._notifyScopeListeners(),
        this
    }
    getLastBreadcrumb() {
        return this._breadcrumbs[this._breadcrumbs.length - 1]
    }
    clearBreadcrumbs() {
        return this._breadcrumbs = [],
        this._notifyScopeListeners(),
        this
    }
    addAttachment(t) {
        return this._attachments.push(t),
        this
    }
    getAttachments() {
        return this.getScopeData().attachments
    }
    clearAttachments() {
        return this._attachments = [],
        this
    }
    getScopeData() {
        let {_breadcrumbs: t, _attachments: n, _contexts: i, _tags: r, _extra: s, _user: o, _level: a, _fingerprint: c, _eventProcessors: l, _propagationContext: u, _sdkProcessingMetadata: h, _transactionName: d, _span: f} = this;
        return {
            breadcrumbs: t,
            attachments: n,
            contexts: i,
            tags: r,
            extra: s,
            user: o,
            level: a,
            fingerprint: c || [],
            eventProcessors: l,
            propagationContext: u,
            sdkProcessingMetadata: h,
            transactionName: d,
            span: f
        }
    }
    applyToEvent(t, n={}, i=[]) {
        df(t, this.getScopeData());
        let r = [...i, ...Kh(), ...this._eventProcessors];
        return Q0(r, t, n)
    }
    setSDKProcessingMetadata(t) {
        return this._sdkProcessingMetadata = C(C({}, this._sdkProcessingMetadata), t),
        this
    }
    setPropagationContext(t) {
        return this._propagationContext = t,
        this
    }
    getPropagationContext() {
        return this._propagationContext
    }
    captureException(t, n) {
        let i = n && n.event_id ? n.event_id : di();
        if (!this._client)
            return We.warn("No client configured on scope - will not capture exception!"),
            i;
        let r = new Error("Sentry syntheticException");
        return this._client.captureException(t, ve(C({
            originalException: t,
            syntheticException: r
        }, n), {
            event_id: i
        }), this),
        i
    }
    captureMessage(t, n, i) {
        let r = i && i.event_id ? i.event_id : di();
        if (!this._client)
            return We.warn("No client configured on scope - will not capture message!"),
            r;
        let s = new Error(t);
        return this._client.captureMessage(t, n, ve(C({
            originalException: t,
            syntheticException: s
        }, i), {
            event_id: r
        }), this),
        r
    }
    captureEvent(t, n) {
        let i = n && n.event_id ? n.event_id : di();
        return this._client ? (this._client.captureEvent(t, ve(C({}, n), {
            event_id: i
        }), this),
        i) : (We.warn("No client configured on scope - will not capture event!"),
        i)
    }
    _notifyScopeListeners() {
        this._notifyingListeners || (this._notifyingListeners = !0,
        this._scopeListeners.forEach(t => {
            t(this)
        }
        ),
        this._notifyingListeners = !1)
    }
}
;
function N_() {
    return t6 || (t6 = new ko),
    t6
}
function D_() {
    return {
        traceId: di(),
        spanId: di().substring(16)
    }
}
var J0 = "7.120.3";
var F_ = parseFloat(J0)
  , kk = 100
  , Qh = class {
    constructor(t, n, i, r=F_) {
        this._version = r;
        let s;
        n ? s = n : (s = new ko,
        s.setClient(t));
        let o;
        i ? o = i : (o = new ko,
        o.setClient(t)),
        this._stack = [{
            scope: s
        }],
        t && this.bindClient(t),
        this._isolationScope = o
    }
    isOlderThan(t) {
        return this._version < t
    }
    bindClient(t) {
        let n = this.getStackTop();
        n.client = t,
        n.scope.setClient(t),
        t && t.setupIntegrations && t.setupIntegrations()
    }
    pushScope() {
        let t = this.getScope().clone();
        return this.getStack().push({
            client: this.getClient(),
            scope: t
        }),
        t
    }
    popScope() {
        return this.getStack().length <= 1 ? !1 : !!this.getStack().pop()
    }
    withScope(t) {
        let n = this.pushScope(), i;
        try {
            i = t(n)
        } catch (r) {
            throw this.popScope(),
            r
        }
        return Co(i) ? i.then(r => (this.popScope(),
        r), r => {
            throw this.popScope(),
            r
        }
        ) : (this.popScope(),
        i)
    }
    getClient() {
        return this.getStackTop().client
    }
    getScope() {
        return this.getStackTop().scope
    }
    getIsolationScope() {
        return this._isolationScope
    }
    getStack() {
        return this._stack
    }
    getStackTop() {
        return this._stack[this._stack.length - 1]
    }
    captureException(t, n) {
        let i = this._lastEventId = n && n.event_id ? n.event_id : di()
          , r = new Error("Sentry syntheticException");
        return this.getScope().captureException(t, ve(C({
            originalException: t,
            syntheticException: r
        }, n), {
            event_id: i
        })),
        i
    }
    captureMessage(t, n, i) {
        let r = this._lastEventId = i && i.event_id ? i.event_id : di()
          , s = new Error(t);
        return this.getScope().captureMessage(t, n, ve(C({
            originalException: t,
            syntheticException: s
        }, i), {
            event_id: r
        })),
        r
    }
    captureEvent(t, n) {
        let i = n && n.event_id ? n.event_id : di();
        return t.type || (this._lastEventId = i),
        this.getScope().captureEvent(t, ve(C({}, n), {
            event_id: i
        })),
        i
    }
    lastEventId() {
        return this._lastEventId
    }
    addBreadcrumb(t, n) {
        let {scope: i, client: r} = this.getStackTop();
        if (!r)
            return;
        let {beforeBreadcrumb: s=null, maxBreadcrumbs: o=kk} = r.getOptions && r.getOptions() || {};
        if (o <= 0)
            return;
        let a = Po()
          , c = C({
            timestamp: a
        }, t)
          , l = s ? mc( () => s(c, n)) : c;
        l !== null && (r.emit && r.emit("beforeAddBreadcrumb", l, n),
        i.addBreadcrumb(l, o))
    }
    setUser(t) {
        this.getScope().setUser(t),
        this.getIsolationScope().setUser(t)
    }
    setTags(t) {
        this.getScope().setTags(t),
        this.getIsolationScope().setTags(t)
    }
    setExtras(t) {
        this.getScope().setExtras(t),
        this.getIsolationScope().setExtras(t)
    }
    setTag(t, n) {
        this.getScope().setTag(t, n),
        this.getIsolationScope().setTag(t, n)
    }
    setExtra(t, n) {
        this.getScope().setExtra(t, n),
        this.getIsolationScope().setExtra(t, n)
    }
    setContext(t, n) {
        this.getScope().setContext(t, n),
        this.getIsolationScope().setContext(t, n)
    }
    configureScope(t) {
        let {scope: n, client: i} = this.getStackTop();
        i && t(n)
    }
    run(t) {
        let n = n6(this);
        try {
            t(this)
        } finally {
            n6(n)
        }
    }
    getIntegration(t) {
        let n = this.getClient();
        if (!n)
            return null;
        try {
            return n.getIntegration(t)
        } catch {
            return Gt && We.warn(`Cannot retrieve integration ${t.id} from the current Hub`),
            null
        }
    }
    startTransaction(t, n) {
        let i = this._callExtensionMethod("startTransaction", t, n);
        return Gt && !i && (this.getClient() ? We.warn(`Tracing extension 'startTransaction' has not been added. Call 'addTracingExtensions' before calling 'init':
Sentry.addTracingExtensions();
Sentry.init({...});
`) : We.warn("Tracing extension 'startTransaction' is missing. You should 'init' the SDK before calling 'startTransaction'")),
        i
    }
    traceHeaders() {
        return this._callExtensionMethod("traceHeaders")
    }
    captureSession(t=!1) {
        if (t)
            return this.endSession();
        this._sendSessionUpdate()
    }
    endSession() {
        let n = this.getStackTop().scope
          , i = n.getSession();
        i && uf(i),
        this._sendSessionUpdate(),
        n.setSession()
    }
    startSession(t) {
        let {scope: n, client: i} = this.getStackTop()
          , {release: r, environment: s=vc} = i && i.getOptions() || {}
          , {userAgent: o} = ft.navigator || {}
          , a = lf(C(C({
            release: r,
            environment: s,
            user: n.getUser()
        }, o && {
            userAgent: o
        }), t))
          , c = n.getSession && n.getSession();
        return c && c.status === "ok" && Js(c, {
            status: "exited"
        }),
        this.endSession(),
        n.setSession(a),
        a
    }
    shouldSendDefaultPii() {
        let t = this.getClient()
          , n = t && t.getOptions();
        return !!(n && n.sendDefaultPii)
    }
    _sendSessionUpdate() {
        let {scope: t, client: n} = this.getStackTop()
          , i = t.getSession();
        i && n && n.captureSession && n.captureSession(i)
    }
    _callExtensionMethod(t, ...n) {
        let r = pf().__SENTRY__;
        if (r && r.extensions && typeof r.extensions[t] == "function")
            return r.extensions[t].apply(this, n);
        Gt && We.warn(`Extension method ${t} couldn't be found, doing nothing.`)
    }
}
;
function pf() {
    return ft.__SENTRY__ = ft.__SENTRY__ || {
        extensions: {},
        hub: void 0
    },
    ft
}
function n6(e) {
    let t = pf()
      , n = ff(t);
    return L_(t, e),
    n
}
function yr() {
    let e = pf();
    if (e.__SENTRY__ && e.__SENTRY__.acs) {
        let t = e.__SENTRY__.acs.getCurrentHub();
        if (t)
            return t
    }
    return Ak(e)
}
function Z0() {
    return yr().getIsolationScope()
}
function Ak(e=pf()) {
    return (!Ik(e) || ff(e).isOlderThan(F_)) && L_(e, new Qh),
    ff(e)
}
function Ik(e) {
    return !!(e && e.__SENTRY__ && e.__SENTRY__.hub)
}
function ff(e) {
    return Hh("hub", () => new Qh, e)
}
function L_(e, t) {
    if (!e)
        return !1;
    let n = e.__SENTRY__ = e.__SENTRY__ || {};
    return n.hub = t,
    !0
}
function U_(e, t, n, i, r, s) {
    let {normalizeDepth: o=3, normalizeMaxBreadth: a=1e3} = e
      , c = ve(C({}, t), {
        event_id: t.event_id || n.event_id || di(),
        timestamp: t.timestamp || Po()
    })
      , l = n.integrations || e.integrations.map(v => v.name);
    Rk(c, e),
    Fk(c, l),
    t.type === void 0 && Dk(c, e.stackParser);
    let u = Bk(i, n.captureContext);
    n.mechanism && pa(c, n.mechanism);
    let h = r && r.getEventProcessors ? r.getEventProcessors() : []
      , d = N_().getScopeData();
    if (s) {
        let v = s.getScopeData();
        e6(d, v)
    }
    if (u) {
        let v = u.getScopeData();
        e6(d, v)
    }
    let f = [...n.attachments || [], ...d.attachments];
    f.length && (n.attachments = f),
    df(c, d);
    let g = [...h, ...Kh(), ...d.eventProcessors];
    return Q0(g, c, n).then(v => (v && Nk(v),
    typeof o == "number" && o > 0 ? Lk(v, o, a) : v))
}
function Rk(e, t) {
    let {environment: n, release: i, dist: r, maxValueLength: s=250} = t;
    "environment"in e || (e.environment = "environment"in t ? n : vc),
    e.release === void 0 && i !== void 0 && (e.release = i),
    e.dist === void 0 && r !== void 0 && (e.dist = r),
    e.message && (e.message = To(e.message, s));
    let o = e.exception && e.exception.values && e.exception.values[0];
    o && o.value && (o.value = To(o.value, s));
    let a = e.request;
    a && a.url && (a.url = To(a.url, s))
}
var B_ = new WeakMap;
function Dk(e, t) {
    let n = ft._sentryDebugIds;
    if (!n)
        return;
    let i, r = B_.get(t);
    r ? i = r : (i = new Map,
    B_.set(t, i));
    let s = Object.keys(n).reduce( (o, a) => {
        let c, l = i.get(a);
        l ? c = l : (c = t(a),
        i.set(a, c));
        for (let u = c.length - 1; u >= 0; u--) {
            let h = c[u];
            if (h.filename) {
                o[h.filename] = n[a];
                break
            }
        }
        return o
    }
    , {});
    try {
        e.exception.values.forEach(o => {
            o.stacktrace.frames.forEach(a => {
                a.filename && (a.debug_id = s[a.filename])
            }
            )
        }
        )
    } catch {}
}
function Nk(e) {
    let t = {};
    try {
        e.exception.values.forEach(i => {
            i.stacktrace.frames.forEach(r => {
                r.debug_id && (r.abs_path ? t[r.abs_path] = r.debug_id : r.filename && (t[r.filename] = r.debug_id),
                delete r.debug_id)
            }
            )
        }
        )
    } catch {}
    if (Object.keys(t).length === 0)
        return;
    e.debug_meta = e.debug_meta || {},
    e.debug_meta.images = e.debug_meta.images || [];
    let n = e.debug_meta.images;
    Object.keys(t).forEach(i => {
        n.push({
            type: "sourcemap",
            code_file: i,
            debug_id: t[i]
        })
    }
    )
}
function Fk(e, t) {
    t.length > 0 && (e.sdk = e.sdk || {},
    e.sdk.integrations = [...e.sdk.integrations || [], ...t])
}
function Lk(e, t, n) {
    if (!e)
        return null;
    let i = C(C(C(C(C({}, e), e.breadcrumbs && {
        breadcrumbs: e.breadcrumbs.map(r => C(C({}, r), r.data && {
            data: Ys(r.data, t, n)
        }))
    }), e.user && {
        user: Ys(e.user, t, n)
    }), e.contexts && {
        contexts: Ys(e.contexts, t, n)
    }), e.extra && {
        extra: Ys(e.extra, t, n)
    });
    return e.contexts && e.contexts.trace && i.contexts && (i.contexts.trace = e.contexts.trace,
    e.contexts.trace.data && (i.contexts.trace.data = Ys(e.contexts.trace.data, t, n))),
    e.spans && (i.spans = e.spans.map(r => {
        let s = ma(r).data;
        return s && (r.data = Ys(s, t, n)),
        r
    }
    )),
    i
}
function Bk(e, t) {
    if (!t)
        return e;
    let n = e ? e.clone() : new ko;
    return n.update(t),
    n
}
function H_(e) {
    if (e)
        return Uk(e) ? {
            captureContext: e
        } : Gk(e) ? {
            captureContext: e
        } : e
}
function Uk(e) {
    return e instanceof ko || typeof e == "function"
}
var Hk = ["user", "level", "extra", "contexts", "tags", "fingerprint", "requestSession", "propagationContext"];
function Gk(e) {
    return Object.keys(e).some(t => Hk.includes(t))
}
function wl(e, t) {
    return yr().captureException(e, H_(t))
}
function Jh(e, t) {
    return yr().captureEvent(e, t)
}
function Ao(e, t) {
    yr().addBreadcrumb(e, t)
}
function gf(e, t) {
    yr().setContext(e, t)
}
function mf(...e) {
    let t = yr();
    if (e.length === 2) {
        let[n,i] = e;
        return n ? t.withScope( () => (t.getStackTop().scope = n,
        i(n))) : t.withScope(i)
    }
    return t.withScope(e[0])
}
function Mn() {
    return yr().getClient()
}
function Mo() {
    return yr().getScope()
}
function Zh(e) {
    let t = Mn()
      , n = Z0()
      , i = Mo()
      , {release: r, environment: s=vc} = t && t.getOptions() || {}
      , {userAgent: o} = ft.navigator || {}
      , a = lf(C(C({
        release: r,
        environment: s,
        user: i.getUser() || n.getUser()
    }, o && {
        userAgent: o
    }), e))
      , c = n.getSession();
    return c && c.status === "ok" && Js(c, {
        status: "exited"
    }),
    vf(),
    n.setSession(a),
    i.setSession(a),
    a
}
function vf() {
    let e = Z0()
      , t = Mo()
      , n = t.getSession() || e.getSession();
    n && uf(n),
    G_(),
    e.setSession(),
    t.setSession()
}
function G_() {
    let e = Z0()
      , t = Mo()
      , n = Mn()
      , i = t.getSession() || e.getSession();
    i && n && n.captureSession && n.captureSession(i)
}
function ed(e=!1) {
    if (e) {
        vf();
        return
    }
    G_()
}
function Vk(e, t) {
    return t && (e.sdk = e.sdk || {},
    e.sdk.name = e.sdk.name || t.name,
    e.sdk.version = e.sdk.version || t.version,
    e.sdk.integrations = [...e.sdk.integrations || [], ...t.integrations || []],
    e.sdk.packages = [...e.sdk.packages || [], ...t.packages || []]),
    e
}
function V_(e, t, n, i) {
    let r = cf(n)
      , s = C(C({
        sent_at: new Date().toISOString()
    }, r && {
        sdk: r
    }), !!i && t && {
        dsn: Ps(t)
    })
      , o = "aggregates"in e ? [{
        type: "sessions"
    }, e] : [{
        type: "session"
    }, e.toJSON()];
    return ks(s, [o])
}
function W_(e, t, n, i) {
    let r = cf(n)
      , s = e.type && e.type !== "replay_event" ? e.type : "event";
    Vk(e, n && n.sdk);
    let o = z4(e, r, i, t);
    return delete e.sdkProcessingMetadata,
    ks(o, [[{
        type: s
    }, e]])
}
var Wk = "7";
function $k(e) {
    let t = e.protocol ? `${e.protocol}:` : ""
      , n = e.port ? `:${e.port}` : "";
    return `${t}//${e.host}${n}${e.path ? `/${e.path}` : ""}/api/`
}
function jk(e) {
    return `${$k(e)}${e.projectId}/envelope/`
}
function qk(e, t) {
    return E4(C({
        sentry_key: e.publicKey,
        sentry_version: Wk
    }, t && {
        sentry_client: `${t.name}/${t.version}`
    }))
}
function $_(e, t={}) {
    let n = typeof t == "string" ? t : t.tunnel
      , i = typeof t == "string" || !t._metadata ? void 0 : t._metadata.sdk;
    return n || `${jk(e)}?${qk(e, i)}`
}
var j_ = [];
function zk(e) {
    let t = {};
    return e.forEach(n => {
        let {name: i} = n
          , r = t[i];
        r && !r.isDefaultInstance && n.isDefaultInstance || (t[i] = n)
    }
    ),
    Object.keys(t).map(n => t[n])
}
function i6(e) {
    let t = e.defaultIntegrations || []
      , n = e.integrations;
    t.forEach(o => {
        o.isDefaultInstance = !0
    }
    );
    let i;
    Array.isArray(n) ? i = [...t, ...n] : typeof n == "function" ? i = Wh(n(t)) : i = t;
    let r = zk(i)
      , s = Xk(r, o => o.name === "Debug");
    if (s !== -1) {
        let[o] = r.splice(s, 1);
        r.push(o)
    }
    return r
}
function q_(e, t) {
    let n = {};
    return t.forEach(i => {
        i && s6(e, i, n)
    }
    ),
    n
}
function r6(e, t) {
    for (let n of t)
        n && n.afterAllSetup && n.afterAllSetup(e)
}
function s6(e, t, n) {
    if (n[t.name]) {
        Gt && We.log(`Integration skipped because it was already installed: ${t.name}`);
        return
    }
    if (n[t.name] = t,
    j_.indexOf(t.name) === -1 && (t.setupOnce(J4, yr),
    j_.push(t.name)),
    t.setup && typeof t.setup == "function" && t.setup(e),
    e.on && typeof t.preprocessEvent == "function") {
        let i = t.preprocessEvent.bind(t);
        e.on("preprocessEvent", (r, s) => i(r, s, e))
    }
    if (e.addEventProcessor && typeof t.processEvent == "function") {
        let i = t.processEvent.bind(t)
          , r = Object.assign( (s, o) => i(s, o, e), {
            id: t.name
        });
        e.addEventProcessor(r)
    }
    Gt && We.log(`Integration installed: ${t.name}`)
}
function Xk(e, t) {
    for (let n = 0; n < e.length; n++)
        if (t(e[n]) === !0)
            return n;
    return -1
}
function fi(e, t) {
    return Object.assign(function(...i) {
        return t(...i)
    }, {
        id: e
    })
}
function z_(e) {
    let t = "";
    for (let n of e) {
        let i = Object.entries(n.tags)
          , r = i.length > 0 ? `|#${i.map( ([s,o]) => `${s}:${o}`).join(",")}` : "";
        t += `${n.name}@${n.unit}:${n.metric}|${n.metricType}${r}|T${n.timestamp}
`
    }
    return t
}
function X_(e, t, n, i) {
    let r = {
        sent_at: new Date().toISOString()
    };
    n && n.sdk && (r.sdk = {
        name: n.sdk.name,
        version: n.sdk.version
    }),
    i && t && (r.dsn = Ps(t));
    let s = Kk(e);
    return ks(r, [s])
}
function Kk(e) {
    let t = z_(e);
    return [{
        type: "statsd",
        length: t.length
    }, t]
}
var K_ = "Not capturing exception because it's already been captured."
  , td = class {
    constructor(t) {
        if (this._options = t,
        this._integrations = {},
        this._integrationsInitialized = !1,
        this._numProcessing = 0,
        this._outcomes = {},
        this._hooks = {},
        this._eventProcessors = [],
        t.dsn ? this._dsn = q5(t.dsn) : Gt && We.warn("No DSN provided, client will not send events."),
        this._dsn) {
            let n = $_(this._dsn, t);
            this._transport = t.transport(ve(C({
                tunnel: this._options.tunnel,
                recordDroppedEvent: this.recordDroppedEvent.bind(this)
            }, t.transportOptions), {
                url: n
            }))
        }
    }
    captureException(t, n, i) {
        if (Q5(t)) {
            Gt && We.log(K_);
            return
        }
        let r = n && n.event_id;
        return this._process(this.eventFromException(t, n).then(s => this._captureEvent(s, n, i)).then(s => {
            r = s
        }
        )),
        r
    }
    captureMessage(t, n, i, r) {
        let s = i && i.event_id
          , o = q0(t) ? t : String(t)
          , a = ml(t) ? this.eventFromMessage(o, n, i) : this.eventFromException(t, i);
        return this._process(a.then(c => this._captureEvent(c, i, r)).then(c => {
            s = c
        }
        )),
        s
    }
    captureEvent(t, n, i) {
        if (n && n.originalException && Q5(n.originalException)) {
            Gt && We.log(K_);
            return
        }
        let r = n && n.event_id
          , o = (t.sdkProcessingMetadata || {}).capturedSpanScope;
        return this._process(this._captureEvent(t, n, o || i).then(a => {
            r = a
        }
        )),
        r
    }
    captureSession(t) {
        typeof t.release != "string" ? Gt && We.warn("Discarded session because of missing or non-string release") : (this.sendSession(t),
        Js(t, {
            init: !1
        }))
    }
    getDsn() {
        return this._dsn
    }
    getOptions() {
        return this._options
    }
    getSdkMetadata() {
        return this._options._metadata
    }
    getTransport() {
        return this._transport
    }
    flush(t) {
        let n = this._transport;
        return n ? (this.metricsAggregator && this.metricsAggregator.flush(),
        this._isClientDoneProcessing(t).then(i => n.flush(t).then(r => i && r))) : Qs(!0)
    }
    close(t) {
        return this.flush(t).then(n => (this.getOptions().enabled = !1,
        this.metricsAggregator && this.metricsAggregator.close(),
        n))
    }
    getEventProcessors() {
        return this._eventProcessors
    }
    addEventProcessor(t) {
        this._eventProcessors.push(t)
    }
    setupIntegrations(t) {
        (t && !this._integrationsInitialized || this._isEnabled() && !this._integrationsInitialized) && this._setupIntegrations()
    }
    init() {
        this._isEnabled() && this._setupIntegrations()
    }
    getIntegrationById(t) {
        return this.getIntegrationByName(t)
    }
    getIntegrationByName(t) {
        return this._integrations[t]
    }
    getIntegration(t) {
        try {
            return this._integrations[t.id] || null
        } catch {
            return Gt && We.warn(`Cannot retrieve integration ${t.id} from the current Client`),
            null
        }
    }
    addIntegration(t) {
        let n = this._integrations[t.name];
        s6(this, t, this._integrations),
        n || r6(this, [t])
    }
    sendEvent(t, n={}) {
        this.emit("beforeSendEvent", t, n);
        let i = W_(t, this._dsn, this._options._metadata, this._options.tunnel);
        for (let s of n.attachments || [])
            i = $4(i, q4(s, this._options.transportOptions && this._options.transportOptions.textEncoder));
        let r = this._sendEnvelope(i);
        r && r.then(s => this.emit("afterSendEvent", t, s), null)
    }
    sendSession(t) {
        let n = V_(t, this._dsn, this._options._metadata, this._options.tunnel);
        this._sendEnvelope(n)
    }
    recordDroppedEvent(t, n, i) {
        if (this._options.sendClientReports) {
            let r = typeof i == "number" ? i : 1
              , s = `${t}:${n}`;
            Gt && We.log(`Recording outcome: "${s}"${r > 1 ? ` (${r} times)` : ""}`),
            this._outcomes[s] = (this._outcomes[s] || 0) + r
        }
    }
    captureAggregateMetrics(t) {
        Gt && We.log(`Flushing aggregated metrics, number of metrics: ${t.length}`);
        let n = X_(t, this._dsn, this._options._metadata, this._options.tunnel);
        this._sendEnvelope(n)
    }
    on(t, n) {
        this._hooks[t] || (this._hooks[t] = []),
        this._hooks[t].push(n)
    }
    emit(t, ...n) {
        this._hooks[t] && this._hooks[t].forEach(i => i(...n))
    }
    _setupIntegrations() {
        let {integrations: t} = this._options;
        this._integrations = q_(this, t),
        r6(this, t),
        this._integrationsInitialized = !0
    }
    _updateSessionFromEvent(t, n) {
        let i = !1
          , r = !1
          , s = n.exception && n.exception.values;
        if (s) {
            r = !0;
            for (let c of s) {
                let l = c.mechanism;
                if (l && l.handled === !1) {
                    i = !0;
                    break
                }
            }
        }
        let o = t.status === "ok";
        (o && t.errors === 0 || o && i) && (Js(t, ve(C({}, i && {
            status: "crashed"
        }), {
            errors: t.errors || Number(r || i)
        })),
        this.captureSession(t))
    }
    _isClientDoneProcessing(t) {
        return new ds(n => {
            let i = 0
              , r = 1
              , s = setInterval( () => {
                this._numProcessing == 0 ? (clearInterval(s),
                n(!0)) : (i += r,
                t && i >= t && (clearInterval(s),
                n(!1)))
            }
            , r)
        }
        )
    }
    _isEnabled() {
        return this.getOptions().enabled !== !1 && this._transport !== void 0
    }
    _prepareEvent(t, n, i, r=Z0()) {
        let s = this.getOptions()
          , o = Object.keys(this._integrations);
        return !n.integrations && o.length > 0 && (n.integrations = o),
        this.emit("preprocessEvent", t, n),
        U_(s, t, n, i, this, r).then(a => {
            if (a === null)
                return a;
            let c = C(C({}, r.getPropagationContext()), i ? i.getPropagationContext() : void 0);
            if (!(a.contexts && a.contexts.trace) && c) {
                let {traceId: u, spanId: h, parentSpanId: d, dsc: f} = c;
                a.contexts = C({
                    trace: {
                        trace_id: u,
                        span_id: h,
                        parent_span_id: d
                    }
                }, a.contexts);
                let g = f || Z4(u, this, i);
                a.sdkProcessingMetadata = C({
                    dynamicSamplingContext: g
                }, a.sdkProcessingMetadata)
            }
            return a
        }
        )
    }
    _captureEvent(t, n={}, i) {
        return this._processEvent(t, n, i).then(r => r.event_id, r => {
            if (Gt) {
                let s = r;
                s.logLevel === "log" ? We.log(s.message) : We.warn(s)
            }
        }
        )
    }
    _processEvent(t, n, i) {
        let r = this.getOptions()
          , {sampleRate: s} = r
          , o = Q_(t)
          , a = Y_(t)
          , c = t.type || "error"
          , l = `before send for type \`${c}\``;
        if (a && typeof s == "number" && Math.random() > s)
            return this.recordDroppedEvent("sample_rate", "error", t),
            Sl(new sr(`Discarding event because it's not included in the random sample (sampling rate = ${s})`,"log"));
        let u = c === "replay_event" ? "replay" : c
          , d = (t.sdkProcessingMetadata || {}).capturedSpanIsolationScope;
        return this._prepareEvent(t, n, i, d).then(f => {
            if (f === null)
                throw this.recordDroppedEvent("event_processor", u, t),
                new sr("An event processor returned `null`, will not send event.","log");
            if (n.data && n.data.__sentry__ === !0)
                return f;
            let p = Qk(r, f, n);
            return Yk(p, l)
        }
        ).then(f => {
            if (f === null) {
                if (this.recordDroppedEvent("before_send", u, t),
                o) {
                    let b = 1 + (t.spans || []).length;
                    this.recordDroppedEvent("before_send", "span", b)
                }
                throw new sr(`${l} returned \`null\`, will not send event.`,"log")
            }
            let g = i && i.getSession();
            if (!o && g && this._updateSessionFromEvent(g, f),
            o) {
                let v = f.sdkProcessingMetadata && f.sdkProcessingMetadata.spanCountBeforeProcessing || 0
                  , b = f.spans ? f.spans.length : 0
                  , S = v - b;
                S > 0 && this.recordDroppedEvent("before_send", "span", S)
            }
            let p = f.transaction_info;
            if (o && p && f.transaction !== t.transaction) {
                let v = "custom";
                f.transaction_info = ve(C({}, p), {
                    source: v
                })
            }
            return this.sendEvent(f, n),
            f
        }
        ).then(null, f => {
            throw f instanceof sr ? f : (this.captureException(f, {
                data: {
                    __sentry__: !0
                },
                originalException: f
            }),
            new sr(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${f}`))
        }
        )
    }
    _process(t) {
        this._numProcessing++,
        t.then(n => (this._numProcessing--,
        n), n => (this._numProcessing--,
        n))
    }
    _sendEnvelope(t) {
        if (this.emit("beforeEnvelope", t),
        this._isEnabled() && this._transport)
            return this._transport.send(t).then(null, n => {
                Gt && We.error("Error while sending event:", n)
            }
            );
        Gt && We.error("Transport disabled")
    }
    _clearOutcomes() {
        let t = this._outcomes;
        return this._outcomes = {},
        Object.keys(t).map(n => {
            let[i,r] = n.split(":");
            return {
                reason: i,
                category: r,
                quantity: t[n]
            }
        }
        )
    }
}
;
function Yk(e, t) {
    let n = `${t} must return \`null\` or a valid event.`;
    if (Co(e))
        return e.then(i => {
            if (!Xs(i) && i !== null)
                throw new sr(n);
            return i
        }
        , i => {
            throw new sr(`${t} rejected with ${i}`)
        }
        );
    if (!Xs(e) && e !== null)
        throw new sr(n);
    return e
}
function Qk(e, t, n) {
    let {beforeSend: i, beforeSendTransaction: r} = e;
    if (Y_(t) && i)
        return i(t, n);
    if (Q_(t) && r) {
        if (t.spans) {
            let s = t.spans.length;
            t.sdkProcessingMetadata = ve(C({}, t.sdkProcessingMetadata), {
                spanCountBeforeProcessing: s
            })
        }
        return r(t, n)
    }
    return t
}
function Y_(e) {
    return e.type === void 0
}
function Q_(e) {
    return e.type === "transaction"
}
function o6(e, t) {
    t.debug === !0 && (Gt ? We.enable() : mc( () => {
        console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.")
    }
    )),
    Mo().update(t.initialScope);
    let i = new e(t);
    a6(i),
    Jk(i)
}
function a6(e) {
    let n = yr().getStackTop();
    n.client = e,
    n.scope.setClient(e)
}
function Jk(e) {
    e.init ? e.init() : e.setupIntegrations && e.setupIntegrations()
}
var Zk = 30;
function eu(e, t, n=G4(e.bufferSize || Zk)) {
    let i = {}
      , r = o => n.drain(o);
    function s(o) {
        let a = [];
        if (of(o, (h, d) => {
            let f = af(d);
            if (K4(i, f)) {
                let g = J_(h, d);
                e.recordDroppedEvent("ratelimit_backoff", f, g)
            } else
                a.push(h)
        }
        ),
        a.length === 0)
            return Qs();
        let c = ks(o[0], a)
          , l = h => {
            of(c, (d, f) => {
                let g = J_(d, f);
                e.recordDroppedEvent(h, af(f), g)
            }
            )
        }
          , u = () => t({
            body: j4(c, e.textEncoder)
        }).then(h => (h.statusCode !== void 0 && (h.statusCode < 200 || h.statusCode >= 300) && Gt && We.warn(`Sentry responded with status code ${h.statusCode} to sent event.`),
        i = Y4(i, h),
        h), h => {
            throw l("network_error"),
            h
        }
        );
        return n.add(u).then(h => h, h => {
            if (h instanceof sr)
                return Gt && We.error("Skipped sending event because buffer is full."),
                l("queue_overflow"),
                Qs();
            throw h
        }
        )
    }
    return s.__sentry__baseTransport__ = !0,
    {
        send: s,
        flush: r
    }
}
function J_(e, t) {
    if (!(t !== "event" && t !== "transaction"))
        return Array.isArray(e) ? e[1] : void 0
}
function nd(e, t, n=[t], i="npm") {
    let r = e._metadata || {};
    r.sdk || (r.sdk = {
        name: `sentry.javascript.${t}`,
        packages: n.map(s => ({
            name: `${i}:@sentry/${s}`,
            version: J0
        })),
        version: J0
    }),
    e._metadata = r
}
var eA = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/, /^ResizeObserver loop completed with undelivered notifications.$/, /^Cannot redefine property: googletag$/]
  , tA = [/^.*\/healthcheck$/, /^.*\/healthy$/, /^.*\/live$/, /^.*\/ready$/, /^.*\/heartbeat$/, /^.*\/health$/, /^.*\/healthz$/]
  , Z_ = "InboundFilters"
  , nA = (e={}) => ({
    name: Z_,
    setupOnce() {},
    processEvent(t, n, i) {
        let r = i.getOptions()
          , s = iA(e, r);
        return rA(t, s) ? null : t
    }
})
  , id = nA
  , yf = fi(Z_, id);
function iA(e={}, t={}) {
    return {
        allowUrls: [...e.allowUrls || [], ...t.allowUrls || []],
        denyUrls: [...e.denyUrls || [], ...t.denyUrls || []],
        ignoreErrors: [...e.ignoreErrors || [], ...t.ignoreErrors || [], ...e.disableErrorDefaults ? [] : eA],
        ignoreTransactions: [...e.ignoreTransactions || [], ...t.ignoreTransactions || [], ...e.disableTransactionDefaults ? [] : tA],
        ignoreInternal: e.ignoreInternal !== void 0 ? e.ignoreInternal : !0
    }
}
function rA(e, t) {
    return t.ignoreInternal && uA(e) ? (Gt && We.warn(`Event dropped due to being internal Sentry Error.
Event: ${Ks(e)}`),
    !0) : sA(e, t.ignoreErrors) ? (Gt && We.warn(`Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${Ks(e)}`),
    !0) : oA(e, t.ignoreTransactions) ? (Gt && We.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${Ks(e)}`),
    !0) : aA(e, t.denyUrls) ? (Gt && We.warn(`Event dropped due to being matched by \`denyUrls\` option.
Event: ${Ks(e)}.
Url: ${_f(e)}`),
    !0) : cA(e, t.allowUrls) ? !1 : (Gt && We.warn(`Event dropped due to not being matched by \`allowUrls\` option.
Event: ${Ks(e)}.
Url: ${_f(e)}`),
    !0)
}
function sA(e, t) {
    return e.type || !t || !t.length ? !1 : lA(e).some(n => z0(n, t))
}
function oA(e, t) {
    if (e.type !== "transaction" || !t || !t.length)
        return !1;
    let n = e.transaction;
    return n ? z0(n, t) : !1
}
function aA(e, t) {
    if (!t || !t.length)
        return !1;
    let n = _f(e);
    return n ? z0(n, t) : !1
}
function cA(e, t) {
    if (!t || !t.length)
        return !0;
    let n = _f(e);
    return n ? z0(n, t) : !0
}
function lA(e) {
    let t = [];
    e.message && t.push(e.message);
    let n;
    try {
        n = e.exception.values[e.exception.values.length - 1]
    } catch {}
    return n && n.value && (t.push(n.value),
    n.type && t.push(`${n.type}: ${n.value}`)),
    Gt && t.length === 0 && We.error(`Could not extract message for event ${Ks(e)}`),
    t
}
function uA(e) {
    try {
        return e.exception.values[0].type === "SentryError"
    } catch {}
    return !1
}
function hA(e=[]) {
    for (let t = e.length - 1; t >= 0; t--) {
        let n = e[t];
        if (n && n.filename !== "<anonymous>" && n.filename !== "[native code]")
            return n.filename || null
    }
    return null
}
function _f(e) {
    try {
        let t;
        try {
            t = e.exception.values[0].stacktrace.frames
        } catch {}
        return t ? hA(t) : null
    } catch {
        return Gt && We.error(`Cannot extract url for event ${Ks(e)}`),
        null
    }
}
var ey, ny = "FunctionToString", ty = new WeakMap, dA = () => ({
    name: ny,
    setupOnce() {
        ey = Function.prototype.toString;
        try {
            Function.prototype.toString = function(...e) {
                let t = yl(this)
                  , n = ty.has(Mn()) && t !== void 0 ? t : this;
                return ey.apply(n, e)
            }
        } catch {}
    },
    setup(e) {
        ty.set(e, !0)
    }
}), rd = dA, bf = fi(ny, rd);
var fA = "cause"
  , pA = 5
  , iy = "LinkedErrors"
  , gA = (e={}) => {
    let t = e.limit || pA
      , n = e.key || fA;
    return {
        name: iy,
        setupOnce() {},
        preprocessEvent(i, r, s) {
            let o = s.getOptions();
            Uh(Q4, o.stackParser, o.maxValueLength, n, t, i, r)
        }
    }
}
  , mA = gA
  , ry = fi(iy, mA);
var c6 = {};
X8(c6, {
    FunctionToString: () => bf,
    InboundFilters: () => yf,
    LinkedErrors: () => ry
});
var sy = c6;
var br = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__;
var It = ft
  , l6 = 0;
function u6() {
    return l6 > 0
}
function RA() {
    l6++,
    setTimeout( () => {
        l6--
    }
    )
}
function _c(e, t={}, n) {
    if (typeof e != "function")
        return e;
    try {
        let r = e.__sentry_wrapped__;
        if (r)
            return typeof r == "function" ? r : e;
        if (yl(e))
            return e
    } catch {
        return e
    }
    let i = function() {
        let r = Array.prototype.slice.call(arguments);
        try {
            n && typeof n == "function" && n.apply(this, arguments);
            let s = r.map(o => _c(o, t));
            return e.apply(this, s)
        } catch (s) {
            throw RA(),
            mf(o => {
                o.addEventProcessor(a => (t.mechanism && (K0(a, void 0, void 0),
                pa(a, t.mechanism)),
                a.extra = ve(C({}, a.extra), {
                    arguments: r
                }),
                a)),
                wl(s)
            }
            ),
            s
        }
    };
    try {
        for (let r in e)
            Object.prototype.hasOwnProperty.call(e, r) && (i[r] = e[r])
    } catch {}
    z5(i, e),
    fa(e, "__sentry_wrapped__", i);
    try {
        Object.getOwnPropertyDescriptor(i, "name").configurable && Object.defineProperty(i, "name", {
            get() {
                return e.name
            }
        })
    } catch {}
    return i
}
var Sf = 1024
  , oy = "Breadcrumbs"
  , DA = (e={}) => {
    let t = C({
        console: !0,
        dom: !0,
        fetch: !0,
        history: !0,
        sentry: !0,
        xhr: !0
    }, e);
    return {
        name: oy,
        setupOnce() {},
        setup(n) {
            t.console && M4(LA(n)),
            t.dom && I4(FA(n, t.dom)),
            t.xhr && U4(BA(n)),
            t.fetch && F4(UA(n)),
            t.history && qh(HA(n)),
            t.sentry && n.on && n.on("beforeSendEvent", NA(n))
        }
    }
}
  , xf = DA
  , h6 = fi(oy, xf);
function NA(e) {
    return function(n) {
        Mn() === e && Ao({
            category: `sentry.${n.type === "transaction" ? "transaction" : "event"}`,
            event_id: n.event_id,
            level: n.level,
            message: Ks(n)
        }, {
            event: n
        })
    }
}
function FA(e, t) {
    return function(i) {
        if (Mn() !== e)
            return;
        let r, s, o = typeof t == "object" ? t.serializeAttribute : void 0, a = typeof t == "object" && typeof t.maxStringLength == "number" ? t.maxStringLength : void 0;
        a && a > Sf && (br && We.warn(`\`dom.maxStringLength\` cannot exceed ${Sf}, but a value of ${a} was configured. Sentry will use ${Sf} instead.`),
        a = Sf),
        typeof o == "string" && (o = [o]);
        try {
            let l = i.event
              , u = GA(l) ? l.target : l;
            r = Gh(u, {
                keyAttrs: o,
                maxStringLength: a
            }),
            s = w4(u)
        } catch {
            r = "<unknown>"
        }
        if (r.length === 0)
            return;
        let c = {
            category: `ui.${i.name}`,
            message: r
        };
        s && (c.data = {
            "ui.component_name": s
        }),
        Ao(c, {
            event: i.event,
            name: i.name,
            global: i.global
        })
    }
}
function LA(e) {
    return function(n) {
        if (Mn() !== e)
            return;
        let i = {
            category: "console",
            data: {
                arguments: n.args,
                logger: "console"
            },
            level: V4(n.level),
            message: $5(n.args, " ")
        };
        if (n.level === "assert")
            if (n.args[0] === !1)
                i.message = `Assertion failed: ${$5(n.args.slice(1), " ") || "console.assert"}`,
                i.data.arguments = n.args.slice(1);
            else
                return;
        Ao(i, {
            input: n.args,
            level: n.level
        })
    }
}
function BA(e) {
    return function(n) {
        if (Mn() !== e)
            return;
        let {startTimestamp: i, endTimestamp: r} = n
          , s = n.xhr[bl];
        if (!i || !r || !s)
            return;
        let {method: o, url: a, status_code: c, body: l} = s
          , u = {
            method: o,
            url: a,
            status_code: c
        }
          , h = {
            xhr: n.xhr,
            input: l,
            startTimestamp: i,
            endTimestamp: r
        };
        Ao({
            category: "xhr",
            data: u,
            type: "http"
        }, h)
    }
}
function UA(e) {
    return function(n) {
        if (Mn() !== e)
            return;
        let {startTimestamp: i, endTimestamp: r} = n;
        if (r && !(n.fetchData.url.match(/sentry_key/) && n.fetchData.method === "POST"))
            if (n.error) {
                let s = n.fetchData
                  , o = {
                    data: n.error,
                    input: n.args,
                    startTimestamp: i,
                    endTimestamp: r
                };
                Ao({
                    category: "fetch",
                    data: s,
                    level: "error",
                    type: "http"
                }, o)
            } else {
                let s = n.response
                  , o = ve(C({}, n.fetchData), {
                    status_code: s && s.status
                })
                  , a = {
                    input: n.args,
                    response: s,
                    startTimestamp: i,
                    endTimestamp: r
                };
                Ao({
                    category: "fetch",
                    data: o,
                    type: "http"
                }, a)
            }
    }
}
function HA(e) {
    return function(n) {
        if (Mn() !== e)
            return;
        let i = n.from
          , r = n.to
          , s = zh(It.location.href)
          , o = i ? zh(i) : void 0
          , a = zh(r);
        (!o || !o.path) && (o = s),
        s.protocol === a.protocol && s.host === a.host && (r = a.relative),
        s.protocol === o.protocol && s.host === o.host && (i = o.relative),
        Ao({
            category: "navigation",
            data: {
                from: i,
                to: r
            }
        })
    }
}
function GA(e) {
    return !!e && !!e.target
}
function p6(e, t) {
    let n = g6(e, t)
      , i = {
        type: t && t.name,
        value: jA(t)
    };
    return n.length && (i.stacktrace = {
        frames: n
    }),
    i.type === void 0 && i.value === "" && (i.value = "Unrecoverable error caught"),
    i
}
function VA(e, t, n, i) {
    let r = Mn()
      , s = r && r.getOptions().normalizeDepth
      , o = {
        exception: {
            values: [{
                type: vl(t) ? t.constructor.name : i ? "UnhandledRejection" : "Error",
                value: qA(t, {
                    isUnhandledRejection: i
                })
            }]
        },
        extra: {
            __serialized__: sf(t, s)
        }
    };
    if (n) {
        let a = g6(e, n);
        a.length && (o.exception.values[0].stacktrace = {
            frames: a
        })
    }
    return o
}
function d6(e, t) {
    return {
        exception: {
            values: [p6(e, t)]
        }
    }
}
function g6(e, t) {
    let n = t.stacktrace || t.stack || ""
      , i = $A(t);
    try {
        return e(n, i)
    } catch {}
    return []
}
var WA = /Minified React error #\d+;/i;
function $A(e) {
    if (e) {
        if (typeof e.framesToPop == "number")
            return e.framesToPop;
        if (WA.test(e.message))
            return 1
    }
    return 0
}
function jA(e) {
    let t = e && e.message;
    return t ? t.error && typeof t.error.message == "string" ? t.error.message : t : "No error message"
}
function ay(e, t, n, i) {
    let r = n && n.syntheticException || void 0
      , s = wf(e, t, r, i);
    return pa(s),
    s.level = "error",
    n && n.event_id && (s.event_id = n.event_id),
    Qs(s)
}
function cy(e, t, n="info", i, r) {
    let s = i && i.syntheticException || void 0
      , o = f6(e, t, s, r);
    return o.level = n,
    i && i.event_id && (o.event_id = i.event_id),
    Qs(o)
}
function wf(e, t, n, i, r) {
    let s;
    if (j0(t) && t.error)
        return d6(e, t.error);
    if (W5(t) || g4(t)) {
        let o = t;
        if ("stack"in t)
            s = d6(e, t);
        else {
            let a = o.name || (W5(o) ? "DOMError" : "DOMException")
              , c = o.message ? `${a}: ${o.message}` : a;
            s = f6(e, c, n, i),
            K0(s, c)
        }
        return "code"in o && (s.tags = ve(C({}, s.tags), {
            "DOMException.code": `${o.code}`
        })),
        s
    }
    return Lh(t) ? d6(e, t) : Xs(t) || vl(t) ? (s = VA(e, t, n, r),
    pa(s, {
        synthetic: !0
    }),
    s) : (s = f6(e, t, n, i),
    K0(s, `${t}`, void 0),
    pa(s, {
        synthetic: !0
    }),
    s)
}
function f6(e, t, n, i) {
    let r = {};
    if (i && n) {
        let s = g6(e, n);
        s.length && (r.exception = {
            values: [{
                value: t,
                stacktrace: {
                    frames: s
                }
            }]
        })
    }
    if (q0(t)) {
        let {__sentry_template_string__: s, __sentry_template_values__: o} = t;
        return r.logentry = {
            message: s,
            params: o
        },
        r
    }
    return r.message = t,
    r
}
function qA(e, {isUnhandledRejection: t}) {
    let n = T4(e)
      , i = t ? "promise rejection" : "exception";
    return j0(e) ? `Event \`ErrorEvent\` captured as ${i} with message \`${e.message}\`` : vl(e) ? `Event \`${zA(e)}\` (type=${e.type}) captured as ${i}` : `Object captured as ${i} with keys: ${n}`
}
function zA(e) {
    try {
        let t = Object.getPrototypeOf(e);
        return t ? t.constructor.name : void 0
    } catch {}
}
var uy = "GlobalHandlers"
  , XA = (e={}) => {
    let t = C({
        onerror: !0,
        onunhandledrejection: !0
    }, e);
    return {
        name: uy,
        setupOnce() {
            Error.stackTraceLimit = 50
        },
        setup(n) {
            t.onerror && (KA(n),
            ly("onerror")),
            t.onunhandledrejection && (YA(n),
            ly("onunhandledrejection"))
        }
    }
}
  , Cf = XA
  , m6 = fi(uy, Cf);
function KA(e) {
    L4(t => {
        let {stackParser: n, attachStacktrace: i} = dy();
        if (Mn() !== e || u6())
            return;
        let {msg: r, url: s, line: o, column: a, error: c} = t
          , l = c === void 0 && vr(r) ? ZA(r, s, o, a) : hy(wf(n, c || r, void 0, i, !1), s, o, a);
        l.level = "error",
        Jh(l, {
            originalException: c,
            mechanism: {
                handled: !1,
                type: "onerror"
            }
        })
    }
    )
}
function YA(e) {
    B4(t => {
        let {stackParser: n, attachStacktrace: i} = dy();
        if (Mn() !== e || u6())
            return;
        let r = QA(t)
          , s = ml(r) ? JA(r) : wf(n, r, void 0, i, !0);
        s.level = "error",
        Jh(s, {
            originalException: r,
            mechanism: {
                handled: !1,
                type: "onunhandledrejection"
            }
        })
    }
    )
}
function QA(e) {
    if (ml(e))
        return e;
    let t = e;
    try {
        if ("reason"in t)
            return t.reason;
        if ("detail"in t && "reason"in t.detail)
            return t.detail.reason
    } catch {}
    return e
}
function JA(e) {
    return {
        exception: {
            values: [{
                type: "UnhandledRejection",
                value: `Non-Error promise rejection captured with value: ${String(e)}`
            }]
        }
    }
}
function ZA(e, t, n, i) {
    let r = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i
      , s = j0(e) ? e.message : e
      , o = "Error"
      , a = s.match(r);
    return a && (o = a[1],
    s = a[2]),
    hy({
        exception: {
            values: [{
                type: o,
                value: s
            }]
        }
    }, t, n, i)
}
function hy(e, t, n, i) {
    let r = e.exception = e.exception || {}
      , s = r.values = r.values || []
      , o = s[0] = s[0] || {}
      , a = o.stacktrace = o.stacktrace || {}
      , c = a.frames = a.frames || []
      , l = isNaN(parseInt(i, 10)) ? void 0 : i
      , u = isNaN(parseInt(n, 10)) ? void 0 : n
      , h = vr(t) && t.length > 0 ? t : x4();
    return c.length === 0 && c.push({
        colno: l,
        filename: h,
        function: "?",
        in_app: !0,
        lineno: u
    }),
    e
}
function ly(e) {
    br && We.log(`Global Handler attached: ${e}`)
}
function dy() {
    let e = Mn();
    return e && e.getOptions() || {
        stackParser: () => [],
        attachStacktrace: !1
    }
}
function fy(e, {metadata: t, tunnel: n, dsn: i}) {
    let r = C(C({
        event_id: e.event_id,
        sent_at: new Date().toISOString()
    }, t && t.sdk && {
        sdk: {
            name: t.sdk.name,
            version: t.sdk.version
        }
    }), !!n && !!i && {
        dsn: Ps(i)
    })
      , s = eI(e);
    return ks(r, [s])
}
function eI(e) {
    return [{
        type: "user_report"
    }, e]
}
var Ef = class extends td {
    constructor(t) {
        let n = It.SENTRY_SDK_SOURCE || H4();
        nd(t, "browser", ["browser"], n),
        super(t),
        t.sendClientReports && It.document && It.document.addEventListener("visibilitychange", () => {
            It.document.visibilityState === "hidden" && this._flushOutcomes()
        }
        )
    }
    eventFromException(t, n) {
        return ay(this._options.stackParser, t, n, this._options.attachStacktrace)
    }
    eventFromMessage(t, n="info", i) {
        return cy(this._options.stackParser, t, n, i, this._options.attachStacktrace)
    }
    captureUserFeedback(t) {
        if (!this._isEnabled()) {
            br && We.warn("SDK not enabled, will not capture user feedback.");
            return
        }
        let n = fy(t, {
            metadata: this.getSdkMetadata(),
            dsn: this.getDsn(),
            tunnel: this.getOptions().tunnel
        });
        this._sendEnvelope(n)
    }
    _prepareEvent(t, n, i) {
        return t.platform = t.platform || "javascript",
        super._prepareEvent(t, n, i)
    }
    _flushOutcomes() {
        let t = this._clearOutcomes();
        if (t.length === 0) {
            br && We.log("No outcomes to send");
            return
        }
        if (!this._dsn) {
            br && We.log("No dsn provided, will not send outcomes");
            return
        }
        br && We.log("Sending outcomes:", t);
        let n = X4(t, this._options.tunnel && Ps(this._dsn));
        this._sendEnvelope(n)
    }
}
;
var sd;
function py() {
    if (sd)
        return sd;
    if ($h(It.fetch))
        return sd = It.fetch.bind(It);
    let e = It.document
      , t = It.fetch;
    if (e && typeof e.createElement == "function")
        try {
            let n = e.createElement("iframe");
            n.hidden = !0,
            e.head.appendChild(n);
            let i = n.contentWindow;
            i && i.fetch && (t = i.fetch),
            e.head.removeChild(n)
        } catch (n) {
            br && We.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", n)
        }
    return sd = t.bind(It)
}
function gy() {
    sd = void 0
}
function my(e, t=py()) {
    let n = 0
      , i = 0;
    function r(s) {
        let o = s.body.length;
        n += o,
        i++;
        let a = C({
            body: s.body,
            method: "POST",
            referrerPolicy: "origin",
            headers: e.headers,
            keepalive: n <= 6e4 && i < 15
        }, e.fetchOptions);
        try {
            return t(e.url, a).then(c => (n -= o,
            i--,
            {
                statusCode: c.status,
                headers: {
                    "x-sentry-rate-limits": c.headers.get("X-Sentry-Rate-Limits"),
                    "retry-after": c.headers.get("Retry-After")
                }
            }))
        } catch (c) {
            return gy(),
            n -= o,
            i--,
            Sl(c)
        }
    }
    return eu(e, r)
}
var tI = 4;
function vy(e) {
    function t(n) {
        return new ds( (i, r) => {
            let s = new XMLHttpRequest;
            s.onerror = r,
            s.onreadystatechange = () => {
                s.readyState === tI && i({
                    statusCode: s.status,
                    headers: {
                        "x-sentry-rate-limits": s.getResponseHeader("X-Sentry-Rate-Limits"),
                        "retry-after": s.getResponseHeader("Retry-After")
                    }
                })
            }
            ,
            s.open("POST", e.url);
            for (let o in e.headers)
                Object.prototype.hasOwnProperty.call(e.headers, o) && s.setRequestHeader(o, e.headers[o]);
            s.send(n.body)
        }
        )
    }
    return eu(e, t)
}
var Tf = "?";
var nI = 30
  , iI = 40
  , rI = 50;
function v6(e, t, n, i) {
    let r = {
        filename: e,
        function: t,
        in_app: !0
    };
    return n !== void 0 && (r.lineno = n),
    i !== void 0 && (r.colno = i),
    r
}
var sI = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i
  , oI = /\((\S*)(?::(\d+))(?::(\d+))\)/
  , aI = e => {
    let t = sI.exec(e);
    if (t) {
        if (t[2] && t[2].indexOf("eval") === 0) {
            let s = oI.exec(t[2]);
            s && (t[2] = s[1],
            t[3] = s[2],
            t[4] = s[3])
        }
        let[i,r] = yy(t[1] || Tf, t[2]);
        return v6(r, i, t[3] ? +t[3] : void 0, t[4] ? +t[4] : void 0)
    }
}
  , cI = [nI, aI]
  , lI = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i
  , uI = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i
  , hI = e => {
    let t = lI.exec(e);
    if (t) {
        if (t[3] && t[3].indexOf(" > eval") > -1) {
            let s = uI.exec(t[3]);
            s && (t[1] = t[1] || "eval",
            t[3] = s[1],
            t[4] = s[2],
            t[5] = "")
        }
        let i = t[3]
          , r = t[1] || Tf;
        return [r,i] = yy(r, i),
        v6(i, r, t[4] ? +t[4] : void 0, t[5] ? +t[5] : void 0)
    }
}
  , dI = [rI, hI]
  , fI = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:[-a-z]+):.*?):(\d+)(?::(\d+))?\)?\s*$/i
  , pI = e => {
    let t = fI.exec(e);
    return t ? v6(t[2], t[1] || Tf, +t[3], t[4] ? +t[4] : void 0) : void 0
}
  , gI = [iI, pI];
var mI = [cI, dI, gI]
  , _y = K5(...mI)
  , yy = (e, t) => {
    let n = e.indexOf("safari-extension") !== -1
      , i = e.indexOf("safari-web-extension") !== -1;
    return n || i ? [e.indexOf("@") !== -1 ? e.split("@")[0] : Tf, n ? `safari-extension:${t}` : `safari-web-extension:${t}`] : [e, t]
}
;
var xy = "Dedupe"
  , vI = () => {
    let e;
    return {
        name: xy,
        setupOnce() {},
        processEvent(t) {
            if (t.type)
                return t;
            try {
                if (_I(t, e))
                    return br && We.warn("Event dropped due to being a duplicate of previously captured event."),
                    null
            } catch {}
            return e = t
        }
    }
}
  , _6 = vI
  , wy = fi(xy, _6);
function _I(e, t) {
    return t ? !!(yI(e, t) || bI(e, t)) : !1
}
function yI(e, t) {
    let n = e.message
      , i = t.message;
    return !(!n && !i || n && !i || !n && i || n !== i || !Ey(e, t) || !Cy(e, t))
}
function bI(e, t) {
    let n = by(t)
      , i = by(e);
    return !(!n || !i || n.type !== i.type || n.value !== i.value || !Ey(e, t) || !Cy(e, t))
}
function Cy(e, t) {
    let n = Sy(e)
      , i = Sy(t);
    if (!n && !i)
        return !0;
    if (n && !i || !n && i || (n = n,
    i = i,
    i.length !== n.length))
        return !1;
    for (let r = 0; r < i.length; r++) {
        let s = i[r]
          , o = n[r];
        if (s.filename !== o.filename || s.lineno !== o.lineno || s.colno !== o.colno || s.function !== o.function)
            return !1
    }
    return !0
}
function Ey(e, t) {
    let n = e.fingerprint
      , i = t.fingerprint;
    if (!n && !i)
        return !0;
    if (n && !i || !n && i)
        return !1;
    n = n,
    i = i;
    try {
        return n.join("") === i.join("")
    } catch {
        return !1
    }
}
function by(e) {
    return e.exception && e.exception.values && e.exception.values[0]
}
function Sy(e) {
    let t = e.exception;
    if (t)
        try {
            return t.values[0].stacktrace.frames
        } catch {
            return
        }
}
var Ty = "HttpContext"
  , SI = () => ({
    name: Ty,
    setupOnce() {},
    preprocessEvent(e) {
        if (!It.navigator && !It.location && !It.document)
            return;
        let t = e.request && e.request.url || It.location && It.location.href
          , {referrer: n} = It.document || {}
          , {userAgent: i} = It.navigator || {}
          , r = C(C(C({}, e.request && e.request.headers), n && {
            Referer: n
        }), i && {
            "User-Agent": i
        })
          , s = ve(C(C({}, e.request), t && {
            url: t
        }), {
            headers: r
        });
        e.request = s
    }
})
  , y6 = SI
  , Oy = fi(Ty, y6);
var xI = "cause"
  , wI = 5
  , Py = "LinkedErrors"
  , CI = (e={}) => {
    let t = e.limit || wI
      , n = e.key || xI;
    return {
        name: Py,
        setupOnce() {},
        preprocessEvent(i, r, s) {
            let o = s.getOptions();
            Uh(p6, o.stackParser, o.maxValueLength, n, t, i, r)
        }
    }
}
  , b6 = CI
  , My = fi(Py, b6);
var EI = ["EventTarget", "Window", "Node", "ApplicationCache", "AudioTrackList", "BroadcastChannel", "ChannelMergerNode", "CryptoOperation", "EventSource", "FileReader", "HTMLUnknownElement", "IDBDatabase", "IDBRequest", "IDBTransaction", "KeyOperation", "MediaController", "MessagePort", "ModalWindow", "Notification", "SVGElementInstance", "Screen", "SharedWorker", "TextTrack", "TextTrackCue", "TextTrackList", "WebSocket", "WebSocketWorker", "Worker", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestUpload"]
  , Ay = "TryCatch"
  , TI = (e={}) => {
    let t = C({
        XMLHttpRequest: !0,
        eventTarget: !0,
        requestAnimationFrame: !0,
        setInterval: !0,
        setTimeout: !0
    }, e);
    return {
        name: Ay,
        setupOnce() {
            t.setTimeout && Sn(It, "setTimeout", ky),
            t.setInterval && Sn(It, "setInterval", ky),
            t.requestAnimationFrame && Sn(It, "requestAnimationFrame", OI),
            t.XMLHttpRequest && "XMLHttpRequest"in It && Sn(XMLHttpRequest.prototype, "send", PI);
            let n = t.eventTarget;
            n && (Array.isArray(n) ? n : EI).forEach(MI)
        }
    }
}
  , S6 = TI
  , Iy = fi(Ay, S6);
function ky(e) {
    return function(...t) {
        let n = t[0];
        return t[0] = _c(n, {
            mechanism: {
                data: {
                    function: Ms(e)
                },
                handled: !1,
                type: "instrument"
            }
        }),
        e.apply(this, t)
    }
}
function OI(e) {
    return function(t) {
        return e.apply(this, [_c(t, {
            mechanism: {
                data: {
                    function: "requestAnimationFrame",
                    handler: Ms(e)
                },
                handled: !1,
                type: "instrument"
            }
        })])
    }
}
function PI(e) {
    return function(...t) {
        let n = this;
        return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach(r => {
            r in n && typeof n[r] == "function" && Sn(n, r, function(s) {
                let o = {
                    mechanism: {
                        data: {
                            function: r,
                            handler: Ms(s)
                        },
                        handled: !1,
                        type: "instrument"
                    }
                }
                  , a = yl(s);
                return a && (o.mechanism.data.handler = Ms(a)),
                _c(s, o)
            })
        }
        ),
        e.apply(this, t)
    }
}
function MI(e) {
    let t = It
      , n = t[e] && t[e].prototype;
    !n || !n.hasOwnProperty || !n.hasOwnProperty("addEventListener") || (Sn(n, "addEventListener", function(i) {
        return function(r, s, o) {
            try {
                typeof s.handleEvent == "function" && (s.handleEvent = _c(s.handleEvent, {
                    mechanism: {
                        data: {
                            function: "handleEvent",
                            handler: Ms(s),
                            target: e
                        },
                        handled: !1,
                        type: "instrument"
                    }
                }))
            } catch {}
            return i.apply(this, [r, _c(s, {
                mechanism: {
                    data: {
                        function: "addEventListener",
                        handler: Ms(s),
                        target: e
                    },
                    handled: !1,
                    type: "instrument"
                }
            }), o])
        }
    }),
    Sn(n, "removeEventListener", function(i) {
        return function(r, s, o) {
            let a = s;
            try {
                let c = a && a.__sentry_wrapped__;
                c && i.call(this, r, c, o)
            } catch {}
            return i.call(this, r, a, o)
        }
    }))
}
var Ry = [id(), rd(), S6(), xf(), Cf(), b6(), _6(), y6()];
function Of(e) {
    return [...Ry]
}
function x6(e={}) {
    e.defaultIntegrations === void 0 && (e.defaultIntegrations = Of()),
    e.release === void 0 && (typeof __SENTRY_RELEASE__ == "string" && (e.release = __SENTRY_RELEASE__),
    It.SENTRY_RELEASE && It.SENTRY_RELEASE.id && (e.release = It.SENTRY_RELEASE.id)),
    e.autoSessionTracking === void 0 && (e.autoSessionTracking = !0),
    e.sendClientReports === void 0 && (e.sendClientReports = !0);
    let t = ve(C({}, e), {
        stackParser: P4(e.stackParser || _y),
        integrations: i6(e),
        transport: e.transport || (J5() ? my : vy)
    });
    o6(Ef, t),
    e.autoSessionTracking && kI()
}
function kI() {
    if (typeof It.document > "u") {
        br && We.warn("Session tracking in non-browser environment with @sentry/browser is not supported.");
        return
    }
    Zh({
        ignoreDuration: !0
    }),
    ed(),
    qh( ({from: e, to: t}) => {
        e !== void 0 && e !== t && (Zh({
            ignoreDuration: !0
        }),
        ed())
    }
    )
}
var w6 = {};
X8(w6, {
    Breadcrumbs: () => h6,
    Dedupe: () => wy,
    GlobalHandlers: () => m6,
    HttpContext: () => Oy,
    LinkedErrors: () => My,
    TryCatch: () => Iy
});
var Dy = {};
It.Sentry && It.Sentry.Integrations && (Dy = It.Sentry.Integrations);
var Dre = C(C(C({}, Dy), sy), w6);
var E6 = class extends Av {
    supportsDOMEvents = !0
}
  , T6 = class e extends E6 {
    static makeCurrent() {
        kv(new e)
    }
    onAndCancel(t, n, i, r) {
        return t.addEventListener(n, i, r),
        () => {
            t.removeEventListener(n, i, r)
        }
    }
    dispatchEvent(t, n) {
        t.dispatchEvent(n)
    }
    remove(t) {
        t.remove()
    }
    createElement(t, n) {
        return n = n || this.getDefaultDocument(),
        n.createElement(t)
    }
    createHtmlDocument() {
        return document.implementation.createHTMLDocument("fakeTitle")
    }
    getDefaultDocument() {
        return document
    }
    isElementNode(t) {
        return t.nodeType === Node.ELEMENT_NODE
    }
    isShadowRoot(t) {
        return t instanceof DocumentFragment
    }
    getGlobalEventTarget(t, n) {
        return n === "window" ? window : n === "document" ? t : n === "body" ? t.body : null
    }
    getBaseHref(t) {
        let n = FI();
        return n == null ? null : LI(n)
    }
    resetBaseElement() {
        od = null
    }
    getUserAgent() {
        return window.navigator.userAgent
    }
    getCookie(t) {
        return Nv(document.cookie, t)
    }
}
  , od = null;
function FI() {
    return od = od || document.querySelector("base"),
    od ? od.getAttribute("href") : null
}
function LI(e) {
    return new URL(e,document.baseURI).pathname
}
var O6 = class {
    addToWindow(t) {
        ic.getAngularTestability = (i, r=!0) => {
            let s = t.findTestabilityInTree(i, r);
            if (s == null)
                throw new hi(5103,!1);
            return s
        }
        ,
        ic.getAllAngularTestabilities = () => t.getAllTestabilities(),
        ic.getAllAngularRootElements = () => t.getAllRootElements();
        let n = i => {
            let r = ic.getAllAngularTestabilities()
              , s = r.length
              , o = function() {
                s--,
                s == 0 && i()
            };
            r.forEach(a => {
                a.whenStable(o)
            }
            )
        }
        ;
        ic.frameworkStabilizers || (ic.frameworkStabilizers = []),
        ic.frameworkStabilizers.push(n)
    }
    findTestabilityInTree(t, n, i) {
        if (n == null)
            return null;
        let r = t.getTestability(n);
        return r ?? (i ? A5().isShadowRoot(n) ? this.findTestabilityInTree(t, n.host, !0) : this.findTestabilityInTree(t, n.parentElement, !0) : null)
    }
}
  , BI = ( () => {
    class e {
        build() {
            return new XMLHttpRequest
        }
        static \u0275fac = function(i) {
            return new (i || e)
        }
        ;
        static \u0275prov = re({
            token: e,
            factory: e.\u0275fac
        })
    }
    return e
}
)()
  , Mf = new Ze("")
  , Gy = ( () => {
    class e {
        _zone;
        _plugins;
        _eventNameToPlugin = new Map;
        constructor(n, i) {
            this._zone = i,
            n.forEach(r => {
                r.manager = this
            }
            ),
            this._plugins = n.slice().reverse()
        }
        addEventListener(n, i, r, s) {
            return this._findPluginFor(i).addEventListener(n, i, r, s)
        }
        getZone() {
            return this._zone
        }
        _findPluginFor(n) {
            let i = this._eventNameToPlugin.get(n);
            if (i)
                return i;
            if (i = this._plugins.find(s => s.supports(n)),
            !i)
                throw new hi(5101,!1);
            return this._eventNameToPlugin.set(n, i),
            i
        }
        static \u0275fac = function(i) {
            return new (i || e)(xe(Mf),xe(Rn))
        }
        ;
        static \u0275prov = re({
            token: e,
            factory: e.\u0275fac
        })
    }
    return e
}
)()
  , ad = class {
    _doc;
    constructor(t) {
        this._doc = t
    }
    manager
}
  , Pf = "ng-app-id";
function Ny(e) {
    for (let t of e)
        t.remove()
}
function Fy(e, t) {
    let n = t.createElement("style");
    return n.textContent = e,
    n
}
function UI(e, t, n, i) {
    let r = e.head?.querySelectorAll(`style[${Pf}="${t}"],link[${Pf}="${t}"]`);
    if (r)
        for (let s of r)
            s.removeAttribute(Pf),
            s instanceof HTMLLinkElement ? i.set(s.href.slice(s.href.lastIndexOf("/") + 1), {
                usage: 0,
                elements: [s]
            }) : s.textContent && n.set(s.textContent, {
                usage: 0,
                elements: [s]
            })
}
function P6(e, t) {
    let n = t.createElement("link");
    return n.setAttribute("rel", "stylesheet"),
    n.setAttribute("href", e),
    n
}
var Vy = ( () => {
    class e {
        doc;
        appId;
        nonce;
        inline = new Map;
        external = new Map;
        hosts = new Set;
        isServer;
        constructor(n, i, r, s={}) {
            this.doc = n,
            this.appId = i,
            this.nonce = r,
            this.isServer = u4(s),
            UI(n, i, this.inline, this.external),
            this.hosts.add(n.head)
        }
        addStyles(n, i) {
            for (let r of n)
                this.addUsage(r, this.inline, Fy);
            i?.forEach(r => this.addUsage(r, this.external, P6))
        }
        removeStyles(n, i) {
            for (let r of n)
                this.removeUsage(r, this.inline);
            i?.forEach(r => this.removeUsage(r, this.external))
        }
        addUsage(n, i, r) {
            let s = i.get(n);
            s ? s.usage++ : i.set(n, {
                usage: 1,
                elements: [...this.hosts].map(o => this.addElement(o, r(n, this.doc)))
            })
        }
        removeUsage(n, i) {
            let r = i.get(n);
            r && (r.usage--,
            r.usage <= 0 && (Ny(r.elements),
            i.delete(n)))
        }
        ngOnDestroy() {
            for (let[,{elements: n}] of [...this.inline, ...this.external])
                Ny(n);
            this.hosts.clear()
        }
        addHost(n) {
            this.hosts.add(n);
            for (let[i,{elements: r}] of this.inline)
                r.push(this.addElement(n, Fy(i, this.doc)));
            for (let[i,{elements: r}] of this.external)
                r.push(this.addElement(n, P6(i, this.doc)))
        }
        removeHost(n) {
            this.hosts.delete(n)
        }
        addElement(n, i) {
            return this.nonce && i.setAttribute("nonce", this.nonce),
            this.isServer && i.setAttribute(Pf, this.appId),
            n.appendChild(i)
        }
        static \u0275fac = function(i) {
            return new (i || e)(xe(Nn),xe(t4),xe(n4, 8),xe(zs))
        }
        ;
        static \u0275prov = re({
            token: e,
            factory: e.\u0275fac
        })
    }
    return e
}
)()
  , C6 = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: "http://www.w3.org/1999/xhtml",
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/",
    math: "http://www.w3.org/1998/Math/MathML"
}
  , A6 = /%COMP%/g
  , Wy = "%COMP%"
  , HI = `_nghost-${Wy}`
  , GI = `_ngcontent-${Wy}`
  , VI = !0
  , WI = new Ze("",{
    providedIn: "root",
    factory: () => VI
});
function $I(e) {
    return GI.replace(A6, e)
}
function jI(e) {
    return HI.replace(A6, e)
}
function $y(e, t) {
    return t.map(n => n.replace(A6, e))
}
var Ly = ( () => {
    class e {
        eventManager;
        sharedStylesHost;
        appId;
        removeStylesOnCompDestroy;
        doc;
        platformId;
        ngZone;
        nonce;
        tracingService;
        rendererByCompId = new Map;
        defaultRenderer;
        platformIsServer;
        constructor(n, i, r, s, o, a, c, l=null, u=null) {
            this.eventManager = n,
            this.sharedStylesHost = i,
            this.appId = r,
            this.removeStylesOnCompDestroy = s,
            this.doc = o,
            this.platformId = a,
            this.ngZone = c,
            this.nonce = l,
            this.tracingService = u,
            this.platformIsServer = u4(a),
            this.defaultRenderer = new cd(n,o,c,this.platformIsServer,this.tracingService)
        }
        createRenderer(n, i) {
            if (!n || !i)
                return this.defaultRenderer;
            this.platformIsServer && i.encapsulation === Ph.ShadowDom && (i = ve(C({}, i), {
                encapsulation: Ph.Emulated
            }));
            let r = this.getOrCreateRenderer(n, i);
            return r instanceof kf ? r.applyToHost(n) : r instanceof ld && r.applyStyles(),
            r
        }
        getOrCreateRenderer(n, i) {
            let r = this.rendererByCompId
              , s = r.get(i.id);
            if (!s) {
                let o = this.doc
                  , a = this.ngZone
                  , c = this.eventManager
                  , l = this.sharedStylesHost
                  , u = this.removeStylesOnCompDestroy
                  , h = this.platformIsServer;
                switch (i.encapsulation) {
                case Ph.Emulated:
                    s = new kf(c,l,i,this.appId,u,o,a,h,this.tracingService);
                    break;
                case Ph.ShadowDom:
                    return new M6(c,l,n,i,o,a,this.nonce,h,this.tracingService);
                default:
                    s = new ld(c,l,i,u,o,a,h,this.tracingService);
                    break
                }
                r.set(i.id, s)
            }
            return s
        }
        ngOnDestroy() {
            this.rendererByCompId.clear()
        }
        componentReplaced(n) {
            this.rendererByCompId.delete(n)
        }
        static \u0275fac = function(i) {
            return new (i || e)(xe(Gy),xe(Vy),xe(t4),xe(WI),xe(Nn),xe(zs),xe(Rn),xe(n4),xe(pv, 8))
        }
        ;
        static \u0275prov = re({
            token: e,
            factory: e.\u0275fac
        })
    }
    return e
}
)()
  , cd = class {
    eventManager;
    doc;
    ngZone;
    platformIsServer;
    tracingService;
    data = Object.create(null);
    throwOnSyntheticProps = !0;
    constructor(t, n, i, r, s) {
        this.eventManager = t,
        this.doc = n,
        this.ngZone = i,
        this.platformIsServer = r,
        this.tracingService = s
    }
    destroy() {}
    destroyNode = null;
    createElement(t, n) {
        return n ? this.doc.createElementNS(C6[n] || n, t) : this.doc.createElement(t)
    }
    createComment(t) {
        return this.doc.createComment(t)
    }
    createText(t) {
        return this.doc.createTextNode(t)
    }
    appendChild(t, n) {
        (By(t) ? t.content : t).appendChild(n)
    }
    insertBefore(t, n, i) {
        t && (By(t) ? t.content : t).insertBefore(n, i)
    }
    removeChild(t, n) {
        n.remove()
    }
    selectRootElement(t, n) {
        let i = typeof t == "string" ? this.doc.querySelector(t) : t;
        if (!i)
            throw new hi(-5104,!1);
        return n || (i.textContent = ""),
        i
    }
    parentNode(t) {
        return t.parentNode
    }
    nextSibling(t) {
        return t.nextSibling
    }
    setAttribute(t, n, i, r) {
        if (r) {
            n = r + ":" + n;
            let s = C6[r];
            s ? t.setAttributeNS(s, n, i) : t.setAttribute(n, i)
        } else
            t.setAttribute(n, i)
    }
    removeAttribute(t, n, i) {
        if (i) {
            let r = C6[i];
            r ? t.removeAttributeNS(r, n) : t.removeAttribute(`${i}:${n}`)
        } else
            t.removeAttribute(n)
    }
    addClass(t, n) {
        t.classList.add(n)
    }
    removeClass(t, n) {
        t.classList.remove(n)
    }
    setStyle(t, n, i, r) {
        r & (Mh.DashCase | Mh.Important) ? t.style.setProperty(n, i, r & Mh.Important ? "important" : "") : t.style[n] = i
    }
    removeStyle(t, n, i) {
        i & Mh.DashCase ? t.style.removeProperty(n) : t.style[n] = ""
    }
    setProperty(t, n, i) {
        t != null && (t[n] = i)
    }
    setValue(t, n) {
        t.nodeValue = n
    }
    listen(t, n, i, r) {
        if (typeof t == "string" && (t = A5().getGlobalEventTarget(this.doc, t),
        !t))
            throw new Error(`Unsupported event target ${t} for event ${n}`);
        let s = this.decoratePreventDefault(i);
        return this.tracingService !== null && this.tracingService.wrapEventListener && (s = this.tracingService.wrapEventListener(t, n, s)),
        this.eventManager.addEventListener(t, n, s, r)
    }
    decoratePreventDefault(t) {
        return n => {
            if (n === "__ngUnwrap__")
                return t;
            (this.platformIsServer ? this.ngZone.runGuarded( () => t(n)) : t(n)) === !1 && n.preventDefault()
        }
    }
}
;
function By(e) {
    return e.tagName === "TEMPLATE" && e.content !== void 0
}
var M6 = class extends cd {
    sharedStylesHost;
    hostEl;
    shadowRoot;
    constructor(t, n, i, r, s, o, a, c, l) {
        super(t, s, o, c, l),
        this.sharedStylesHost = n,
        this.hostEl = i,
        this.shadowRoot = i.attachShadow({
            mode: "open"
        }),
        this.sharedStylesHost.addHost(this.shadowRoot);
        let u = $y(r.id, r.styles);
        for (let d of u) {
            let f = document.createElement("style");
            a && f.setAttribute("nonce", a),
            f.textContent = d,
            this.shadowRoot.appendChild(f)
        }
        let h = r.getExternalStyles?.();
        if (h)
            for (let d of h) {
                let f = P6(d, s);
                a && f.setAttribute("nonce", a),
                this.shadowRoot.appendChild(f)
            }
    }
    nodeOrShadowRoot(t) {
        return t === this.hostEl ? this.shadowRoot : t
    }
    appendChild(t, n) {
        return super.appendChild(this.nodeOrShadowRoot(t), n)
    }
    insertBefore(t, n, i) {
        return super.insertBefore(this.nodeOrShadowRoot(t), n, i)
    }
    removeChild(t, n) {
        return super.removeChild(null, n)
    }
    parentNode(t) {
        return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t)))
    }
    destroy() {
        this.sharedStylesHost.removeHost(this.shadowRoot)
    }
}
  , ld = class extends cd {
    sharedStylesHost;
    removeStylesOnCompDestroy;
    styles;
    styleUrls;
    constructor(t, n, i, r, s, o, a, c, l) {
        super(t, s, o, a, c),
        this.sharedStylesHost = n,
        this.removeStylesOnCompDestroy = r,
        this.styles = l ? $y(l, i.styles) : i.styles,
        this.styleUrls = i.getExternalStyles?.(l)
    }
    applyStyles() {
        this.sharedStylesHost.addStyles(this.styles, this.styleUrls)
    }
    destroy() {
        this.removeStylesOnCompDestroy && this.sharedStylesHost.removeStyles(this.styles, this.styleUrls)
    }
}
  , kf = class extends ld {
    contentAttr;
    hostAttr;
    constructor(t, n, i, r, s, o, a, c, l) {
        let u = r + "-" + i.id;
        super(t, n, i, s, o, a, c, l, u),
        this.contentAttr = $I(u),
        this.hostAttr = jI(u)
    }
    applyToHost(t) {
        this.applyStyles(),
        this.setAttribute(t, this.hostAttr, "")
    }
    createElement(t, n) {
        let i = super.createElement(t, n);
        return super.setAttribute(i, this.contentAttr, ""),
        i
    }
}
  , qI = ( () => {
    class e extends ad {
        constructor(n) {
            super(n)
        }
        supports(n) {
            return !0
        }
        addEventListener(n, i, r, s) {
            return n.addEventListener(i, r, s),
            () => this.removeEventListener(n, i, r, s)
        }
        removeEventListener(n, i, r, s) {
            return n.removeEventListener(i, r, s)
        }
        static \u0275fac = function(i) {
            return new (i || e)(xe(Nn))
        }
        ;
        static \u0275prov = re({
            token: e,
            factory: e.\u0275fac
        })
    }
    return e
}
)()
  , Uy = ["alt", "control", "meta", "shift"]
  , zI = {
    "\b": "Backspace",
    "	": "Tab",
    "\x7F": "Delete",
    "\x1B": "Escape",
    Del: "Delete",
    Esc: "Escape",
    Left: "ArrowLeft",
    Right: "ArrowRight",
    Up: "ArrowUp",
    Down: "ArrowDown",
    Menu: "ContextMenu",
    Scroll: "ScrollLock",
    Win: "OS"
}
  , XI = {
    alt: e => e.altKey,
    control: e => e.ctrlKey,
    meta: e => e.metaKey,
    shift: e => e.shiftKey
}
  , KI = ( () => {
    class e extends ad {
        constructor(n) {
            super(n)
        }
        supports(n) {
            return e.parseEventName(n) != null
        }
        addEventListener(n, i, r, s) {
            let o = e.parseEventName(i)
              , a = e.eventCallback(o.fullKey, r, this.manager.getZone());
            return this.manager.getZone().runOutsideAngular( () => A5().onAndCancel(n, o.domEventName, a, s))
        }
        static parseEventName(n) {
            let i = n.toLowerCase().split(".")
              , r = i.shift();
            if (i.length === 0 || !(r === "keydown" || r === "keyup"))
                return null;
            let s = e._normalizeKey(i.pop())
              , o = ""
              , a = i.indexOf("code");
            if (a > -1 && (i.splice(a, 1),
            o = "code."),
            Uy.forEach(l => {
                let u = i.indexOf(l);
                u > -1 && (i.splice(u, 1),
                o += l + ".")
            }
            ),
            o += s,
            i.length != 0 || s.length === 0)
                return null;
            let c = {};
            return c.domEventName = r,
            c.fullKey = o,
            c
        }
        static matchEventFullKeyCode(n, i) {
            let r = zI[n.key] || n.key
              , s = "";
            return i.indexOf("code.") > -1 && (r = n.code,
            s = "code."),
            r == null || !r ? !1 : (r = r.toLowerCase(),
            r === " " ? r = "space" : r === "." && (r = "dot"),
            Uy.forEach(o => {
                if (o !== r) {
                    let a = XI[o];
                    a(n) && (s += o + ".")
                }
            }
            ),
            s += r,
            s === i)
        }
        static eventCallback(n, i, r) {
            return s => {
                e.matchEventFullKeyCode(s, n) && r.runGuarded( () => i(s))
            }
        }
        static _normalizeKey(n) {
            return n === "esc" ? "escape" : n
        }
        static \u0275fac = function(i) {
            return new (i || e)(xe(Nn))
        }
        ;
        static \u0275prov = re({
            token: e,
            factory: e.\u0275fac
        })
    }
    return e
}
)();
function dse(e, t) {
    return Ov(C({
        rootComponent: e
    }, YI(t)))
}
function YI(e) {
    return {
        appProviders: [...jy, ...e?.providers ?? []],
        platformProviders: eR
    }
}
function QI() {
    T6.makeCurrent()
}
function JI() {
    return new e4
}
function ZI() {
    return dv(document),
    document
}
var eR = [{
    provide: zs,
    useValue: Hv
}, {
    provide: fv,
    useValue: QI,
    multi: !0
}, {
    provide: Nn,
    useFactory: ZI,
    deps: []
}];
var tR = [{
    provide: S5,
    useClass: O6,
    deps: []
}, {
    provide: Sv,
    useClass: x5,
    deps: [Rn, o4, S5]
}, {
    provide: x5,
    useClass: x5,
    deps: [Rn, o4, S5]
}]
  , jy = [{
    provide: uv,
    useValue: "root"
}, {
    provide: e4,
    useFactory: JI,
    deps: []
}, {
    provide: Mf,
    useClass: qI,
    multi: !0,
    deps: [Nn, Rn, zs]
}, {
    provide: Mf,
    useClass: KI,
    multi: !0,
    deps: [Nn]
}, Ly, Vy, Gy, {
    provide: vv,
    useExisting: Ly
}, {
    provide: Vv,
    useClass: BI,
    deps: []
}, []]
  , fse = ( () => {
    class e {
        constructor() {}
        static \u0275fac = function(i) {
            return new (i || e)
        }
        ;
        static \u0275mod = ir({
            type: e
        });
        static \u0275inj = nr({
            providers: [...jy, ...tR],
            imports: [fc, Tv]
        })
    }
    return e
}
)();
var qy = ( () => {
    class e {
        _doc;
        constructor(n) {
            this._doc = n
        }
        getTitle() {
            return this._doc.title
        }
        setTitle(n) {
            this._doc.title = n || ""
        }
        static \u0275fac = function(i) {
            return new (i || e)(xe(Nn))
        }
        ;
        static \u0275prov = re({
            token: e,
            factory: e.\u0275fac,
            providedIn: "root"
        })
    }
    return e
}
)();
var nR = {
    pan: !0,
    panstart: !0,
    panmove: !0,
    panend: !0,
    pancancel: !0,
    panleft: !0,
    panright: !0,
    panup: !0,
    pandown: !0,
    pinch: !0,
    pinchstart: !0,
    pinchmove: !0,
    pinchend: !0,
    pinchcancel: !0,
    pinchin: !0,
    pinchout: !0,
    press: !0,
    pressup: !0,
    rotate: !0,
    rotatestart: !0,
    rotatemove: !0,
    rotateend: !0,
    rotatecancel: !0,
    swipe: !0,
    swipeleft: !0,
    swiperight: !0,
    swipeup: !0,
    swipedown: !0,
    tap: !0,
    doubletap: !0
}
  , k6 = new Ze("")
  , zy = new Ze("")
  , I6 = ( () => {
    class e {
        events = [];
        overrides = {};
        options;
        buildHammer(n) {
            let i = new Hammer(n,this.options);
            i.get("pinch").set({
                enable: !0
            }),
            i.get("rotate").set({
                enable: !0
            });
            for (let r in this.overrides)
                i.get(r).set(this.overrides[r]);
            return i
        }
        static \u0275fac = function(i) {
            return new (i || e)
        }
        ;
        static \u0275prov = re({
            token: e,
            factory: e.\u0275fac
        })
    }
    return e
}
)()
  , iR = ( () => {
    class e extends ad {
        _config;
        _injector;
        loader;
        _loaderPromise = null;
        constructor(n, i, r, s) {
            super(n),
            this._config = i,
            this._injector = r,
            this.loader = s
        }
        supports(n) {
            return !(!nR.hasOwnProperty(n.toLowerCase()) && !this.isCustomEvent(n) || !window.Hammer && !this.loader)
        }
        addEventListener(n, i, r) {
            let s = this.manager.getZone();
            if (i = i.toLowerCase(),
            !window.Hammer && this.loader) {
                this._loaderPromise = this._loaderPromise || s.runOutsideAngular( () => this.loader());
                let o = !1
                  , a = () => {
                    o = !0
                }
                ;
                return s.runOutsideAngular( () => this._loaderPromise.then( () => {
                    if (!window.Hammer) {
                        a = () => {}
                        ;
                        return
                    }
                    o || (a = this.addEventListener(n, i, r))
                }
                ).catch( () => {
                    a = () => {}
                }
                )),
                () => {
                    a()
                }
            }
            return s.runOutsideAngular( () => {
                let o = this._config.buildHammer(n)
                  , a = function(c) {
                    s.runGuarded(function() {
                        r(c)
                    })
                };
                return o.on(i, a),
                () => {
                    o.off(i, a),
                    typeof o.destroy == "function" && o.destroy()
                }
            }
            )
        }
        isCustomEvent(n) {
            return this._config.events.indexOf(n) > -1
        }
        static \u0275fac = function(i) {
            return new (i || e)(xe(Nn),xe(k6),xe(an),xe(zy, 8))
        }
        ;
        static \u0275prov = re({
            token: e,
            factory: e.\u0275fac
        })
    }
    return e
}
)()
  , pse = ( () => {
    class e {
        static \u0275fac = function(i) {
            return new (i || e)
        }
        ;
        static \u0275mod = ir({
            type: e
        });
        static \u0275inj = nr({
            providers: [{
                provide: Mf,
                useClass: iR,
                multi: !0,
                deps: [Nn, k6, an, [new v5, zy]]
            }, {
                provide: k6,
                useClass: I6,
                deps: []
            }]
        })
    }
    return e
}
)();
var Ct = "primary"
  , wd = Symbol("RouteTitle")
  , L6 = class {
    params;
    constructor(t) {
        this.params = t || {}
    }
    has(t) {
        return Object.prototype.hasOwnProperty.call(this.params, t)
    }
    get(t) {
        if (this.has(t)) {
            let n = this.params[t];
            return Array.isArray(n) ? n[0] : n
        }
        return null
    }
    getAll(t) {
        if (this.has(t)) {
            let n = this.params[t];
            return Array.isArray(n) ? n : [n]
        }
        return []
    }
    get keys() {
        return Object.keys(this.params)
    }
}
;
function ou(e) {
    return new L6(e)
}
function oR(e, t, n) {
    let i = n.path.split("/");
    if (i.length > e.length || n.pathMatch === "full" && (t.hasChildren() || i.length < e.length))
        return null;
    let r = {};
    for (let s = 0; s < i.length; s++) {
        let o = i[s]
          , a = e[s];
        if (o[0] === ":")
            r[o.substring(1)] = a;
        else if (o !== a.path)
            return null
    }
    return {
        consumed: e.slice(0, i.length),
        posParams: r
    }
}
function aR(e, t) {
    if (e.length !== t.length)
        return !1;
    for (let n = 0; n < e.length; ++n)
        if (!Io(e[n], t[n]))
            return !1;
    return !0
}
function Io(e, t) {
    let n = e ? B6(e) : void 0
      , i = t ? B6(t) : void 0;
    if (!n || !i || n.length != i.length)
        return !1;
    let r;
    for (let s = 0; s < n.length; s++)
        if (r = n[s],
        !rb(e[r], t[r]))
            return !1;
    return !0
}
function B6(e) {
    return [...Object.keys(e), ...Object.getOwnPropertySymbols(e)]
}
function rb(e, t) {
    if (Array.isArray(e) && Array.isArray(t)) {
        if (e.length !== t.length)
            return !1;
        let n = [...e].sort()
          , i = [...t].sort();
        return n.every( (r, s) => i[s] === r)
    } else
        return e === t
}
function sb(e) {
    return e.length > 0 ? e[e.length - 1] : null
}
function bc(e) {
    return J8(e) ? e : xv(e) ? Qn(Promise.resolve(e)) : Be(e)
}
var cR = {
    exact: ab,
    subset: cb
}
  , ob = {
    exact: lR,
    subset: uR,
    ignored: () => !0
};
function Xy(e, t, n) {
    return cR[n.paths](e.root, t.root, n.matrixParams) && ob[n.queryParams](e.queryParams, t.queryParams) && !(n.fragment === "exact" && e.fragment !== t.fragment)
}
function lR(e, t) {
    return Io(e, t)
}
function ab(e, t, n) {
    if (!El(e.segments, t.segments) || !Rf(e.segments, t.segments, n) || e.numberOfChildren !== t.numberOfChildren)
        return !1;
    for (let i in t.children)
        if (!e.children[i] || !ab(e.children[i], t.children[i], n))
            return !1;
    return !0
}
function uR(e, t) {
    return Object.keys(t).length <= Object.keys(e).length && Object.keys(t).every(n => rb(e[n], t[n]))
}
function cb(e, t, n) {
    return lb(e, t, t.segments, n)
}
function lb(e, t, n, i) {
    if (e.segments.length > n.length) {
        let r = e.segments.slice(0, n.length);
        return !(!El(r, n) || t.hasChildren() || !Rf(r, n, i))
    } else if (e.segments.length === n.length) {
        if (!El(e.segments, n) || !Rf(e.segments, n, i))
            return !1;
        for (let r in t.children)
            if (!e.children[r] || !cb(e.children[r], t.children[r], i))
                return !1;
        return !0
    } else {
        let r = n.slice(0, e.segments.length)
          , s = n.slice(e.segments.length);
        return !El(e.segments, r) || !Rf(e.segments, r, i) || !e.children[Ct] ? !1 : lb(e.children[Ct], t, s, i)
    }
}
function Rf(e, t, n) {
    return t.every( (i, r) => ob[n](e[r].parameters, i.parameters))
}
var ya = class {
    root;
    queryParams;
    fragment;
    _queryParamMap;
    constructor(t=new Kt([],{}), n={}, i=null) {
        this.root = t,
        this.queryParams = n,
        this.fragment = i
    }
    get queryParamMap() {
        return this._queryParamMap ??= ou(this.queryParams),
        this._queryParamMap
    }
    toString() {
        return fR.serialize(this)
    }
}
  , Kt = class {
    segments;
    children;
    parent = null;
    constructor(t, n) {
        this.segments = t,
        this.children = n,
        Object.values(n).forEach(i => i.parent = this)
    }
    hasChildren() {
        return this.numberOfChildren > 0
    }
    get numberOfChildren() {
        return Object.keys(this.children).length
    }
    toString() {
        return Df(this)
    }
}
  , Cl = class {
    path;
    parameters;
    _parameterMap;
    constructor(t, n) {
        this.path = t,
        this.parameters = n
    }
    get parameterMap() {
        return this._parameterMap ??= ou(this.parameters),
        this._parameterMap
    }
    toString() {
        return hb(this)
    }
}
;
function hR(e, t) {
    return El(e, t) && e.every( (n, i) => Io(n.parameters, t[i].parameters))
}
function El(e, t) {
    return e.length !== t.length ? !1 : e.every( (n, i) => n.path === t[i].path)
}
function dR(e, t) {
    let n = [];
    return Object.entries(e.children).forEach( ([i,r]) => {
        i === Ct && (n = n.concat(t(r, i)))
    }
    ),
    Object.entries(e.children).forEach( ([i,r]) => {
        i !== Ct && (n = n.concat(t(r, i)))
    }
    ),
    n
}
var Cd = ( () => {
    class e {
        static \u0275fac = function(i) {
            return new (i || e)
        }
        ;
        static \u0275prov = re({
            token: e,
            factory: () => new au,
            providedIn: "root"
        })
    }
    return e
}
)()
  , au = class {
    parse(t) {
        let n = new H6(t);
        return new ya(n.parseRootSegment(),n.parseQueryParams(),n.parseFragment())
    }
    serialize(t) {
        let n = `/${ud(t.root, !0)}`
          , i = mR(t.queryParams)
          , r = typeof t.fragment == "string" ? `#${pR(t.fragment)}` : "";
        return `${n}${i}${r}`
    }
}
  , fR = new au;
function Df(e) {
    return e.segments.map(t => hb(t)).join("/")
}
function ud(e, t) {
    if (!e.hasChildren())
        return Df(e);
    if (t) {
        let n = e.children[Ct] ? ud(e.children[Ct], !1) : ""
          , i = [];
        return Object.entries(e.children).forEach( ([r,s]) => {
            r !== Ct && i.push(`${r}:${ud(s, !1)}`)
        }
        ),
        i.length > 0 ? `${n}(${i.join("//")})` : n
    } else {
        let n = dR(e, (i, r) => r === Ct ? [ud(e.children[Ct], !1)] : [`${r}:${ud(i, !1)}`]);
        return Object.keys(e.children).length === 1 && e.children[Ct] != null ? `${Df(e)}/${n[0]}` : `${Df(e)}/(${n.join("//")})`
    }
}
function ub(e) {
    return encodeURIComponent(e).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",")
}
function Af(e) {
    return ub(e).replace(/%3B/gi, ";")
}
function pR(e) {
    return encodeURI(e)
}
function U6(e) {
    return ub(e).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&")
}
function Nf(e) {
    return decodeURIComponent(e)
}
function Ky(e) {
    return Nf(e.replace(/\+/g, "%20"))
}
function hb(e) {
    return `${U6(e.path)}${gR(e.parameters)}`
}
function gR(e) {
    return Object.entries(e).map( ([t,n]) => `;${U6(t)}=${U6(n)}`).join("")
}
function mR(e) {
    let t = Object.entries(e).map( ([n,i]) => Array.isArray(i) ? i.map(r => `${Af(n)}=${Af(r)}`).join("&") : `${Af(n)}=${Af(i)}`).filter(n => n);
    return t.length ? `?${t.join("&")}` : ""
}
var vR = /^[^\/()?;#]+/;
function R6(e) {
    let t = e.match(vR);
    return t ? t[0] : ""
}
var _R = /^[^\/()?;=#]+/;
function yR(e) {
    let t = e.match(_R);
    return t ? t[0] : ""
}
var bR = /^[^=?&#]+/;
function SR(e) {
    let t = e.match(bR);
    return t ? t[0] : ""
}
var xR = /^[^&#]+/;
function wR(e) {
    let t = e.match(xR);
    return t ? t[0] : ""
}
var H6 = class {
    url;
    remaining;
    constructor(t) {
        this.url = t,
        this.remaining = t
    }
    parseRootSegment() {
        return this.consumeOptional("/"),
        this.remaining === "" || this.peekStartsWith("?") || this.peekStartsWith("#") ? new Kt([],{}) : new Kt([],this.parseChildren())
    }
    parseQueryParams() {
        let t = {};
        if (this.consumeOptional("?"))
            do
                this.parseQueryParam(t);
            while (this.consumeOptional("&"));
        return t
    }
    parseFragment() {
        return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null
    }
    parseChildren() {
        if (this.remaining === "")
            return {};
        this.consumeOptional("/");
        let t = [];
        for (this.peekStartsWith("(") || t.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/("); )
            this.capture("/"),
            t.push(this.parseSegment());
        let n = {};
        this.peekStartsWith("/(") && (this.capture("/"),
        n = this.parseParens(!0));
        let i = {};
        return this.peekStartsWith("(") && (i = this.parseParens(!1)),
        (t.length > 0 || Object.keys(n).length > 0) && (i[Ct] = new Kt(t,n)),
        i
    }
    parseSegment() {
        let t = R6(this.remaining);
        if (t === "" && this.peekStartsWith(";"))
            throw new hi(4009,!1);
        return this.capture(t),
        new Cl(Nf(t),this.parseMatrixParams())
    }
    parseMatrixParams() {
        let t = {};
        for (; this.consumeOptional(";"); )
            this.parseParam(t);
        return t
    }
    parseParam(t) {
        let n = yR(this.remaining);
        if (!n)
            return;
        this.capture(n);
        let i = "";
        if (this.consumeOptional("=")) {
            let r = R6(this.remaining);
            r && (i = r,
            this.capture(i))
        }
        t[Nf(n)] = Nf(i)
    }
    parseQueryParam(t) {
        let n = SR(this.remaining);
        if (!n)
            return;
        this.capture(n);
        let i = "";
        if (this.consumeOptional("=")) {
            let o = wR(this.remaining);
            o && (i = o,
            this.capture(i))
        }
        let r = Ky(n)
          , s = Ky(i);
        if (t.hasOwnProperty(r)) {
            let o = t[r];
            Array.isArray(o) || (o = [o],
            t[r] = o),
            o.push(s)
        } else
            t[r] = s
    }
    parseParens(t) {
        let n = {};
        for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0; ) {
            let i = R6(this.remaining)
              , r = this.remaining[i.length];
            if (r !== "/" && r !== ")" && r !== ";")
                throw new hi(4010,!1);
            let s;
            i.indexOf(":") > -1 ? (s = i.slice(0, i.indexOf(":")),
            this.capture(s),
            this.capture(":")) : t && (s = Ct);
            let o = this.parseChildren();
            n[s] = Object.keys(o).length === 1 ? o[Ct] : new Kt([],o),
            this.consumeOptional("//")
        }
        return n
    }
    peekStartsWith(t) {
        return this.remaining.startsWith(t)
    }
    consumeOptional(t) {
        return this.peekStartsWith(t) ? (this.remaining = this.remaining.substring(t.length),
        !0) : !1
    }
    capture(t) {
        if (!this.consumeOptional(t))
            throw new hi(4011,!1)
    }
}
;
function db(e) {
    return e.segments.length > 0 ? new Kt([],{
        [Ct]: e
    }) : e
}
function fb(e) {
    let t = {};
    for (let[i,r] of Object.entries(e.children)) {
        let s = fb(r);
        if (i === Ct && s.segments.length === 0 && s.hasChildren())
            for (let[o,a] of Object.entries(s.children))
                t[o] = a;
        else
            (s.segments.length > 0 || s.hasChildren()) && (t[i] = s)
    }
    let n = new Kt(e.segments,t);
    return CR(n)
}
function CR(e) {
    if (e.numberOfChildren === 1 && e.children[Ct]) {
        let t = e.children[Ct];
        return new Kt(e.segments.concat(t.segments),t.children)
    }
    return e
}
function Tl(e) {
    return e instanceof ya
}
function ER(e, t, n=null, i=null) {
    let r = pb(e);
    return gb(r, t, n, i)
}
function pb(e) {
    let t;
    function n(s) {
        let o = {};
        for (let c of s.children) {
            let l = n(c);
            o[c.outlet] = l
        }
        let a = new Kt(s.url,o);
        return s === e && (t = a),
        a
    }
    let i = n(e.root)
      , r = db(i);
    return t ?? r
}
function gb(e, t, n, i) {
    let r = e;
    for (; r.parent; )
        r = r.parent;
    if (t.length === 0)
        return D6(r, r, r, n, i);
    let s = TR(t);
    if (s.toRoot())
        return D6(r, r, new Kt([],{}), n, i);
    let o = OR(s, r, e)
      , a = o.processChildren ? dd(o.segmentGroup, o.index, s.commands) : vb(o.segmentGroup, o.index, s.commands);
    return D6(r, o.segmentGroup, a, n, i)
}
function Ff(e) {
    return typeof e == "object" && e != null && !e.outlets && !e.segmentPath
}
function gd(e) {
    return typeof e == "object" && e != null && e.outlets
}
function D6(e, t, n, i, r) {
    let s = {};
    i && Object.entries(i).forEach( ([c,l]) => {
        s[c] = Array.isArray(l) ? l.map(u => `${u}`) : `${l}`
    }
    );
    let o;
    e === t ? o = n : o = mb(e, t, n);
    let a = db(fb(o));
    return new ya(a,s,r)
}
function mb(e, t, n) {
    let i = {};
    return Object.entries(e.children).forEach( ([r,s]) => {
        s === t ? i[r] = n : i[r] = mb(s, t, n)
    }
    ),
    new Kt(e.segments,i)
}
var Lf = class {
    isAbsolute;
    numberOfDoubleDots;
    commands;
    constructor(t, n, i) {
        if (this.isAbsolute = t,
        this.numberOfDoubleDots = n,
        this.commands = i,
        t && i.length > 0 && Ff(i[0]))
            throw new hi(4003,!1);
        let r = i.find(gd);
        if (r && r !== sb(i))
            throw new hi(4004,!1)
    }
    toRoot() {
        return this.isAbsolute && this.commands.length === 1 && this.commands[0] == "/"
    }
}
;
function TR(e) {
    if (typeof e[0] == "string" && e.length === 1 && e[0] === "/")
        return new Lf(!0,0,e);
    let t = 0
      , n = !1
      , i = e.reduce( (r, s, o) => {
        if (typeof s == "object" && s != null) {
            if (s.outlets) {
                let a = {};
                return Object.entries(s.outlets).forEach( ([c,l]) => {
                    a[c] = typeof l == "string" ? l.split("/") : l
                }
                ),
                [...r, {
                    outlets: a
                }]
            }
            if (s.segmentPath)
                return [...r, s.segmentPath]
        }
        return typeof s != "string" ? [...r, s] : o === 0 ? (s.split("/").forEach( (a, c) => {
            c == 0 && a === "." || (c == 0 && a === "" ? n = !0 : a === ".." ? t++ : a != "" && r.push(a))
        }
        ),
        r) : [...r, s]
    }
    , []);
    return new Lf(n,t,i)
}
var iu = class {
    segmentGroup;
    processChildren;
    index;
    constructor(t, n, i) {
        this.segmentGroup = t,
        this.processChildren = n,
        this.index = i
    }
}
;
function OR(e, t, n) {
    if (e.isAbsolute)
        return new iu(t,!0,0);
    if (!n)
        return new iu(t,!1,NaN);
    if (n.parent === null)
        return new iu(n,!0,0);
    let i = Ff(e.commands[0]) ? 0 : 1
      , r = n.segments.length - 1 + i;
    return PR(n, r, e.numberOfDoubleDots)
}
function PR(e, t, n) {
    let i = e
      , r = t
      , s = n;
    for (; s > r; ) {
        if (s -= r,
        i = i.parent,
        !i)
            throw new hi(4005,!1);
        r = i.segments.length
    }
    return new iu(i,!1,r - s)
}
function MR(e) {
    return gd(e[0]) ? e[0].outlets : {
        [Ct]: e
    }
}
function vb(e, t, n) {
    if (e ??= new Kt([],{}),
    e.segments.length === 0 && e.hasChildren())
        return dd(e, t, n);
    let i = kR(e, t, n)
      , r = n.slice(i.commandIndex);
    if (i.match && i.pathIndex < e.segments.length) {
        let s = new Kt(e.segments.slice(0, i.pathIndex),{});
        return s.children[Ct] = new Kt(e.segments.slice(i.pathIndex),e.children),
        dd(s, 0, r)
    } else
        return i.match && r.length === 0 ? new Kt(e.segments,{}) : i.match && !e.hasChildren() ? G6(e, t, n) : i.match ? dd(e, 0, r) : G6(e, t, n)
}
function dd(e, t, n) {
    if (n.length === 0)
        return new Kt(e.segments,{});
    {
        let i = MR(n)
          , r = {};
        if (Object.keys(i).some(s => s !== Ct) && e.children[Ct] && e.numberOfChildren === 1 && e.children[Ct].segments.length === 0) {
            let s = dd(e.children[Ct], t, n);
            return new Kt(e.segments,s.children)
        }
        return Object.entries(i).forEach( ([s,o]) => {
            typeof o == "string" && (o = [o]),
            o !== null && (r[s] = vb(e.children[s], t, o))
        }
        ),
        Object.entries(e.children).forEach( ([s,o]) => {
            i[s] === void 0 && (r[s] = o)
        }
        ),
        new Kt(e.segments,r)
    }
}
function kR(e, t, n) {
    let i = 0
      , r = t
      , s = {
        match: !1,
        pathIndex: 0,
        commandIndex: 0
    };
    for (; r < e.segments.length; ) {
        if (i >= n.length)
            return s;
        let o = e.segments[r]
          , a = n[i];
        if (gd(a))
            break;
        let c = `${a}`
          , l = i < n.length - 1 ? n[i + 1] : null;
        if (r > 0 && c === void 0)
            break;
        if (c && l && typeof l == "object" && l.outlets === void 0) {
            if (!Qy(c, l, o))
                return s;
            i += 2
        } else {
            if (!Qy(c, {}, o))
                return s;
            i++
        }
        r++
    }
    return {
        match: !0,
        pathIndex: r,
        commandIndex: i
    }
}
function G6(e, t, n) {
    let i = e.segments.slice(0, t)
      , r = 0;
    for (; r < n.length; ) {
        let s = n[r];
        if (gd(s)) {
            let c = AR(s.outlets);
            return new Kt(i,c)
        }
        if (r === 0 && Ff(n[0])) {
            let c = e.segments[t];
            i.push(new Cl(c.path,Yy(n[0]))),
            r++;
            continue
        }
        let o = gd(s) ? s.outlets[Ct] : `${s}`
          , a = r < n.length - 1 ? n[r + 1] : null;
        o && a && Ff(a) ? (i.push(new Cl(o,Yy(a))),
        r += 2) : (i.push(new Cl(o,{})),
        r++)
    }
    return new Kt(i,{})
}
function AR(e) {
    let t = {};
    return Object.entries(e).forEach( ([n,i]) => {
        typeof i == "string" && (i = [i]),
        i !== null && (t[n] = G6(new Kt([],{}), 0, i))
    }
    ),
    t
}
function Yy(e) {
    let t = {};
    return Object.entries(e).forEach( ([n,i]) => t[n] = `${i}`),
    t
}
function Qy(e, t, n) {
    return e == n.path && Io(t, n.parameters)
}
var fd = "imperative"
  , Ei = function(e) {
    return e[e.NavigationStart = 0] = "NavigationStart",
    e[e.NavigationEnd = 1] = "NavigationEnd",
    e[e.NavigationCancel = 2] = "NavigationCancel",
    e[e.NavigationError = 3] = "NavigationError",
    e[e.RoutesRecognized = 4] = "RoutesRecognized",
    e[e.ResolveStart = 5] = "ResolveStart",
    e[e.ResolveEnd = 6] = "ResolveEnd",
    e[e.GuardsCheckStart = 7] = "GuardsCheckStart",
    e[e.GuardsCheckEnd = 8] = "GuardsCheckEnd",
    e[e.RouteConfigLoadStart = 9] = "RouteConfigLoadStart",
    e[e.RouteConfigLoadEnd = 10] = "RouteConfigLoadEnd",
    e[e.ChildActivationStart = 11] = "ChildActivationStart",
    e[e.ChildActivationEnd = 12] = "ChildActivationEnd",
    e[e.ActivationStart = 13] = "ActivationStart",
    e[e.ActivationEnd = 14] = "ActivationEnd",
    e[e.Scroll = 15] = "Scroll",
    e[e.NavigationSkipped = 16] = "NavigationSkipped",
    e
}(Ei || {})
  , As = class {
    id;
    url;
    constructor(t, n) {
        this.id = t,
        this.url = n
    }
}
  , yc = class extends As {
    type = Ei.NavigationStart;
    navigationTrigger;
    restoredState;
    constructor(t, n, i="imperative", r=null) {
        super(t, n),
        this.navigationTrigger = i,
        this.restoredState = r
    }
    toString() {
        return `NavigationStart(id: ${this.id}, url: '${this.url}')`
    }
}
  , Ro = class extends As {
    urlAfterRedirects;
    type = Ei.NavigationEnd;
    constructor(t, n, i) {
        super(t, n),
        this.urlAfterRedirects = i
    }
    toString() {
        return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`
    }
}
  , ps = function(e) {
    return e[e.Redirect = 0] = "Redirect",
    e[e.SupersededByNewNavigation = 1] = "SupersededByNewNavigation",
    e[e.NoDataFromResolver = 2] = "NoDataFromResolver",
    e[e.GuardRejected = 3] = "GuardRejected",
    e
}(ps || {})
  , Bf = function(e) {
    return e[e.IgnoredSameUrlNavigation = 0] = "IgnoredSameUrlNavigation",
    e[e.IgnoredByUrlHandlingStrategy = 1] = "IgnoredByUrlHandlingStrategy",
    e
}(Bf || {})
  , _a = class extends As {
    reason;
    code;
    type = Ei.NavigationCancel;
    constructor(t, n, i, r) {
        super(t, n),
        this.reason = i,
        this.code = r
    }
    toString() {
        return `NavigationCancel(id: ${this.id}, url: '${this.url}')`
    }
}
  , Do = class extends As {
    reason;
    code;
    type = Ei.NavigationSkipped;
    constructor(t, n, i, r) {
        super(t, n),
        this.reason = i,
        this.code = r
    }
}
  , md = class extends As {
    error;
    target;
    type = Ei.NavigationError;
    constructor(t, n, i, r) {
        super(t, n),
        this.error = i,
        this.target = r
    }
    toString() {
        return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`
    }
}
  , Uf = class extends As {
    urlAfterRedirects;
    state;
    type = Ei.RoutesRecognized;
    constructor(t, n, i, r) {
        super(t, n),
        this.urlAfterRedirects = i,
        this.state = r
    }
    toString() {
        return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
    }
}
  , V6 = class extends As {
    urlAfterRedirects;
    state;
    type = Ei.GuardsCheckStart;
    constructor(t, n, i, r) {
        super(t, n),
        this.urlAfterRedirects = i,
        this.state = r
    }
    toString() {
        return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
    }
}
  , W6 = class extends As {
    urlAfterRedirects;
    state;
    shouldActivate;
    type = Ei.GuardsCheckEnd;
    constructor(t, n, i, r, s) {
        super(t, n),
        this.urlAfterRedirects = i,
        this.state = r,
        this.shouldActivate = s
    }
    toString() {
        return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`
    }
}
  , $6 = class extends As {
    urlAfterRedirects;
    state;
    type = Ei.ResolveStart;
    constructor(t, n, i, r) {
        super(t, n),
        this.urlAfterRedirects = i,
        this.state = r
    }
    toString() {
        return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
    }
}
  , j6 = class extends As {
    urlAfterRedirects;
    state;
    type = Ei.ResolveEnd;
    constructor(t, n, i, r) {
        super(t, n),
        this.urlAfterRedirects = i,
        this.state = r
    }
    toString() {
        return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
    }
}
  , q6 = class {
    route;
    type = Ei.RouteConfigLoadStart;
    constructor(t) {
        this.route = t
    }
    toString() {
        return `RouteConfigLoadStart(path: ${this.route.path})`
    }
}
  , z6 = class {
    route;
    type = Ei.RouteConfigLoadEnd;
    constructor(t) {
        this.route = t
    }
    toString() {
        return `RouteConfigLoadEnd(path: ${this.route.path})`
    }
}
  , X6 = class {
    snapshot;
    type = Ei.ChildActivationStart;
    constructor(t) {
        this.snapshot = t
    }
    toString() {
        return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')`
    }
}
  , K6 = class {
    snapshot;
    type = Ei.ChildActivationEnd;
    constructor(t) {
        this.snapshot = t
    }
    toString() {
        return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')`
    }
}
  , Y6 = class {
    snapshot;
    type = Ei.ActivationStart;
    constructor(t) {
        this.snapshot = t
    }
    toString() {
        return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')`
    }
}
  , Q6 = class {
    snapshot;
    type = Ei.ActivationEnd;
    constructor(t) {
        this.snapshot = t
    }
    toString() {
        return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')`
    }
}
  , Hf = class {
    routerEvent;
    position;
    anchor;
    type = Ei.Scroll;
    constructor(t, n, i) {
        this.routerEvent = t,
        this.position = n,
        this.anchor = i
    }
    toString() {
        let t = this.position ? `${this.position[0]}, ${this.position[1]}` : null;
        return `Scroll(anchor: '${this.anchor}', position: '${t}')`
    }
}
  , vd = class {
}
  , cu = class {
    url;
    navigationBehaviorOptions;
    constructor(t, n) {
        this.url = t,
        this.navigationBehaviorOptions = n
    }
}
;
function IR(e, t) {
    return e.providers && !e._injector && (e._injector = r4(e.providers, t, `Route: ${e.path}`)),
    e._injector ?? t
}
function Zs(e) {
    return e.outlet || Ct
}
function RR(e, t) {
    let n = e.filter(i => Zs(i) === t);
    return n.push(...e.filter(i => Zs(i) !== t)),
    n
}
function Ed(e) {
    if (!e)
        return null;
    if (e.routeConfig?._injector)
        return e.routeConfig._injector;
    for (let t = e.parent; t; t = t.parent) {
        let n = t.routeConfig;
        if (n?._loadedInjector)
            return n._loadedInjector;
        if (n?._injector)
            return n._injector
    }
    return null
}
var J6 = class {
    rootInjector;
    outlet = null;
    route = null;
    children;
    attachRef = null;
    get injector() {
        return Ed(this.route?.snapshot) ?? this.rootInjector
    }
    constructor(t) {
        this.rootInjector = t,
        this.children = new Td(this.rootInjector)
    }
}
  , Td = ( () => {
    class e {
        rootInjector;
        contexts = new Map;
        constructor(n) {
            this.rootInjector = n
        }
        onChildOutletCreated(n, i) {
            let r = this.getOrCreateContext(n);
            r.outlet = i,
            this.contexts.set(n, r)
        }
        onChildOutletDestroyed(n) {
            let i = this.getContext(n);
            i && (i.outlet = null,
            i.attachRef = null)
        }
        onOutletDeactivated() {
            let n = this.contexts;
            return this.contexts = new Map,
            n
        }
        onOutletReAttached(n) {
            this.contexts = n
        }
        getOrCreateContext(n) {
            let i = this.getContext(n);
            return i || (i = new J6(this.rootInjector),
            this.contexts.set(n, i)),
            i
        }
        getContext(n) {
            return this.contexts.get(n) || null
        }
        static \u0275fac = function(i) {
            return new (i || e)(xe(rc))
        }
        ;
        static \u0275prov = re({
            token: e,
            factory: e.\u0275fac,
            providedIn: "root"
        })
    }
    return e
}
)()
  , Gf = class {
    _root;
    constructor(t) {
        this._root = t
    }
    get root() {
        return this._root.value
    }
    parent(t) {
        let n = this.pathFromRoot(t);
        return n.length > 1 ? n[n.length - 2] : null
    }
    children(t) {
        let n = Z6(t, this._root);
        return n ? n.children.map(i => i.value) : []
    }
    firstChild(t) {
        let n = Z6(t, this._root);
        return n && n.children.length > 0 ? n.children[0].value : null
    }
    siblings(t) {
        let n = eg(t, this._root);
        return n.length < 2 ? [] : n[n.length - 2].children.map(r => r.value).filter(r => r !== t)
    }
    pathFromRoot(t) {
        return eg(t, this._root).map(n => n.value)
    }
}
;
function Z6(e, t) {
    if (e === t.value)
        return t;
    for (let n of t.children) {
        let i = Z6(e, n);
        if (i)
            return i
    }
    return null
}
function eg(e, t) {
    if (e === t.value)
        return [t];
    for (let n of t.children) {
        let i = eg(e, n);
        if (i.length)
            return i.unshift(t),
            i
    }
    return []
}
var fs = class {
    value;
    children;
    constructor(t, n) {
        this.value = t,
        this.children = n
    }
    toString() {
        return `TreeNode(${this.value})`
    }
}
;
function nu(e) {
    let t = {};
    return e && e.children.forEach(n => t[n.value.outlet] = n),
    t
}
var Vf = class extends Gf {
    snapshot;
    constructor(t, n) {
        super(t),
        this.snapshot = n,
        lg(this, t)
    }
    toString() {
        return this.snapshot.toString()
    }
}
;
function _b(e) {
    let t = DR(e)
      , n = new Ne([new Cl("",{})])
      , i = new Ne({})
      , r = new Ne({})
      , s = new Ne({})
      , o = new Ne("")
      , a = new No(n,i,s,o,r,Ct,e,t.root);
    return a.snapshot = t.root,
    new Vf(new fs(a,[]),t)
}
function DR(e) {
    let t = {}
      , n = {}
      , i = {}
      , r = ""
      , s = new ru([],t,i,r,n,Ct,e,null,{});
    return new $f("",new fs(s,[]))
}
var No = class {
    urlSubject;
    paramsSubject;
    queryParamsSubject;
    fragmentSubject;
    dataSubject;
    outlet;
    component;
    snapshot;
    _futureSnapshot;
    _routerState;
    _paramMap;
    _queryParamMap;
    title;
    url;
    params;
    queryParams;
    fragment;
    data;
    constructor(t, n, i, r, s, o, a, c) {
        this.urlSubject = t,
        this.paramsSubject = n,
        this.queryParamsSubject = i,
        this.fragmentSubject = r,
        this.dataSubject = s,
        this.outlet = o,
        this.component = a,
        this._futureSnapshot = c,
        this.title = this.dataSubject?.pipe($e(l => l[wd])) ?? Be(void 0),
        this.url = t,
        this.params = n,
        this.queryParams = i,
        this.fragment = r,
        this.data = s
    }
    get routeConfig() {
        return this._futureSnapshot.routeConfig
    }
    get root() {
        return this._routerState.root
    }
    get parent() {
        return this._routerState.parent(this)
    }
    get firstChild() {
        return this._routerState.firstChild(this)
    }
    get children() {
        return this._routerState.children(this)
    }
    get pathFromRoot() {
        return this._routerState.pathFromRoot(this)
    }
    get paramMap() {
        return this._paramMap ??= this.params.pipe($e(t => ou(t))),
        this._paramMap
    }
    get queryParamMap() {
        return this._queryParamMap ??= this.queryParams.pipe($e(t => ou(t))),
        this._queryParamMap
    }
    toString() {
        return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})`
    }
}
;
function Wf(e, t, n="emptyOnly") {
    let i, {routeConfig: r} = e;
    return t !== null && (n === "always" || r?.path === "" || !t.component && !t.routeConfig?.loadComponent) ? i = {
        params: C(C({}, t.params), e.params),
        data: C(C({}, t.data), e.data),
        resolve: C(C(C(C({}, e.data), t.data), r?.data), e._resolvedData)
    } : i = {
        params: C({}, e.params),
        data: C({}, e.data),
        resolve: C(C({}, e.data), e._resolvedData ?? {})
    },
    r && bb(r) && (i.resolve[wd] = r.title),
    i
}
var ru = class {
    url;
    params;
    queryParams;
    fragment;
    data;
    outlet;
    component;
    routeConfig;
    _resolve;
    _resolvedData;
    _routerState;
    _paramMap;
    _queryParamMap;
    get title() {
        return this.data?.[wd]
    }
    constructor(t, n, i, r, s, o, a, c, l) {
        this.url = t,
        this.params = n,
        this.queryParams = i,
        this.fragment = r,
        this.data = s,
        this.outlet = o,
        this.component = a,
        this.routeConfig = c,
        this._resolve = l
    }
    get root() {
        return this._routerState.root
    }
    get parent() {
        return this._routerState.parent(this)
    }
    get firstChild() {
        return this._routerState.firstChild(this)
    }
    get children() {
        return this._routerState.children(this)
    }
    get pathFromRoot() {
        return this._routerState.pathFromRoot(this)
    }
    get paramMap() {
        return this._paramMap ??= ou(this.params),
        this._paramMap
    }
    get queryParamMap() {
        return this._queryParamMap ??= ou(this.queryParams),
        this._queryParamMap
    }
    toString() {
        let t = this.url.map(i => i.toString()).join("/")
          , n = this.routeConfig ? this.routeConfig.path : "";
        return `Route(url:'${t}', path:'${n}')`
    }
}
  , $f = class extends Gf {
    url;
    constructor(t, n) {
        super(n),
        this.url = t,
        lg(this, n)
    }
    toString() {
        return yb(this._root)
    }
}
;
function lg(e, t) {
    t.value._routerState = e,
    t.children.forEach(n => lg(e, n))
}
function yb(e) {
    let t = e.children.length > 0 ? ` { ${e.children.map(yb).join(", ")} } ` : "";
    return `${e.value}${t}`
}
function N6(e) {
    if (e.snapshot) {
        let t = e.snapshot
          , n = e._futureSnapshot;
        e.snapshot = n,
        Io(t.queryParams, n.queryParams) || e.queryParamsSubject.next(n.queryParams),
        t.fragment !== n.fragment && e.fragmentSubject.next(n.fragment),
        Io(t.params, n.params) || e.paramsSubject.next(n.params),
        aR(t.url, n.url) || e.urlSubject.next(n.url),
        Io(t.data, n.data) || e.dataSubject.next(n.data)
    } else
        e.snapshot = e._futureSnapshot,
        e.dataSubject.next(e._futureSnapshot.data)
}
function tg(e, t) {
    let n = Io(e.params, t.params) && hR(e.url, t.url)
      , i = !e.parent != !t.parent;
    return n && !i && (!e.parent || tg(e.parent, t.parent))
}
function bb(e) {
    return typeof e.title == "string" || e.title === null
}
var NR = new Ze("")
  , FR = ( () => {
    class e {
        activated = null;
        get activatedComponentRef() {
            return this.activated
        }
        _activatedRoute = null;
        name = Ct;
        activateEvents = new os;
        deactivateEvents = new os;
        attachEvents = new os;
        detachEvents = new os;
        routerOutletData = Ee(void 0);
        parentContexts = z(Td);
        location = z(b5);
        changeDetector = z(dc);
        inputBinder = z(Xf, {
            optional: !0
        });
        supportsBindingToComponentInputs = !0;
        ngOnChanges(n) {
            if (n.name) {
                let {firstChange: i, previousValue: r} = n.name;
                if (i)
                    return;
                this.isTrackedInParentContexts(r) && (this.deactivate(),
                this.parentContexts.onChildOutletDestroyed(r)),
                this.initializeOutletWithName()
            }
        }
        ngOnDestroy() {
            this.isTrackedInParentContexts(this.name) && this.parentContexts.onChildOutletDestroyed(this.name),
            this.inputBinder?.unsubscribeFromRouteData(this)
        }
        isTrackedInParentContexts(n) {
            return this.parentContexts.getContext(n)?.outlet === this
        }
        ngOnInit() {
            this.initializeOutletWithName()
        }
        initializeOutletWithName() {
            if (this.parentContexts.onChildOutletCreated(this.name, this),
            this.activated)
                return;
            let n = this.parentContexts.getContext(this.name);
            n?.route && (n.attachRef ? this.attach(n.attachRef, n.route) : this.activateWith(n.route, n.injector))
        }
        get isActivated() {
            return !!this.activated
        }
        get component() {
            if (!this.activated)
                throw new hi(4012,!1);
            return this.activated.instance
        }
        get activatedRoute() {
            if (!this.activated)
                throw new hi(4012,!1);
            return this._activatedRoute
        }
        get activatedRouteData() {
            return this._activatedRoute ? this._activatedRoute.snapshot.data : {}
        }
        detach() {
            if (!this.activated)
                throw new hi(4012,!1);
            this.location.detach();
            let n = this.activated;
            return this.activated = null,
            this._activatedRoute = null,
            this.detachEvents.emit(n.instance),
            n
        }
        attach(n, i) {
            this.activated = n,
            this._activatedRoute = i,
            this.location.insert(n.hostView),
            this.inputBinder?.bindActivatedRouteToOutletComponent(this),
            this.attachEvents.emit(n.instance)
        }
        deactivate() {
            if (this.activated) {
                let n = this.component;
                this.activated.destroy(),
                this.activated = null,
                this._activatedRoute = null,
                this.deactivateEvents.emit(n)
            }
        }
        activateWith(n, i) {
            if (this.isActivated)
                throw new hi(4013,!1);
            this._activatedRoute = n;
            let r = this.location
              , o = n.snapshot.component
              , a = this.parentContexts.getOrCreateContext(this.name).children
              , c = new ng(n,a,r.injector,this.routerOutletData);
            this.activated = r.createComponent(o, {
                index: r.length,
                injector: c,
                environmentInjector: i
            }),
            this.changeDetector.markForCheck(),
            this.inputBinder?.bindActivatedRouteToOutletComponent(this),
            this.activateEvents.emit(this.activated.instance)
        }
        static \u0275fac = function(i) {
            return new (i || e)
        }
        ;
        static \u0275dir = as({
            type: e,
            selectors: [["router-outlet"]],
            inputs: {
                name: "name",
                routerOutletData: [1, "routerOutletData"]
            },
            outputs: {
                activateEvents: "activate",
                deactivateEvents: "deactivate",
                attachEvents: "attach",
                detachEvents: "detach"
            },
            exportAs: ["outlet"],
            features: [qs]
        })
    }
    return e
}
)()
  , ng = class e {
    route;
    childContexts;
    parent;
    outletData;
    __ngOutletInjector(t) {
        return new e(this.route,this.childContexts,t,this.outletData)
    }
    constructor(t, n, i, r) {
        this.route = t,
        this.childContexts = n,
        this.parent = i,
        this.outletData = r
    }
    get(t, n) {
        return t === No ? this.route : t === Td ? this.childContexts : t === NR ? this.outletData : this.parent.get(t, n)
    }
}
  , Xf = new Ze("")
  , Jy = ( () => {
    class e {
        outletDataSubscriptions = new Map;
        bindActivatedRouteToOutletComponent(n) {
            this.unsubscribeFromRouteData(n),
            this.subscribeToRouteData(n)
        }
        unsubscribeFromRouteData(n) {
            this.outletDataSubscriptions.get(n)?.unsubscribe(),
            this.outletDataSubscriptions.delete(n)
        }
        subscribeToRouteData(n) {
            let {activatedRoute: i} = n
              , r = ll([i.queryParams, i.params, i.data]).pipe(Vt( ([s,o,a], c) => (a = C(C(C({}, s), o), a),
            c === 0 ? Be(a) : Promise.resolve(a)))).subscribe(s => {
                if (!n.isActivated || !n.activatedComponentRef || n.activatedRoute !== i || i.component === null) {
                    this.unsubscribeFromRouteData(n);
                    return
                }
                let o = Mv(i.component);
                if (!o) {
                    this.unsubscribeFromRouteData(n);
                    return
                }
                for (let {templateName: a} of o.inputs)
                    n.activatedComponentRef.setInput(a, s[a])
            }
            );
            this.outletDataSubscriptions.set(n, r)
        }
        static \u0275fac = function(i) {
            return new (i || e)
        }
        ;
        static \u0275prov = re({
            token: e,
            factory: e.\u0275fac
        })
    }
    return e
}
)();
function LR(e, t, n) {
    let i = _d(e, t._root, n ? n._root : void 0);
    return new Vf(i,t)
}
function _d(e, t, n) {
    if (n && e.shouldReuseRoute(t.value, n.value.snapshot)) {
        let i = n.value;
        i._futureSnapshot = t.value;
        let r = BR(e, t, n);
        return new fs(i,r)
    } else {
        if (e.shouldAttach(t.value)) {
            let s = e.retrieve(t.value);
            if (s !== null) {
                let o = s.route;
                return o.value._futureSnapshot = t.value,
                o.children = t.children.map(a => _d(e, a)),
                o
            }
        }
        let i = UR(t.value)
          , r = t.children.map(s => _d(e, s));
        return new fs(i,r)
    }
}
function BR(e, t, n) {
    return t.children.map(i => {
        for (let r of n.children)
            if (e.shouldReuseRoute(i.value, r.value.snapshot))
                return _d(e, i, r);
        return _d(e, i)
    }
    )
}
function UR(e) {
    return new No(new Ne(e.url),new Ne(e.params),new Ne(e.queryParams),new Ne(e.fragment),new Ne(e.data),e.outlet,e.component,e)
}
var yd = class {
    redirectTo;
    navigationBehaviorOptions;
    constructor(t, n) {
        this.redirectTo = t,
        this.navigationBehaviorOptions = n
    }
}
  , Sb = "ngNavigationCancelingError";
function jf(e, t) {
    let {redirectTo: n, navigationBehaviorOptions: i} = Tl(t) ? {
        redirectTo: t,
        navigationBehaviorOptions: void 0
    } : t
      , r = xb(!1, ps.Redirect);
    return r.url = n,
    r.navigationBehaviorOptions = i,
    r
}
function xb(e, t) {
    let n = new Error(`NavigationCancelingError: ${e || ""}`);
    return n[Sb] = !0,
    n.cancellationCode = t,
    n
}
function HR(e) {
    return wb(e) && Tl(e.url)
}
function wb(e) {
    return !!e && e[Sb]
}
var GR = (e, t, n, i) => $e(r => (new ig(t,r.targetRouterState,r.currentRouterState,n,i).activate(e),
r))
  , ig = class {
    routeReuseStrategy;
    futureState;
    currState;
    forwardEvent;
    inputBindingEnabled;
    constructor(t, n, i, r, s) {
        this.routeReuseStrategy = t,
        this.futureState = n,
        this.currState = i,
        this.forwardEvent = r,
        this.inputBindingEnabled = s
    }
    activate(t) {
        let n = this.futureState._root
          , i = this.currState ? this.currState._root : null;
        this.deactivateChildRoutes(n, i, t),
        N6(this.futureState.root),
        this.activateChildRoutes(n, i, t)
    }
    deactivateChildRoutes(t, n, i) {
        let r = nu(n);
        t.children.forEach(s => {
            let o = s.value.outlet;
            this.deactivateRoutes(s, r[o], i),
            delete r[o]
        }
        ),
        Object.values(r).forEach(s => {
            this.deactivateRouteAndItsChildren(s, i)
        }
        )
    }
    deactivateRoutes(t, n, i) {
        let r = t.value
          , s = n ? n.value : null;
        if (r === s)
            if (r.component) {
                let o = i.getContext(r.outlet);
                o && this.deactivateChildRoutes(t, n, o.children)
            } else
                this.deactivateChildRoutes(t, n, i);
        else
            s && this.deactivateRouteAndItsChildren(n, i)
    }
    deactivateRouteAndItsChildren(t, n) {
        t.value.component && this.routeReuseStrategy.shouldDetach(t.value.snapshot) ? this.detachAndStoreRouteSubtree(t, n) : this.deactivateRouteAndOutlet(t, n)
    }
    detachAndStoreRouteSubtree(t, n) {
        let i = n.getContext(t.value.outlet)
          , r = i && t.value.component ? i.children : n
          , s = nu(t);
        for (let o of Object.values(s))
            this.deactivateRouteAndItsChildren(o, r);
        if (i && i.outlet) {
            let o = i.outlet.detach()
              , a = i.children.onOutletDeactivated();
            this.routeReuseStrategy.store(t.value.snapshot, {
                componentRef: o,
                route: t,
                contexts: a
            })
        }
    }
    deactivateRouteAndOutlet(t, n) {
        let i = n.getContext(t.value.outlet)
          , r = i && t.value.component ? i.children : n
          , s = nu(t);
        for (let o of Object.values(s))
            this.deactivateRouteAndItsChildren(o, r);
        i && (i.outlet && (i.outlet.deactivate(),
        i.children.onOutletDeactivated()),
        i.attachRef = null,
        i.route = null)
    }
    activateChildRoutes(t, n, i) {
        let r = nu(n);
        t.children.forEach(s => {
            this.activateRoutes(s, r[s.value.outlet], i),
            this.forwardEvent(new Q6(s.value.snapshot))
        }
        ),
        t.children.length && this.forwardEvent(new K6(t.value.snapshot))
    }
    activateRoutes(t, n, i) {
        let r = t.value
          , s = n ? n.value : null;
        if (N6(r),
        r === s)
            if (r.component) {
                let o = i.getOrCreateContext(r.outlet);
                this.activateChildRoutes(t, n, o.children)
            } else
                this.activateChildRoutes(t, n, i);
        else if (r.component) {
            let o = i.getOrCreateContext(r.outlet);
            if (this.routeReuseStrategy.shouldAttach(r.snapshot)) {
                let a = this.routeReuseStrategy.retrieve(r.snapshot);
                this.routeReuseStrategy.store(r.snapshot, null),
                o.children.onOutletReAttached(a.contexts),
                o.attachRef = a.componentRef,
                o.route = a.route.value,
                o.outlet && o.outlet.attach(a.componentRef, a.route.value),
                N6(a.route.value),
                this.activateChildRoutes(t, null, o.children)
            } else
                o.attachRef = null,
                o.route = r,
                o.outlet && o.outlet.activateWith(r, o.injector),
                this.activateChildRoutes(t, null, o.children)
        } else
            this.activateChildRoutes(t, null, i)
    }
}
  , qf = class {
    path;
    route;
    constructor(t) {
        this.path = t,
        this.route = this.path[this.path.length - 1]
    }
}
  , su = class {
    component;
    route;
    constructor(t, n) {
        this.component = t,
        this.route = n
    }
}
;
function VR(e, t, n) {
    let i = e._root
      , r = t ? t._root : null;
    return hd(i, r, n, [i.value])
}
function WR(e) {
    let t = e.routeConfig ? e.routeConfig.canActivateChild : null;
    return !t || t.length === 0 ? null : {
        node: e,
        guards: t
    }
}
function uu(e, t) {
    let n = Symbol()
      , i = t.get(e, n);
    return i === n ? typeof e == "function" && !cv(e) ? e : t.get(e) : i
}
function hd(e, t, n, i, r={
    canDeactivateChecks: [],
    canActivateChecks: []
}) {
    let s = nu(t);
    return e.children.forEach(o => {
        $R(o, s[o.value.outlet], n, i.concat([o.value]), r),
        delete s[o.value.outlet]
    }
    ),
    Object.entries(s).forEach( ([o,a]) => pd(a, n.getContext(o), r)),
    r
}
function $R(e, t, n, i, r={
    canDeactivateChecks: [],
    canActivateChecks: []
}) {
    let s = e.value
      , o = t ? t.value : null
      , a = n ? n.getContext(e.value.outlet) : null;
    if (o && s.routeConfig === o.routeConfig) {
        let c = jR(o, s, s.routeConfig.runGuardsAndResolvers);
        c ? r.canActivateChecks.push(new qf(i)) : (s.data = o.data,
        s._resolvedData = o._resolvedData),
        s.component ? hd(e, t, a ? a.children : null, i, r) : hd(e, t, n, i, r),
        c && a && a.outlet && a.outlet.isActivated && r.canDeactivateChecks.push(new su(a.outlet.component,o))
    } else
        o && pd(t, a, r),
        r.canActivateChecks.push(new qf(i)),
        s.component ? hd(e, null, a ? a.children : null, i, r) : hd(e, null, n, i, r);
    return r
}
function jR(e, t, n) {
    if (typeof n == "function")
        return n(e, t);
    switch (n) {
    case "pathParamsChange":
        return !El(e.url, t.url);
    case "pathParamsOrQueryParamsChange":
        return !El(e.url, t.url) || !Io(e.queryParams, t.queryParams);
    case "always":
        return !0;
    case "paramsOrQueryParamsChange":
        return !tg(e, t) || !Io(e.queryParams, t.queryParams);
    case "paramsChange":
    default:
        return !tg(e, t)
    }
}
function pd(e, t, n) {
    let i = nu(e)
      , r = e.value;
    Object.entries(i).forEach( ([s,o]) => {
        r.component ? t ? pd(o, t.children.getContext(s), n) : pd(o, null, n) : pd(o, t, n)
    }
    ),
    r.component ? t && t.outlet && t.outlet.isActivated ? n.canDeactivateChecks.push(new su(t.outlet.component,r)) : n.canDeactivateChecks.push(new su(null,r)) : n.canDeactivateChecks.push(new su(null,r))
}
function Od(e) {
    return typeof e == "function"
}
function qR(e) {
    return typeof e == "boolean"
}
function zR(e) {
    return e && Od(e.canLoad)
}
function XR(e) {
    return e && Od(e.canActivate)
}
function KR(e) {
    return e && Od(e.canActivateChild)
}
function YR(e) {
    return e && Od(e.canDeactivate)
}
function QR(e) {
    return e && Od(e.canMatch)
}
function Cb(e) {
    return e instanceof Z8 || e?.name === "EmptyError"
}
var If = Symbol("INITIAL_VALUE");
function lu() {
    return Vt(e => ll(e.map(t => t.pipe(Lt(1), Oh(If)))).pipe($e(t => {
        for (let n of t)
            if (n !== !0) {
                if (n === If)
                    return If;
                if (n === !1 || JR(n))
                    return n
            }
        return !0
    }
    ), mt(t => t !== If), Lt(1)))
}
function JR(e) {
    return Tl(e) || e instanceof yd
}
function ZR(e, t) {
    return ci(n => {
        let {targetSnapshot: i, currentSnapshot: r, guards: {canActivateChecks: s, canDeactivateChecks: o}} = n;
        return o.length === 0 && s.length === 0 ? Be(ve(C({}, n), {
            guardsResult: !0
        })) : eD(o, i, r, e).pipe(ci(a => a && qR(a) ? tD(i, s, e, t) : Be(a)), $e(a => ve(C({}, n), {
            guardsResult: a
        })))
    }
    )
}
function eD(e, t, n, i) {
    return Qn(e).pipe(ci(r => oD(r.component, r.route, n, t, i)), Jn(r => r !== !0, !0))
}
function tD(e, t, n, i) {
    return Qn(t).pipe(ui(r => I0(iD(r.route.parent, i), nD(r.route, i), sD(e, r.path, n), rD(e, r.route, n))), Jn(r => r !== !0, !0))
}
function nD(e, t) {
    return e !== null && t && t(new Y6(e)),
    Be(!0)
}
function iD(e, t) {
    return e !== null && t && t(new X6(e)),
    Be(!0)
}
function rD(e, t, n) {
    let i = t.routeConfig ? t.routeConfig.canActivate : null;
    if (!i || i.length === 0)
        return Be(!0);
    let r = i.map(s => R0( () => {
        let o = Ed(t) ?? n
          , a = uu(s, o)
          , c = XR(a) ? a.canActivate(t, e) : So(o, () => a(t, e));
        return bc(c).pipe(Jn())
    }
    ));
    return Be(r).pipe(lu())
}
function sD(e, t, n) {
    let i = t[t.length - 1]
      , s = t.slice(0, t.length - 1).reverse().map(o => WR(o)).filter(o => o !== null).map(o => R0( () => {
        let a = o.guards.map(c => {
            let l = Ed(o.node) ?? n
              , u = uu(c, l)
              , h = KR(u) ? u.canActivateChild(i, e) : So(l, () => u(i, e));
            return bc(h).pipe(Jn())
        }
        );
        return Be(a).pipe(lu())
    }
    ));
    return Be(s).pipe(lu())
}
function oD(e, t, n, i, r) {
    let s = t && t.routeConfig ? t.routeConfig.canDeactivate : null;
    if (!s || s.length === 0)
        return Be(!0);
    let o = s.map(a => {
        let c = Ed(t) ?? r
          , l = uu(a, c)
          , u = YR(l) ? l.canDeactivate(e, t, n, i) : So(c, () => l(e, t, n, i));
        return bc(u).pipe(Jn())
    }
    );
    return Be(o).pipe(lu())
}
function aD(e, t, n, i) {
    let r = t.canLoad;
    if (r === void 0 || r.length === 0)
        return Be(!0);
    let s = r.map(o => {
        let a = uu(o, e)
          , c = zR(a) ? a.canLoad(t, n) : So(e, () => a(t, n));
        return bc(c)
    }
    );
    return Be(s).pipe(lu(), Eb(i))
}
function Eb(e) {
    return g5(Ge(t => {
        if (typeof t != "boolean")
            throw jf(e, t)
    }
    ), $e(t => t === !0))
}
function cD(e, t, n, i) {
    let r = t.canMatch;
    if (!r || r.length === 0)
        return Be(!0);
    let s = r.map(o => {
        let a = uu(o, e)
          , c = QR(a) ? a.canMatch(t, n) : So(e, () => a(t, n));
        return bc(c)
    }
    );
    return Be(s).pipe(lu(), Eb(i))
}
var bd = class {
    segmentGroup;
    constructor(t) {
        this.segmentGroup = t || null
    }
}
  , Sd = class extends Error {
    urlTree;
    constructor(t) {
        super(),
        this.urlTree = t
    }
}
;
function tu(e) {
    return Hr(new bd(e))
}
function lD(e) {
    return Hr(new hi(4e3,!1))
}
function uD(e) {
    return Hr(xb(!1, ps.GuardRejected))
}
var rg = class {
    urlSerializer;
    urlTree;
    constructor(t, n) {
        this.urlSerializer = t,
        this.urlTree = n
    }
    lineralizeSegments(t, n) {
        let i = []
          , r = n.root;
        for (; ; ) {
            if (i = i.concat(r.segments),
            r.numberOfChildren === 0)
                return Be(i);
            if (r.numberOfChildren > 1 || !r.children[Ct])
                return lD(`${t.redirectTo}`);
            r = r.children[Ct]
        }
    }
    applyRedirectCommands(t, n, i, r, s) {
        if (typeof n != "string") {
            let a = n
              , {queryParams: c, fragment: l, routeConfig: u, url: h, outlet: d, params: f, data: g, title: p} = r
              , v = So(s, () => a({
                params: f,
                data: g,
                queryParams: c,
                fragment: l,
                routeConfig: u,
                url: h,
                outlet: d,
                title: p
            }));
            if (v instanceof ya)
                throw new Sd(v);
            n = v
        }
        let o = this.applyRedirectCreateUrlTree(n, this.urlSerializer.parse(n), t, i);
        if (n[0] === "/")
            throw new Sd(o);
        return o
    }
    applyRedirectCreateUrlTree(t, n, i, r) {
        let s = this.createSegmentGroup(t, n.root, i, r);
        return new ya(s,this.createQueryParams(n.queryParams, this.urlTree.queryParams),n.fragment)
    }
    createQueryParams(t, n) {
        let i = {};
        return Object.entries(t).forEach( ([r,s]) => {
            if (typeof s == "string" && s[0] === ":") {
                let a = s.substring(1);
                i[r] = n[a]
            } else
                i[r] = s
        }
        ),
        i
    }
    createSegmentGroup(t, n, i, r) {
        let s = this.createSegments(t, n.segments, i, r)
          , o = {};
        return Object.entries(n.children).forEach( ([a,c]) => {
            o[a] = this.createSegmentGroup(t, c, i, r)
        }
        ),
        new Kt(s,o)
    }
    createSegments(t, n, i, r) {
        return n.map(s => s.path[0] === ":" ? this.findPosParam(t, s, r) : this.findOrReturn(s, i))
    }
    findPosParam(t, n, i) {
        let r = i[n.path.substring(1)];
        if (!r)
            throw new hi(4001,!1);
        return r
    }
    findOrReturn(t, n) {
        let i = 0;
        for (let r of n) {
            if (r.path === t.path)
                return n.splice(i),
                r;
            i++
        }
        return t
    }
}
  , sg = {
    matched: !1,
    consumedSegments: [],
    remainingSegments: [],
    parameters: {},
    positionalParamSegments: {}
};
function hD(e, t, n, i, r) {
    let s = Tb(e, t, n);
    return s.matched ? (i = IR(t, i),
    cD(i, t, n, r).pipe($e(o => o === !0 ? s : C({}, sg)))) : Be(s)
}
function Tb(e, t, n) {
    if (t.path === "**")
        return dD(n);
    if (t.path === "")
        return t.pathMatch === "full" && (e.hasChildren() || n.length > 0) ? C({}, sg) : {
            matched: !0,
            consumedSegments: [],
            remainingSegments: n,
            parameters: {},
            positionalParamSegments: {}
        };
    let r = (t.matcher || oR)(n, e, t);
    if (!r)
        return C({}, sg);
    let s = {};
    Object.entries(r.posParams ?? {}).forEach( ([a,c]) => {
        s[a] = c.path
    }
    );
    let o = r.consumed.length > 0 ? C(C({}, s), r.consumed[r.consumed.length - 1].parameters) : s;
    return {
        matched: !0,
        consumedSegments: r.consumed,
        remainingSegments: n.slice(r.consumed.length),
        parameters: o,
        positionalParamSegments: r.posParams ?? {}
    }
}
function dD(e) {
    return {
        matched: !0,
        parameters: e.length > 0 ? sb(e).parameters : {},
        consumedSegments: e,
        remainingSegments: [],
        positionalParamSegments: {}
    }
}
function Zy(e, t, n, i) {
    return n.length > 0 && gD(e, n, i) ? {
        segmentGroup: new Kt(t,pD(i, new Kt(n,e.children))),
        slicedSegments: []
    } : n.length === 0 && mD(e, n, i) ? {
        segmentGroup: new Kt(e.segments,fD(e, n, i, e.children)),
        slicedSegments: n
    } : {
        segmentGroup: new Kt(e.segments,e.children),
        slicedSegments: n
    }
}
function fD(e, t, n, i) {
    let r = {};
    for (let s of n)
        if (Kf(e, t, s) && !i[Zs(s)]) {
            let o = new Kt([],{});
            r[Zs(s)] = o
        }
    return C(C({}, i), r)
}
function pD(e, t) {
    let n = {};
    n[Ct] = t;
    for (let i of e)
        if (i.path === "" && Zs(i) !== Ct) {
            let r = new Kt([],{});
            n[Zs(i)] = r
        }
    return n
}
function gD(e, t, n) {
    return n.some(i => Kf(e, t, i) && Zs(i) !== Ct)
}
function mD(e, t, n) {
    return n.some(i => Kf(e, t, i))
}
function Kf(e, t, n) {
    return (e.hasChildren() || t.length > 0) && n.pathMatch === "full" ? !1 : n.path === ""
}
function vD(e, t, n) {
    return t.length === 0 && !e.children[n]
}
var og = class {
}
;
function _D(e, t, n, i, r, s, o="emptyOnly") {
    return new ag(e,t,n,i,r,o,s).recognize()
}
var yD = 31
  , ag = class {
    injector;
    configLoader;
    rootComponentType;
    config;
    urlTree;
    paramsInheritanceStrategy;
    urlSerializer;
    applyRedirects;
    absoluteRedirectCount = 0;
    allowRedirects = !0;
    constructor(t, n, i, r, s, o, a) {
        this.injector = t,
        this.configLoader = n,
        this.rootComponentType = i,
        this.config = r,
        this.urlTree = s,
        this.paramsInheritanceStrategy = o,
        this.urlSerializer = a,
        this.applyRedirects = new rg(this.urlSerializer,this.urlTree)
    }
    noMatchError(t) {
        return new hi(4002,`'${t.segmentGroup}'`)
    }
    recognize() {
        let t = Zy(this.urlTree.root, [], [], this.config).segmentGroup;
        return this.match(t).pipe($e( ({children: n, rootSnapshot: i}) => {
            let r = new fs(i,n)
              , s = new $f("",r)
              , o = ER(i, [], this.urlTree.queryParams, this.urlTree.fragment);
            return o.queryParams = this.urlTree.queryParams,
            s.url = this.urlSerializer.serialize(o),
            {
                state: s,
                tree: o
            }
        }
        ))
    }
    match(t) {
        let n = new ru([],Object.freeze({}),Object.freeze(C({}, this.urlTree.queryParams)),this.urlTree.fragment,Object.freeze({}),Ct,this.rootComponentType,null,{});
        return this.processSegmentGroup(this.injector, this.config, t, Ct, n).pipe($e(i => ({
            children: i,
            rootSnapshot: n
        })), on(i => {
            if (i instanceof Sd)
                return this.urlTree = i.urlTree,
                this.match(i.urlTree.root);
            throw i instanceof bd ? this.noMatchError(i) : i
        }
        ))
    }
    processSegmentGroup(t, n, i, r, s) {
        return i.segments.length === 0 && i.hasChildren() ? this.processChildren(t, n, i, s) : this.processSegment(t, n, i, i.segments, r, !0, s).pipe($e(o => o instanceof fs ? [o] : []))
    }
    processChildren(t, n, i, r) {
        let s = [];
        for (let o of Object.keys(i.children))
            o === "primary" ? s.unshift(o) : s.push(o);
        return Qn(s).pipe(ui(o => {
            let a = i.children[o]
              , c = RR(n, o);
            return this.processSegmentGroup(t, c, a, o, r)
        }
        ), F0( (o, a) => (o.push(...a),
        o)), Xp(null), iv(), ci(o => {
            if (o === null)
                return tu(i);
            let a = Ob(o);
            return bD(a),
            Be(a)
        }
        ))
    }
    processSegment(t, n, i, r, s, o, a) {
        return Qn(n).pipe(ui(c => this.processSegmentAgainstRoute(c._injector ?? t, n, c, i, r, s, o, a).pipe(on(l => {
            if (l instanceof bd)
                return Be(null);
            throw l
        }
        ))), Jn(c => !!c), on(c => {
            if (Cb(c))
                return vD(i, r, s) ? Be(new og) : tu(i);
            throw c
        }
        ))
    }
    processSegmentAgainstRoute(t, n, i, r, s, o, a, c) {
        return Zs(i) !== o && (o === Ct || !Kf(r, s, i)) ? tu(r) : i.redirectTo === void 0 ? this.matchSegmentAgainstRoute(t, r, i, s, o, c) : this.allowRedirects && a ? this.expandSegmentAgainstRouteUsingRedirect(t, r, n, i, s, o, c) : tu(r)
    }
    expandSegmentAgainstRouteUsingRedirect(t, n, i, r, s, o, a) {
        let {matched: c, parameters: l, consumedSegments: u, positionalParamSegments: h, remainingSegments: d} = Tb(n, r, s);
        if (!c)
            return tu(n);
        typeof r.redirectTo == "string" && r.redirectTo[0] === "/" && (this.absoluteRedirectCount++,
        this.absoluteRedirectCount > yD && (this.allowRedirects = !1));
        let f = new ru(s,l,Object.freeze(C({}, this.urlTree.queryParams)),this.urlTree.fragment,eb(r),Zs(r),r.component ?? r._loadedComponent ?? null,r,tb(r))
          , g = Wf(f, a, this.paramsInheritanceStrategy);
        f.params = Object.freeze(g.params),
        f.data = Object.freeze(g.data);
        let p = this.applyRedirects.applyRedirectCommands(u, r.redirectTo, h, f, t);
        return this.applyRedirects.lineralizeSegments(r, p).pipe(ci(v => this.processSegment(t, i, n, v.concat(d), o, !1, a)))
    }
    matchSegmentAgainstRoute(t, n, i, r, s, o) {
        let a = hD(n, i, r, t, this.urlSerializer);
        return i.path === "**" && (n.children = {}),
        a.pipe(Vt(c => c.matched ? (t = i._injector ?? t,
        this.getChildConfig(t, i, r).pipe(Vt( ({routes: l}) => {
            let u = i._loadedInjector ?? t
              , {parameters: h, consumedSegments: d, remainingSegments: f} = c
              , g = new ru(d,h,Object.freeze(C({}, this.urlTree.queryParams)),this.urlTree.fragment,eb(i),Zs(i),i.component ?? i._loadedComponent ?? null,i,tb(i))
              , p = Wf(g, o, this.paramsInheritanceStrategy);
            g.params = Object.freeze(p.params),
            g.data = Object.freeze(p.data);
            let {segmentGroup: v, slicedSegments: b} = Zy(n, d, f, l);
            if (b.length === 0 && v.hasChildren())
                return this.processChildren(u, l, v, g).pipe($e(w => new fs(g,w)));
            if (l.length === 0 && b.length === 0)
                return Be(new fs(g,[]));
            let S = Zs(i) === s;
            return this.processSegment(u, l, v, b, S ? Ct : s, !0, g).pipe($e(w => new fs(g,w instanceof fs ? [w] : [])))
        }
        ))) : tu(n)))
    }
    getChildConfig(t, n, i) {
        return n.children ? Be({
            routes: n.children,
            injector: t
        }) : n.loadChildren ? n._loadedRoutes !== void 0 ? Be({
            routes: n._loadedRoutes,
            injector: n._loadedInjector
        }) : aD(t, n, i, this.urlSerializer).pipe(ci(r => r ? this.configLoader.loadChildren(t, n).pipe(Ge(s => {
            n._loadedRoutes = s.routes,
            n._loadedInjector = s.injector
        }
        )) : uD(n))) : Be({
            routes: [],
            injector: t
        })
    }
}
;
function bD(e) {
    e.sort( (t, n) => t.value.outlet === Ct ? -1 : n.value.outlet === Ct ? 1 : t.value.outlet.localeCompare(n.value.outlet))
}
function SD(e) {
    let t = e.value.routeConfig;
    return t && t.path === ""
}
function Ob(e) {
    let t = []
      , n = new Set;
    for (let i of e) {
        if (!SD(i)) {
            t.push(i);
            continue
        }
        let r = t.find(s => i.value.routeConfig === s.value.routeConfig);
        r !== void 0 ? (r.children.push(...i.children),
        n.add(r)) : t.push(i)
    }
    for (let i of n) {
        let r = Ob(i.children);
        t.push(new fs(i.value,r))
    }
    return t.filter(i => !n.has(i))
}
function eb(e) {
    return e.data || {}
}
function tb(e) {
    return e.resolve || {}
}
function xD(e, t, n, i, r, s) {
    return ci(o => _D(e, t, n, i, o.extractedUrl, r, s).pipe($e( ({state: a, tree: c}) => ve(C({}, o), {
        targetSnapshot: a,
        urlAfterRedirects: c
    }))))
}
function wD(e, t) {
    return ci(n => {
        let {targetSnapshot: i, guards: {canActivateChecks: r}} = n;
        if (!r.length)
            return Be(n);
        let s = new Set(r.map(c => c.route))
          , o = new Set;
        for (let c of s)
            if (!o.has(c))
                for (let l of Pb(c))
                    o.add(l);
        let a = 0;
        return Qn(o).pipe(ui(c => s.has(c) ? CD(c, i, e, t) : (c.data = Wf(c, c.parent, e).resolve,
        Be(void 0))), Ge( () => a++), Kp(1), ci(c => a === o.size ? Be(n) : Ur))
    }
    )
}
function Pb(e) {
    let t = e.children.map(n => Pb(n)).flat();
    return [e, ...t]
}
function CD(e, t, n, i) {
    let r = e.routeConfig
      , s = e._resolve;
    return r?.title !== void 0 && !bb(r) && (s[wd] = r.title),
    ED(s, e, t, i).pipe($e(o => (e._resolvedData = o,
    e.data = Wf(e, e.parent, n).resolve,
    null)))
}
function ED(e, t, n, i) {
    let r = B6(e);
    if (r.length === 0)
        return Be({});
    let s = {};
    return Qn(r).pipe(ci(o => TD(e[o], t, n, i).pipe(Jn(), Ge(a => {
        if (a instanceof yd)
            throw jf(new au, a);
        s[o] = a
    }
    ))), Kp(1), $e( () => s), on(o => Cb(o) ? Ur : Hr(o)))
}
function TD(e, t, n, i) {
    let r = Ed(t) ?? i
      , s = uu(e, r)
      , o = s.resolve ? s.resolve(t, n) : So(r, () => s(t, n));
    return bc(o)
}
function F6(e) {
    return Vt(t => {
        let n = e(t);
        return n ? Qn(n).pipe($e( () => t)) : Be(t)
    }
    )
}
var Mb = ( () => {
    class e {
        buildTitle(n) {
            let i, r = n.root;
            for (; r !== void 0; )
                i = this.getResolvedTitleForRoute(r) ?? i,
                r = r.children.find(s => s.outlet === Ct);
            return i
        }
        getResolvedTitleForRoute(n) {
            return n.data[wd]
        }
        static \u0275fac = function(i) {
            return new (i || e)
        }
        ;
        static \u0275prov = re({
            token: e,
            factory: () => z(OD),
            providedIn: "root"
        })
    }
    return e
}
)()
  , OD = ( () => {
    class e extends Mb {
        title;
        constructor(n) {
            super(),
            this.title = n
        }
        updateTitle(n) {
            let i = this.buildTitle(n);
            i !== void 0 && this.title.setTitle(i)
        }
        static \u0275fac = function(i) {
            return new (i || e)(xe(qy))
        }
        ;
        static \u0275prov = re({
            token: e,
            factory: e.\u0275fac,
            providedIn: "root"
        })
    }
    return e
}
)()
  , Pd = new Ze("",{
    providedIn: "root",
    factory: () => ({})
})
  , PD = ( () => {
    class e {
        static \u0275fac = function(i) {
            return new (i || e)
        }
        ;
        static \u0275cmp = Ye({
            type: e,
            selectors: [["ng-component"]],
            exportAs: ["emptyRouterOutlet"],
            decls: 1,
            vars: 0,
            template: function(i, r) {
                i & 1 && me(0, "router-outlet")
            },
            dependencies: [FR],
            encapsulation: 2
        })
    }
    return e
}
)();
function ug(e) {
    let t = e.children && e.children.map(ug)
      , n = t ? ve(C({}, e), {
        children: t
    }) : C({}, e);
    return !n.component && !n.loadComponent && (t || n.loadChildren) && n.outlet && n.outlet !== Ct && (n.component = PD),
    n
}
var xd = new Ze("")
  , hg = ( () => {
    class e {
        componentLoaders = new WeakMap;
        childrenLoaders = new WeakMap;
        onLoadStartListener;
        onLoadEndListener;
        compiler = z(O5);
        loadComponent(n) {
            if (this.componentLoaders.get(n))
                return this.componentLoaders.get(n);
            if (n._loadedComponent)
                return Be(n._loadedComponent);
            this.onLoadStartListener && this.onLoadStartListener(n);
            let i = bc(n.loadComponent()).pipe($e(kb), Ge(s => {
                this.onLoadEndListener && this.onLoadEndListener(n),
                n._loadedComponent = s
            }
            ), gr( () => {
                this.componentLoaders.delete(n)
            }
            ))
              , r = new jp(i, () => new lt).pipe($p());
            return this.componentLoaders.set(n, r),
            r
        }
        loadChildren(n, i) {
            if (this.childrenLoaders.get(i))
                return this.childrenLoaders.get(i);
            if (i._loadedRoutes)
                return Be({
                    routes: i._loadedRoutes,
                    injector: i._loadedInjector
                });
            this.onLoadStartListener && this.onLoadStartListener(i);
            let s = MD(i, this.compiler, n, this.onLoadEndListener).pipe(gr( () => {
                this.childrenLoaders.delete(i)
            }
            ))
              , o = new jp(s, () => new lt).pipe($p());
            return this.childrenLoaders.set(i, o),
            o
        }
        static \u0275fac = function(i) {
            return new (i || e)
        }
        ;
        static \u0275prov = re({
            token: e,
            factory: e.\u0275fac,
            providedIn: "root"
        })
    }
    return e
}
)();
function MD(e, t, n, i) {
    return bc(e.loadChildren()).pipe($e(kb), ci(r => r instanceof yv || Array.isArray(r) ? Be(r) : Qn(t.compileModuleAsync(r))), $e(r => {
        i && i(e);
        let s, o, a = !1;
        return Array.isArray(r) ? (o = r,
        a = !0) : (s = r.create(n).injector,
        o = s.get(xd, [], {
            optional: !0,
            self: !0
        }).flat()),
        {
            routes: o.map(ug),
            injector: s
        }
    }
    ))
}
function kD(e) {
    return e && typeof e == "object" && "default"in e
}
function kb(e) {
    return kD(e) ? e.default : e
}
var dg = ( () => {
    class e {
        static \u0275fac = function(i) {
            return new (i || e)
        }
        ;
        static \u0275prov = re({
            token: e,
            factory: () => z(AD),
            providedIn: "root"
        })
    }
    return e
}
)()
  , AD = ( () => {
    class e {
        shouldProcessUrl(n) {
            return !0
        }
        extract(n) {
            return n
        }
        merge(n, i) {
            return n
        }
        static \u0275fac = function(i) {
            return new (i || e)
        }
        ;
        static \u0275prov = re({
            token: e,
            factory: e.\u0275fac,
            providedIn: "root"
        })
    }
    return e
}
)()
  , Ab = new Ze("")
  , Ib = new Ze("");
function ID(e, t, n) {
    let i = e.get(Ib)
      , r = e.get(Nn);
    return e.get(Rn).runOutsideAngular( () => {
        if (!r.startViewTransition || i.skipNextTransition)
            return i.skipNextTransition = !1,
            new Promise(l => setTimeout(l));
        let s, o = new Promise(l => {
            s = l
        }
        ), a = r.startViewTransition( () => (s(),
        RD(e))), {onViewTransitionCreated: c} = i;
        return c && So(e, () => c({
            transition: a,
            from: t,
            to: n
        })),
        o
    }
    )
}
function RD(e) {
    return new Promise(t => {
        fl({
            read: () => setTimeout(t)
        }, {
            injector: e
        })
    }
    )
}
var Rb = new Ze("")
  , fg = ( () => {
    class e {
        currentNavigation = null;
        currentTransition = null;
        lastSuccessfulNavigation = null;
        events = new lt;
        transitionAbortSubject = new lt;
        configLoader = z(hg);
        environmentInjector = z(rc);
        urlSerializer = z(Cd);
        rootContexts = z(Td);
        location = z(Dh);
        inputBindingEnabled = z(Xf, {
            optional: !0
        }) !== null;
        titleStrategy = z(Mb);
        options = z(Pd, {
            optional: !0
        }) || {};
        paramsInheritanceStrategy = this.options.paramsInheritanceStrategy || "emptyOnly";
        urlHandlingStrategy = z(dg);
        createViewTransition = z(Ab, {
            optional: !0
        });
        navigationErrorHandler = z(Rb, {
            optional: !0
        });
        navigationId = 0;
        get hasRequestedNavigation() {
            return this.navigationId !== 0
        }
        transitions;
        afterPreactivation = () => Be(void 0);
        rootComponentType = null;
        constructor() {
            let n = r => this.events.next(new q6(r))
              , i = r => this.events.next(new z6(r));
            this.configLoader.onLoadEndListener = i,
            this.configLoader.onLoadStartListener = n
        }
        complete() {
            this.transitions?.complete()
        }
        handleNavigationRequest(n) {
            let i = ++this.navigationId;
            this.transitions?.next(ve(C(C({}, this.transitions.value), n), {
                id: i
            }))
        }
        setupNavigations(n, i, r) {
            return this.transitions = new Ne({
                id: 0,
                currentUrlTree: i,
                currentRawUrl: i,
                extractedUrl: this.urlHandlingStrategy.extract(i),
                urlAfterRedirects: this.urlHandlingStrategy.extract(i),
                rawUrl: i,
                extras: {},
                resolve: () => {}
                ,
                reject: () => {}
                ,
                promise: Promise.resolve(!0),
                source: fd,
                restoredState: null,
                currentSnapshot: r.snapshot,
                targetSnapshot: null,
                currentRouterState: r,
                targetRouterState: null,
                guards: {
                    canActivateChecks: [],
                    canDeactivateChecks: []
                },
                guardsResult: null
            }),
            this.transitions.pipe(mt(s => s.id !== 0), $e(s => ve(C({}, s), {
                extractedUrl: this.urlHandlingStrategy.extract(s.rawUrl)
            })), Vt(s => {
                let o = !1
                  , a = !1;
                return Be(s).pipe(Vt(c => {
                    if (this.navigationId > s.id)
                        return this.cancelNavigationTransition(s, "", ps.SupersededByNewNavigation),
                        Ur;
                    this.currentTransition = s,
                    this.currentNavigation = {
                        id: c.id,
                        initialUrl: c.rawUrl,
                        extractedUrl: c.extractedUrl,
                        targetBrowserUrl: typeof c.extras.browserUrl == "string" ? this.urlSerializer.parse(c.extras.browserUrl) : c.extras.browserUrl,
                        trigger: c.source,
                        extras: c.extras,
                        previousNavigation: this.lastSuccessfulNavigation ? ve(C({}, this.lastSuccessfulNavigation), {
                            previousNavigation: null
                        }) : null
                    };
                    let l = !n.navigated || this.isUpdatingInternalState() || this.isUpdatedBrowserUrl()
                      , u = c.extras.onSameUrlNavigation ?? n.onSameUrlNavigation;
                    if (!l && u !== "reload") {
                        let h = "";
                        return this.events.next(new Do(c.id,this.urlSerializer.serialize(c.rawUrl),h,Bf.IgnoredSameUrlNavigation)),
                        c.resolve(!1),
                        Ur
                    }
                    if (this.urlHandlingStrategy.shouldProcessUrl(c.rawUrl))
                        return Be(c).pipe(Vt(h => {
                            let d = this.transitions?.getValue();
                            return this.events.next(new yc(h.id,this.urlSerializer.serialize(h.extractedUrl),h.source,h.restoredState)),
                            d !== this.transitions?.getValue() ? Ur : Promise.resolve(h)
                        }
                        ), xD(this.environmentInjector, this.configLoader, this.rootComponentType, n.config, this.urlSerializer, this.paramsInheritanceStrategy), Ge(h => {
                            s.targetSnapshot = h.targetSnapshot,
                            s.urlAfterRedirects = h.urlAfterRedirects,
                            this.currentNavigation = ve(C({}, this.currentNavigation), {
                                finalUrl: h.urlAfterRedirects
                            });
                            let d = new Uf(h.id,this.urlSerializer.serialize(h.extractedUrl),this.urlSerializer.serialize(h.urlAfterRedirects),h.targetSnapshot);
                            this.events.next(d)
                        }
                        ));
                    if (l && this.urlHandlingStrategy.shouldProcessUrl(c.currentRawUrl)) {
                        let {id: h, extractedUrl: d, source: f, restoredState: g, extras: p} = c
                          , v = new yc(h,this.urlSerializer.serialize(d),f,g);
                        this.events.next(v);
                        let b = _b(this.rootComponentType).snapshot;
                        return this.currentTransition = s = ve(C({}, c), {
                            targetSnapshot: b,
                            urlAfterRedirects: d,
                            extras: ve(C({}, p), {
                                skipLocationChange: !1,
                                replaceUrl: !1
                            })
                        }),
                        this.currentNavigation.finalUrl = d,
                        Be(s)
                    } else {
                        let h = "";
                        return this.events.next(new Do(c.id,this.urlSerializer.serialize(c.extractedUrl),h,Bf.IgnoredByUrlHandlingStrategy)),
                        c.resolve(!1),
                        Ur
                    }
                }
                ), Ge(c => {
                    let l = new V6(c.id,this.urlSerializer.serialize(c.extractedUrl),this.urlSerializer.serialize(c.urlAfterRedirects),c.targetSnapshot);
                    this.events.next(l)
                }
                ), $e(c => (this.currentTransition = s = ve(C({}, c), {
                    guards: VR(c.targetSnapshot, c.currentSnapshot, this.rootContexts)
                }),
                s)), ZR(this.environmentInjector, c => this.events.next(c)), Ge(c => {
                    if (s.guardsResult = c.guardsResult,
                    c.guardsResult && typeof c.guardsResult != "boolean")
                        throw jf(this.urlSerializer, c.guardsResult);
                    let l = new W6(c.id,this.urlSerializer.serialize(c.extractedUrl),this.urlSerializer.serialize(c.urlAfterRedirects),c.targetSnapshot,!!c.guardsResult);
                    this.events.next(l)
                }
                ), mt(c => c.guardsResult ? !0 : (this.cancelNavigationTransition(c, "", ps.GuardRejected),
                !1)), F6(c => {
                    if (c.guards.canActivateChecks.length)
                        return Be(c).pipe(Ge(l => {
                            let u = new $6(l.id,this.urlSerializer.serialize(l.extractedUrl),this.urlSerializer.serialize(l.urlAfterRedirects),l.targetSnapshot);
                            this.events.next(u)
                        }
                        ), Vt(l => {
                            let u = !1;
                            return Be(l).pipe(wD(this.paramsInheritanceStrategy, this.environmentInjector), Ge({
                                next: () => u = !0,
                                complete: () => {
                                    u || this.cancelNavigationTransition(l, "", ps.NoDataFromResolver)
                                }
                            }))
                        }
                        ), Ge(l => {
                            let u = new j6(l.id,this.urlSerializer.serialize(l.extractedUrl),this.urlSerializer.serialize(l.urlAfterRedirects),l.targetSnapshot);
                            this.events.next(u)
                        }
                        ))
                }
                ), F6(c => {
                    let l = u => {
                        let h = [];
                        u.routeConfig?.loadComponent && !u.routeConfig._loadedComponent && h.push(this.configLoader.loadComponent(u.routeConfig).pipe(Ge(d => {
                            u.component = d
                        }
                        ), $e( () => {}
                        )));
                        for (let d of u.children)
                            h.push(...l(d));
                        return h
                    }
                    ;
                    return ll(l(c.targetSnapshot.root)).pipe(Xp(null), Lt(1))
                }
                ), F6( () => this.afterPreactivation()), Vt( () => {
                    let {currentSnapshot: c, targetSnapshot: l} = s
                      , u = this.createViewTransition?.(this.environmentInjector, c.root, l.root);
                    return u ? Qn(u).pipe($e( () => s)) : Be(s)
                }
                ), $e(c => {
                    let l = LR(n.routeReuseStrategy, c.targetSnapshot, c.currentRouterState);
                    return this.currentTransition = s = ve(C({}, c), {
                        targetRouterState: l
                    }),
                    this.currentNavigation.targetRouterState = l,
                    s
                }
                ), Ge( () => {
                    this.events.next(new vd)
                }
                ), GR(this.rootContexts, n.routeReuseStrategy, c => this.events.next(c), this.inputBindingEnabled), Lt(1), Ge({
                    next: c => {
                        o = !0,
                        this.lastSuccessfulNavigation = this.currentNavigation,
                        this.events.next(new Ro(c.id,this.urlSerializer.serialize(c.extractedUrl),this.urlSerializer.serialize(c.urlAfterRedirects))),
                        this.titleStrategy?.updateTitle(c.targetRouterState.snapshot),
                        c.resolve(!0)
                    }
                    ,
                    complete: () => {
                        o = !0
                    }
                }), In(this.transitionAbortSubject.pipe(Ge(c => {
                    throw c
                }
                ))), gr( () => {
                    !o && !a && this.cancelNavigationTransition(s, "", ps.SupersededByNewNavigation),
                    this.currentTransition?.id === s.id && (this.currentNavigation = null,
                    this.currentTransition = null)
                }
                ), on(c => {
                    if (a = !0,
                    wb(c))
                        this.events.next(new _a(s.id,this.urlSerializer.serialize(s.extractedUrl),c.message,c.cancellationCode)),
                        HR(c) ? this.events.next(new cu(c.url,c.navigationBehaviorOptions)) : s.resolve(!1);
                    else {
                        let l = new md(s.id,this.urlSerializer.serialize(s.extractedUrl),c,s.targetSnapshot ?? void 0);
                        try {
                            let u = So(this.environmentInjector, () => this.navigationErrorHandler?.(l));
                            if (u instanceof yd) {
                                let {message: h, cancellationCode: d} = jf(this.urlSerializer, u);
                                this.events.next(new _a(s.id,this.urlSerializer.serialize(s.extractedUrl),h,d)),
                                this.events.next(new cu(u.redirectTo,u.navigationBehaviorOptions))
                            } else
                                throw this.events.next(l),
                                c
                        } catch (u) {
                            this.options.resolveNavigationPromiseOnError ? s.resolve(!1) : s.reject(u)
                        }
                    }
                    return Ur
                }
                ))
            }
            ))
        }
        cancelNavigationTransition(n, i, r) {
            let s = new _a(n.id,this.urlSerializer.serialize(n.extractedUrl),i,r);
            this.events.next(s),
            n.resolve(!1)
        }
        isUpdatingInternalState() {
            return this.currentTransition?.extractedUrl.toString() !== this.currentTransition?.currentUrlTree.toString()
        }
        isUpdatedBrowserUrl() {
            let n = this.urlHandlingStrategy.extract(this.urlSerializer.parse(this.location.path(!0)))
              , i = this.currentNavigation?.targetBrowserUrl ?? this.currentNavigation?.extractedUrl;
            return n.toString() !== i?.toString() && !this.currentNavigation?.extras.skipLocationChange
        }
        static \u0275fac = function(i) {
            return new (i || e)
        }
        ;
        static \u0275prov = re({
            token: e,
            factory: e.\u0275fac,
            providedIn: "root"
        })
    }
    return e
}
)();
function DD(e) {
    return e !== fd
}
var ND = ( () => {
    class e {
        static \u0275fac = function(i) {
            return new (i || e)
        }
        ;
        static \u0275prov = re({
            token: e,
            factory: () => z(FD),
            providedIn: "root"
        })
    }
    return e
}
)()
  , cg = class {
    shouldDetach(t) {
        return !1
    }
    store(t, n) {}
    shouldAttach(t) {
        return !1
    }
    retrieve(t) {
        return null
    }
    shouldReuseRoute(t, n) {
        return t.routeConfig === n.routeConfig
    }
}
  , FD = ( () => {
    class e extends cg {
        static \u0275fac = ( () => {
            let n;
            return function(r) {
                return (n || (n = On(e)))(r || e)
            }
        }
        )();
        static \u0275prov = re({
            token: e,
            factory: e.\u0275fac,
            providedIn: "root"
        })
    }
    return e
}
)()
  , Db = ( () => {
    class e {
        static \u0275fac = function(i) {
            return new (i || e)
        }
        ;
        static \u0275prov = re({
            token: e,
            factory: () => z(LD),
            providedIn: "root"
        })
    }
    return e
}
)()
  , LD = ( () => {
    class e extends Db {
        location = z(Dh);
        urlSerializer = z(Cd);
        options = z(Pd, {
            optional: !0
        }) || {};
        canceledNavigationResolution = this.options.canceledNavigationResolution || "replace";
        urlHandlingStrategy = z(dg);
        urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred";
        currentUrlTree = new ya;
        getCurrentUrlTree() {
            return this.currentUrlTree
        }
        rawUrlTree = this.currentUrlTree;
        getRawUrlTree() {
            return this.rawUrlTree
        }
        currentPageId = 0;
        lastSuccessfulId = -1;
        restoredState() {
            return this.location.getState()
        }
        get browserPageId() {
            return this.canceledNavigationResolution !== "computed" ? this.currentPageId : this.restoredState()?.\u0275routerPageId ?? this.currentPageId
        }
        routerState = _b(null);
        getRouterState() {
            return this.routerState
        }
        stateMemento = this.createStateMemento();
        createStateMemento() {
            return {
                rawUrlTree: this.rawUrlTree,
                currentUrlTree: this.currentUrlTree,
                routerState: this.routerState
            }
        }
        registerNonRouterCurrentEntryChangeListener(n) {
            return this.location.subscribe(i => {
                i.type === "popstate" && n(i.url, i.state)
            }
            )
        }
        handleRouterEvent(n, i) {
            if (n instanceof yc)
                this.stateMemento = this.createStateMemento();
            else if (n instanceof Do)
                this.rawUrlTree = i.initialUrl;
            else if (n instanceof Uf) {
                if (this.urlUpdateStrategy === "eager" && !i.extras.skipLocationChange) {
                    let r = this.urlHandlingStrategy.merge(i.finalUrl, i.initialUrl);
                    this.setBrowserUrl(i.targetBrowserUrl ?? r, i)
                }
            } else
                n instanceof vd ? (this.currentUrlTree = i.finalUrl,
                this.rawUrlTree = this.urlHandlingStrategy.merge(i.finalUrl, i.initialUrl),
                this.routerState = i.targetRouterState,
                this.urlUpdateStrategy === "deferred" && !i.extras.skipLocationChange && this.setBrowserUrl(i.targetBrowserUrl ?? this.rawUrlTree, i)) : n instanceof _a && (n.code === ps.GuardRejected || n.code === ps.NoDataFromResolver) ? this.restoreHistory(i) : n instanceof md ? this.restoreHistory(i, !0) : n instanceof Ro && (this.lastSuccessfulId = n.id,
                this.currentPageId = this.browserPageId)
        }
        setBrowserUrl(n, i) {
            let r = n instanceof ya ? this.urlSerializer.serialize(n) : n;
            if (this.location.isCurrentPathEqualTo(r) || i.extras.replaceUrl) {
                let s = this.browserPageId
                  , o = C(C({}, i.extras.state), this.generateNgRouterState(i.id, s));
                this.location.replaceState(r, "", o)
            } else {
                let s = C(C({}, i.extras.state), this.generateNgRouterState(i.id, this.browserPageId + 1));
                this.location.go(r, "", s)
            }
        }
        restoreHistory(n, i=!1) {
            if (this.canceledNavigationResolution === "computed") {
                let r = this.browserPageId
                  , s = this.currentPageId - r;
                s !== 0 ? this.location.historyGo(s) : this.currentUrlTree === n.finalUrl && s === 0 && (this.resetState(n),
                this.resetUrlToCurrentUrlTree())
            } else
                this.canceledNavigationResolution === "replace" && (i && this.resetState(n),
                this.resetUrlToCurrentUrlTree())
        }
        resetState(n) {
            this.routerState = this.stateMemento.routerState,
            this.currentUrlTree = this.stateMemento.currentUrlTree,
            this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, n.finalUrl ?? this.rawUrlTree)
        }
        resetUrlToCurrentUrlTree() {
            this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId))
        }
        generateNgRouterState(n, i) {
            return this.canceledNavigationResolution === "computed" ? {
                navigationId: n,
                \u0275routerPageId: i
            } : {
                navigationId: n
            }
        }
        static \u0275fac = ( () => {
            let n;
            return function(r) {
                return (n || (n = On(e)))(r || e)
            }
        }
        )();
        static \u0275prov = re({
            token: e,
            factory: e.\u0275fac,
            providedIn: "root"
        })
    }
    return e
}
)();
function Nb(e, t) {
    e.events.pipe(mt(n => n instanceof Ro || n instanceof _a || n instanceof md || n instanceof Do), $e(n => n instanceof Ro || n instanceof Do ? 0 : (n instanceof _a ? n.code === ps.Redirect || n.code === ps.SupersededByNewNavigation : !1) ? 2 : 1), mt(n => n !== 2), Lt(1)).subscribe( () => {
        t()
    }
    )
}
var BD = {
    paths: "exact",
    fragment: "ignored",
    matrixParams: "ignored",
    queryParams: "exact"
}
  , UD = {
    paths: "subset",
    fragment: "ignored",
    matrixParams: "ignored",
    queryParams: "subset"
}
  , Ui = ( () => {
    class e {
        get currentUrlTree() {
            return this.stateManager.getCurrentUrlTree()
        }
        get rawUrlTree() {
            return this.stateManager.getRawUrlTree()
        }
        disposed = !1;
        nonRouterCurrentEntryChangeSubscription;
        console = z(s4);
        stateManager = z(Db);
        options = z(Pd, {
            optional: !0
        }) || {};
        pendingTasks = z(hv);
        urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred";
        navigationTransitions = z(fg);
        urlSerializer = z(Cd);
        location = z(Dh);
        urlHandlingStrategy = z(dg);
        _events = new lt;
        get events() {
            return this._events
        }
        get routerState() {
            return this.stateManager.getRouterState()
        }
        navigated = !1;
        routeReuseStrategy = z(ND);
        onSameUrlNavigation = this.options.onSameUrlNavigation || "ignore";
        config = z(xd, {
            optional: !0
        })?.flat() ?? [];
        componentInputBindingEnabled = !!z(Xf, {
            optional: !0
        });
        constructor() {
            this.resetConfig(this.config),
            this.navigationTransitions.setupNavigations(this, this.currentUrlTree, this.routerState).subscribe({
                error: n => {
                    this.console.warn(n)
                }
            }),
            this.subscribeToNavigationEvents()
        }
        eventsSubscription = new K8;
        subscribeToNavigationEvents() {
            let n = this.navigationTransitions.events.subscribe(i => {
                try {
                    let r = this.navigationTransitions.currentTransition
                      , s = this.navigationTransitions.currentNavigation;
                    if (r !== null && s !== null) {
                        if (this.stateManager.handleRouterEvent(i, s),
                        i instanceof _a && i.code !== ps.Redirect && i.code !== ps.SupersededByNewNavigation)
                            this.navigated = !0;
                        else if (i instanceof Ro)
                            this.navigated = !0;
                        else if (i instanceof cu) {
                            let o = i.navigationBehaviorOptions
                              , a = this.urlHandlingStrategy.merge(i.url, r.currentRawUrl)
                              , c = C({
                                browserUrl: r.extras.browserUrl,
                                info: r.extras.info,
                                skipLocationChange: r.extras.skipLocationChange,
                                replaceUrl: r.extras.replaceUrl || this.urlUpdateStrategy === "eager" || DD(r.source)
                            }, o);
                            this.scheduleNavigation(a, fd, null, c, {
                                resolve: r.resolve,
                                reject: r.reject,
                                promise: r.promise
                            })
                        }
                    }
                    GD(i) && this._events.next(i)
                } catch (r) {
                    this.navigationTransitions.transitionAbortSubject.next(r)
                }
            }
            );
            this.eventsSubscription.add(n)
        }
        resetRootComponentType(n) {
            this.routerState.root.component = n,
            this.navigationTransitions.rootComponentType = n
        }
        initialNavigation() {
            this.setUpLocationChangeListener(),
            this.navigationTransitions.hasRequestedNavigation || this.navigateToSyncWithBrowser(this.location.path(!0), fd, this.stateManager.restoredState())
        }
        setUpLocationChangeListener() {
            this.nonRouterCurrentEntryChangeSubscription ??= this.stateManager.registerNonRouterCurrentEntryChangeListener( (n, i) => {
                setTimeout( () => {
                    this.navigateToSyncWithBrowser(n, "popstate", i)
                }
                , 0)
            }
            )
        }
        navigateToSyncWithBrowser(n, i, r) {
            let s = {
                replaceUrl: !0
            }
              , o = r?.navigationId ? r : null;
            if (r) {
                let c = C({}, r);
                delete c.navigationId,
                delete c.\u0275routerPageId,
                Object.keys(c).length !== 0 && (s.state = c)
            }
            let a = this.parseUrl(n);
            this.scheduleNavigation(a, i, o, s)
        }
        get url() {
            return this.serializeUrl(this.currentUrlTree)
        }
        getCurrentNavigation() {
            return this.navigationTransitions.currentNavigation
        }
        get lastSuccessfulNavigation() {
            return this.navigationTransitions.lastSuccessfulNavigation
        }
        resetConfig(n) {
            this.config = n.map(ug),
            this.navigated = !1
        }
        ngOnDestroy() {
            this.dispose()
        }
        dispose() {
            this._events.unsubscribe(),
            this.navigationTransitions.complete(),
            this.nonRouterCurrentEntryChangeSubscription && (this.nonRouterCurrentEntryChangeSubscription.unsubscribe(),
            this.nonRouterCurrentEntryChangeSubscription = void 0),
            this.disposed = !0,
            this.eventsSubscription.unsubscribe()
        }
        createUrlTree(n, i={}) {
            let {relativeTo: r, queryParams: s, fragment: o, queryParamsHandling: a, preserveFragment: c} = i
              , l = c ? this.currentUrlTree.fragment : o
              , u = null;
            switch (a ?? this.options.defaultQueryParamsHandling) {
            case "merge":
                u = C(C({}, this.currentUrlTree.queryParams), s);
                break;
            case "preserve":
                u = this.currentUrlTree.queryParams;
                break;
            default:
                u = s || null
            }
            u !== null && (u = this.removeEmptyProps(u));
            let h;
            try {
                let d = r ? r.snapshot : this.routerState.snapshot.root;
                h = pb(d)
            } catch {
                (typeof n[0] != "string" || n[0][0] !== "/") && (n = []),
                h = this.currentUrlTree.root
            }
            return gb(h, n, u, l ?? null)
        }
        navigateByUrl(n, i={
            skipLocationChange: !1
        }) {
            let r = Tl(n) ? n : this.parseUrl(n)
              , s = this.urlHandlingStrategy.merge(r, this.rawUrlTree);
            return this.scheduleNavigation(s, fd, null, i)
        }
        navigate(n, i={
            skipLocationChange: !1
        }) {
            return HD(n),
            this.navigateByUrl(this.createUrlTree(n, i), i)
        }
        serializeUrl(n) {
            return this.urlSerializer.serialize(n)
        }
        parseUrl(n) {
            try {
                return this.urlSerializer.parse(n)
            } catch {
                return this.urlSerializer.parse("/")
            }
        }
        isActive(n, i) {
            let r;
            if (i === !0 ? r = C({}, BD) : i === !1 ? r = C({}, UD) : r = i,
            Tl(n))
                return Xy(this.currentUrlTree, n, r);
            let s = this.parseUrl(n);
            return Xy(this.currentUrlTree, s, r)
        }
        removeEmptyProps(n) {
            return Object.entries(n).reduce( (i, [r,s]) => (s != null && (i[r] = s),
            i), {})
        }
        scheduleNavigation(n, i, r, s, o) {
            if (this.disposed)
                return Promise.resolve(!1);
            let a, c, l;
            o ? (a = o.resolve,
            c = o.reject,
            l = o.promise) : l = new Promise( (h, d) => {
                a = h,
                c = d
            }
            );
            let u = this.pendingTasks.add();
            return Nb(this, () => {
                queueMicrotask( () => this.pendingTasks.remove(u))
            }
            ),
            this.navigationTransitions.handleNavigationRequest({
                source: i,
                restoredState: r,
                currentUrlTree: this.currentUrlTree,
                currentRawUrl: this.currentUrlTree,
                rawUrl: n,
                extras: s,
                resolve: a,
                reject: c,
                promise: l,
                currentSnapshot: this.routerState.snapshot,
                currentRouterState: this.routerState
            }),
            l.catch(h => Promise.reject(h))
        }
        static \u0275fac = function(i) {
            return new (i || e)
        }
        ;
        static \u0275prov = re({
            token: e,
            factory: e.\u0275fac,
            providedIn: "root"
        })
    }
    return e
}
)();
function HD(e) {
    for (let t = 0; t < e.length; t++)
        if (e[t] == null)
            throw new hi(4008,!1)
}
function GD(e) {
    return !(e instanceof vd) && !(e instanceof cu)
}
var Dse = ( () => {
    class e {
        router;
        route;
        tabIndexAttribute;
        renderer;
        el;
        locationStrategy;
        href = null;
        target;
        queryParams;
        fragment;
        queryParamsHandling;
        state;
        info;
        relativeTo;
        isAnchorElement;
        subscription;
        onChanges = new lt;
        constructor(n, i, r, s, o, a) {
            this.router = n,
            this.route = i,
            this.tabIndexAttribute = r,
            this.renderer = s,
            this.el = o,
            this.locationStrategy = a;
            let c = o.nativeElement.tagName?.toLowerCase();
            this.isAnchorElement = c === "a" || c === "area",
            this.isAnchorElement ? this.subscription = n.events.subscribe(l => {
                l instanceof Ro && this.updateHref()
            }
            ) : this.setTabIndexIfNotOnNativeEl("0")
        }
        preserveFragment = !1;
        skipLocationChange = !1;
        replaceUrl = !1;
        setTabIndexIfNotOnNativeEl(n) {
            this.tabIndexAttribute != null || this.isAnchorElement || this.applyAttributeValue("tabindex", n)
        }
        ngOnChanges(n) {
            this.isAnchorElement && this.updateHref(),
            this.onChanges.next(this)
        }
        routerLinkInput = null;
        set routerLink(n) {
            n == null ? (this.routerLinkInput = null,
            this.setTabIndexIfNotOnNativeEl(null)) : (Tl(n) ? this.routerLinkInput = n : this.routerLinkInput = Array.isArray(n) ? n : [n],
            this.setTabIndexIfNotOnNativeEl("0"))
        }
        onClick(n, i, r, s, o) {
            let a = this.urlTree;
            if (a === null || this.isAnchorElement && (n !== 0 || i || r || s || o || typeof this.target == "string" && this.target != "_self"))
                return !0;
            let c = {
                skipLocationChange: this.skipLocationChange,
                replaceUrl: this.replaceUrl,
                state: this.state,
                info: this.info
            };
            return this.router.navigateByUrl(a, c),
            !this.isAnchorElement
        }
        ngOnDestroy() {
            this.subscription?.unsubscribe()
        }
        updateHref() {
            let n = this.urlTree;
            this.href = n !== null && this.locationStrategy ? this.locationStrategy?.prepareExternalUrl(this.router.serializeUrl(n)) : null;
            let i = this.href === null ? null : gv(this.href, this.el.nativeElement.tagName.toLowerCase(), "href");
            this.applyAttributeValue("href", i)
        }
        applyAttributeValue(n, i) {
            let r = this.renderer
              , s = this.el.nativeElement;
            i !== null ? r.setAttribute(s, n, i) : r.removeAttribute(s, n)
        }
        get urlTree() {
            return this.routerLinkInput === null ? null : Tl(this.routerLinkInput) ? this.routerLinkInput : this.router.createUrlTree(this.routerLinkInput, {
                relativeTo: this.relativeTo !== void 0 ? this.relativeTo : this.route,
                queryParams: this.queryParams,
                fragment: this.fragment,
                queryParamsHandling: this.queryParamsHandling,
                preserveFragment: this.preserveFragment
            })
        }
        static \u0275fac = function(i) {
            return new (i || e)(Pt(Ui),Pt(No),Zp("tabindex"),Pt(_v),Pt(Os),Pt(Rh))
        }
        ;
        static \u0275dir = as({
            type: e,
            selectors: [["", "routerLink", ""]],
            hostVars: 1,
            hostBindings: function(i, r) {
                i & 1 && Qe("click", function(o) {
                    return r.onClick(o.button, o.ctrlKey, o.shiftKey, o.altKey, o.metaKey)
                }),
                i & 2 && U0("target", r.target)
            },
            inputs: {
                target: "target",
                queryParams: "queryParams",
                fragment: "fragment",
                queryParamsHandling: "queryParamsHandling",
                state: "state",
                info: "info",
                relativeTo: "relativeTo",
                preserveFragment: [2, "preserveFragment", "preserveFragment", P5],
                skipLocationChange: [2, "skipLocationChange", "skipLocationChange", P5],
                replaceUrl: [2, "replaceUrl", "replaceUrl", P5],
                routerLink: "routerLink"
            },
            features: [bv, qs]
        })
    }
    return e
}
)();
var zf = class {
}
;
var VD = ( () => {
    class e {
        router;
        injector;
        preloadingStrategy;
        loader;
        subscription;
        constructor(n, i, r, s, o) {
            this.router = n,
            this.injector = r,
            this.preloadingStrategy = s,
            this.loader = o
        }
        setUpPreloading() {
            this.subscription = this.router.events.pipe(mt(n => n instanceof Ro), ui( () => this.preload())).subscribe( () => {}
            )
        }
        preload() {
            return this.processRoutes(this.injector, this.router.config)
        }
        ngOnDestroy() {
            this.subscription && this.subscription.unsubscribe()
        }
        processRoutes(n, i) {
            let r = [];
            for (let s of i) {
                s.providers && !s._injector && (s._injector = r4(s.providers, n, `Route: ${s.path}`));
                let o = s._injector ?? n
                  , a = s._loadedInjector ?? o;
                (s.loadChildren && !s._loadedRoutes && s.canLoad === void 0 || s.loadComponent && !s._loadedComponent) && r.push(this.preloadConfig(o, s)),
                (s.children || s._loadedRoutes) && r.push(this.processRoutes(a, s.children ?? s._loadedRoutes))
            }
            return Qn(r).pipe(qp())
        }
        preloadConfig(n, i) {
            return this.preloadingStrategy.preload(i, () => {
                let r;
                i.loadChildren && i.canLoad === void 0 ? r = this.loader.loadChildren(n, i) : r = Be(null);
                let s = r.pipe(ci(o => o === null ? Be(void 0) : (i._loadedRoutes = o.routes,
                i._loadedInjector = o.injector,
                this.processRoutes(o.injector ?? n, o.routes))));
                if (i.loadComponent && !i._loadedComponent) {
                    let o = this.loader.loadComponent(i);
                    return Qn([s, o]).pipe(qp())
                } else
                    return s
            }
            )
        }
        static \u0275fac = function(i) {
            return new (i || e)(xe(Ui),xe(O5),xe(rc),xe(zf),xe(hg))
        }
        ;
        static \u0275prov = re({
            token: e,
            factory: e.\u0275fac,
            providedIn: "root"
        })
    }
    return e
}
)()
  , Fb = new Ze("")
  , WD = ( () => {
    class e {
        urlSerializer;
        transitions;
        viewportScroller;
        zone;
        options;
        routerEventsSubscription;
        scrollEventsSubscription;
        lastId = 0;
        lastSource = "imperative";
        restoredId = 0;
        store = {};
        constructor(n, i, r, s, o={}) {
            this.urlSerializer = n,
            this.transitions = i,
            this.viewportScroller = r,
            this.zone = s,
            this.options = o,
            o.scrollPositionRestoration ||= "disabled",
            o.anchorScrolling ||= "disabled"
        }
        init() {
            this.options.scrollPositionRestoration !== "disabled" && this.viewportScroller.setHistoryScrollRestoration("manual"),
            this.routerEventsSubscription = this.createScrollEvents(),
            this.scrollEventsSubscription = this.consumeScrollEvents()
        }
        createScrollEvents() {
            return this.transitions.events.subscribe(n => {
                n instanceof yc ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(),
                this.lastSource = n.navigationTrigger,
                this.restoredId = n.restoredState ? n.restoredState.navigationId : 0) : n instanceof Ro ? (this.lastId = n.id,
                this.scheduleScrollEvent(n, this.urlSerializer.parse(n.urlAfterRedirects).fragment)) : n instanceof Do && n.code === Bf.IgnoredSameUrlNavigation && (this.lastSource = void 0,
                this.restoredId = 0,
                this.scheduleScrollEvent(n, this.urlSerializer.parse(n.url).fragment))
            }
            )
        }
        consumeScrollEvents() {
            return this.transitions.events.subscribe(n => {
                n instanceof Hf && (n.position ? this.options.scrollPositionRestoration === "top" ? this.viewportScroller.scrollToPosition([0, 0]) : this.options.scrollPositionRestoration === "enabled" && this.viewportScroller.scrollToPosition(n.position) : n.anchor && this.options.anchorScrolling === "enabled" ? this.viewportScroller.scrollToAnchor(n.anchor) : this.options.scrollPositionRestoration !== "disabled" && this.viewportScroller.scrollToPosition([0, 0]))
            }
            )
        }
        scheduleScrollEvent(n, i) {
            this.zone.runOutsideAngular( () => {
                setTimeout( () => {
                    this.zone.run( () => {
                        this.transitions.events.next(new Hf(n,this.lastSource === "popstate" ? this.store[this.restoredId] : null,i))
                    }
                    )
                }
                , 0)
            }
            )
        }
        ngOnDestroy() {
            this.routerEventsSubscription?.unsubscribe(),
            this.scrollEventsSubscription?.unsubscribe()
        }
        static \u0275fac = function(i) {
            mv()
        }
        ;
        static \u0275prov = re({
            token: e,
            factory: e.\u0275fac
        })
    }
    return e
}
)();
function Nse(e, ...t) {
    return B0([{
        provide: xd,
        multi: !0,
        useValue: e
    }, [], {
        provide: No,
        useFactory: Lb,
        deps: [Ui]
    }, {
        provide: a4,
        multi: !0,
        useFactory: Bb
    }, t.map(n => n.\u0275providers)])
}
function Lb(e) {
    return e.routerState.root
}
function Md(e, t) {
    return {
        \u0275kind: e,
        \u0275providers: t
    }
}
function Bb() {
    let e = z(an);
    return t => {
        let n = e.get(ua);
        if (t !== n.components[0])
            return;
        let i = e.get(Ui)
          , r = e.get(Ub);
        e.get(pg) === 1 && i.initialNavigation(),
        e.get(Hb, null, Qp.Optional)?.setUpPreloading(),
        e.get(Fb, null, Qp.Optional)?.init(),
        i.resetRootComponentType(n.componentTypes[0]),
        r.closed || (r.next(),
        r.complete(),
        r.unsubscribe())
    }
}
var Ub = new Ze("",{
    factory: () => new lt
})
  , pg = new Ze("",{
    providedIn: "root",
    factory: () => 1
});
function $D() {
    return Md(2, [{
        provide: pg,
        useValue: 0
    }, {
        provide: kh,
        multi: !0,
        deps: [an],
        useFactory: t => {
            let n = t.get(Iv, Promise.resolve());
            return () => n.then( () => new Promise(i => {
                let r = t.get(Ui)
                  , s = t.get(Ub);
                Nb(r, () => {
                    i(!0)
                }
                ),
                t.get(fg).afterPreactivation = () => (i(!0),
                s.closed ? Be(void 0) : s),
                r.initialNavigation()
            }
            ))
        }
    }])
}
function jD() {
    return Md(3, [{
        provide: kh,
        multi: !0,
        useFactory: () => {
            let t = z(Ui);
            return () => {
                t.setUpLocationChangeListener()
            }
        }
    }, {
        provide: pg,
        useValue: 2
    }])
}
var Hb = new Ze("");
function qD(e) {
    return Md(0, [{
        provide: Hb,
        useExisting: VD
    }, {
        provide: zf,
        useExisting: e
    }])
}
function zD() {
    return Md(8, [Jy, {
        provide: Xf,
        useExisting: Jy
    }])
}
function XD(e) {
    let t = [{
        provide: Ab,
        useValue: ID
    }, {
        provide: Ib,
        useValue: C({
            skipNextTransition: !!e?.skipInitialTransition
        }, e)
    }];
    return Md(9, t)
}
var nb = new Ze("ROUTER_FORROOT_GUARD")
  , KD = [Dh, {
    provide: Cd,
    useClass: au
}, Ui, Td, {
    provide: No,
    useFactory: Lb,
    deps: [Ui]
}, hg, []]
  , Fse = ( () => {
    class e {
        constructor(n) {}
        static forRoot(n, i) {
            return {
                ngModule: e,
                providers: [KD, [], {
                    provide: xd,
                    multi: !0,
                    useValue: n
                }, {
                    provide: nb,
                    useFactory: ZD,
                    deps: [[Ui, new v5, new lv]]
                }, i?.errorHandler ? {
                    provide: Rb,
                    useValue: i.errorHandler
                } : [], {
                    provide: Pd,
                    useValue: i || {}
                }, i?.useHash ? QD() : JD(), YD(), i?.preloadingStrategy ? qD(i.preloadingStrategy).\u0275providers : [], i?.initialNavigation ? eN(i) : [], i?.bindToComponentInputs ? zD().\u0275providers : [], i?.enableViewTransitions ? XD().\u0275providers : [], tN()]
            }
        }
        static forChild(n) {
            return {
                ngModule: e,
                providers: [{
                    provide: xd,
                    multi: !0,
                    useValue: n
                }]
            }
        }
        static \u0275fac = function(i) {
            return new (i || e)(xe(nb, 8))
        }
        ;
        static \u0275mod = ir({
            type: e
        });
        static \u0275inj = nr({})
    }
    return e
}
)();
function YD() {
    return {
        provide: Fb,
        useFactory: () => {
            let e = z(Gv)
              , t = z(Rn)
              , n = z(Pd)
              , i = z(fg)
              , r = z(Cd);
            return n.scrollOffset && e.setOffset(n.scrollOffset),
            new WD(r,i,e,t,n)
        }
    }
}
function QD() {
    return {
        provide: Rh,
        useClass: Dv
    }
}
function JD() {
    return {
        provide: Rh,
        useClass: Rv
    }
}
function ZD(e) {
    return "guarded"
}
function eN(e) {
    return [e.initialNavigation === "disabled" ? jD().\u0275providers : [], e.initialNavigation === "enabledBlocking" ? $D().\u0275providers : []]
}
var ib = new Ze("");
function tN() {
    return [{
        provide: ib,
        useFactory: Bb
    }, {
        provide: a4,
        multi: !0,
        useExisting: ib
    }]
}
var nN = typeof __SENTRY_DEBUG__ > "u" ? !0 : __SENTRY_DEBUG__;
function Kse(e) {
    let t = Object.assign({
        defaultIntegrations: Of(e).filter(n => n.name !== "TryCatch")
    }, e);
    nd(t, "angular-ivy"),
    iN(),
    x6(t)
}
function iN() {
    let t = T5 && T5.major ? parseInt(T5.major, 10) : void 0;
    t && (t < 12 && nN && We.warn(`This Sentry SDK does not officially support Angular ${t}.`, "This SDK only supports Angular 12 and above.", "If you're using Angular 10 or 11, please use `@sentry/angular` instead.", "Otherwise, please consider upgrading your Angular version."),
    gf("angular", {
        version: t
    }))
}
var Yse = typeof Zone < "u" && !!Zone.current;
var pi = function(e) {
    return e[e.None = 0] = "None",
    e[e.Note = 1] = "Note",
    e[e.Agreement = 2] = "Agreement",
    e[e.Settings = 3] = "Settings",
    e[e.MarketView = 4] = "MarketView",
    e[e.MoneyReceipt = 5] = "MoneyReceipt",
    e[e.Payment = 6] = "Payment",
    e[e.Conditional = 7] = "Conditional",
    e[e.Menu = 8] = "Menu",
    e[e.BrokerChange = 9] = "BrokerChange",
    e[e.Feedback = 10] = "Feedback",
    e[e.AboutUs = 11] = "AboutUs",
    e[e.Messages = 12] = "Messages",
    e[e.layoutList = 13] = "layoutList",
    e[e.AccountActivity = 14] = "AccountActivity",
    e[e.WalletCard = 15] = "WalletCard",
    e[e.Funds = 16] = "Funds",
    e[e.ChangeHistory = 17] = "ChangeHistory",
    e[e.Search = 18] = "Search",
    e[e.Children = 19] = "Children",
    e[e.EasyChart = 20] = "EasyChart",
    e[e.Option = 21] = "Option",
    e[e.AiMarketAssistant = 22] = "AiMarketAssistant",
    e
}(pi || {})
  , Jse = {
    settings: pi.Settings,
    "wallet-card": pi.WalletCard,
    funds: pi.Funds,
    messages: pi.Messages,
    menu: pi.Menu,
    conditional: pi.Conditional,
    agreement: pi.Agreement,
    marketView: pi.MarketView,
    aiMarketAssistant: pi.AiMarketAssistant
};
var Vb = function(e) {
    return e.EASY_FILTER_ROUTE = "easy-filter",
    e.RECEIPT_ROUTE = "receipt",
    e.RECEIPT_ROUTE_ERROR = "receipt/error",
    e.NOTES_ROUTE = "notes",
    e.MARKET_WATCH_ROUTE = "market-watch",
    e
}(Vb || {})
  , gg = function(e) {
    return e.ORDERS_ROUTE = "orders",
    e.PORTFOLIO_ROUTE = "portfolio-fill",
    e.PORTFOLIO_SOLD_ITEMS = "portfolio-sold-items",
    e.MARKET_WATCH_ROUTE = "market-watch",
    e.AI_MARKET_ASSISTANT = "ai-market-assistant",
    e.SEARCH_ROUTE = "search",
    e.MENU_ROUTE = "menu",
    e.RECEIPT_ROUTE = "money-receipt",
    e.RECEIPT_ROUTE_ERROR = "money-receipt/error",
    e.SETTING_ROUTE = "setting",
    e.NOTES_ROUTE = "note-management",
    e.STOCK_DETAILS_MESSAGES_ROUTE = "messages",
    e.CHANGE_HISTORY = "release-notes",
    e.POSITION = "position",
    e.POSITION_HISTORY = "position-history",
    e.CHAIN = "chain",
    e.MARKET_VIEW = "market-view",
    e.MAP = "map",
    e
}(gg || {})
  , ei = function(e) {
    return e.MAIN_ROUTE = "",
    e.BANK_ACCOUNT_ROUTE = "payment/bank-account",
    e.MARKET_MAP_ROUTE = "market-map",
    e.STOCK_DETAILS_ROUTE = "stock-details",
    e.STOCK_DETAILS_CONDITION_ROUTE = "condition",
    e.ORDER_HISTORY_ROUTE = "orders-history",
    e.OPTION_ROUTE = "option",
    e.ALGO_HISTORY_ROUTE = "algo-orders-history",
    e.EASY_CHART_ROUTE = "easy-chart",
    e.PAYMENT_ROUTE = "payment",
    e.CONDITION_ROUTE = "conditional",
    e.TRANSACTIONS_ROUTE = "transactions",
    e.ACCOUNT_ACTIVITY_ROUTE = "account-activity",
    e.MENU_ROUTE = "menu",
    e.MESSAGES_ROUTE = "messages",
    e.IMMEDIATE_MESSAGE_ROUTE = "immediate-messages",
    e.PORTFOLIO_MESSAGE_ROUTE = "portfolio-messages",
    e.MOFID_MESSAGE_ROUTE = "mofid-messages",
    e.WALLET_CARD_ROUTE = "wallet-card",
    e.AGREEMENT_ROUTE = "agreement",
    e.FUND_ROUTE = "funds",
    e.SUPPORT_ROUTE = "support",
    e.SETTING = "setting",
    e.BROKER_CHANGE_ROUTE = "broker-change",
    e.MARKET_VIEW_ROUTE = "market-view",
    e.CHILDREN_ROUTE = "children",
    e.OFFLINE_ORDER = "offline-order",
    e.LOGIN = "login",
    e
}(ei || {})
  , toe = [ei.ORDER_HISTORY_ROUTE, ei.ALGO_HISTORY_ROUTE, ei.OPTION_ROUTE, ei.TRANSACTIONS_ROUTE, Vb.EASY_FILTER_ROUTE, ei.MARKET_MAP_ROUTE]
  , sN = function(e) {
    return e.TRANSACTIONS_ROUTE = "\u062A\u0627\u0631\u06CC\u062E\u0686\u0647 \u062A\u0631\u0627\u06A9\u0646\u0634",
    e.ORDER_HISTORY_ROUTE = "\u062A\u0627\u0631\u06CC\u062E\u0686\u0647 \u0633\u0641\u0627\u0631\u0634\u0627\u062A",
    e.EASY_FILTER_ROUTE = "\u0627\u06CC\u0632\u06CC \u0641\u06CC\u0644\u062A\u0631",
    e.EASY_CHART_ROUTE = "\u0686\u0627\u0631\u062A",
    e.MARKET_MAP_ROUTE = "\u0646\u0642\u0634\u0647 \u0628\u0627\u0632\u0627\u0631",
    e
}(sN || {})
  , kd = function(e) {
    return e[e.Broker = 1] = "Broker",
    e[e.Immediate = 2] = "Immediate",
    e[e.Portfolio = 3] = "Portfolio",
    e[e.Mofid = 4] = "Mofid",
    e
}(kd || {});
function Wb(e, t) {
    switch (e) {
    case ei.IMMEDIATE_MESSAGE_ROUTE:
        return {
            sidePanel: pi.Messages,
            data: {
                selectedTab: kd.Immediate
            }
        };
    case ei.PORTFOLIO_MESSAGE_ROUTE:
        return {
            sidePanel: pi.Messages,
            data: {
                selectedTab: kd.Portfolio
            }
        };
    case ei.MOFID_MESSAGE_ROUTE:
        return {
            sidePanel: pi.Messages,
            data: {
                selectedTab: kd.Mofid
            }
        };
    case ei.MESSAGES_ROUTE:
        return {
            sidePanel: pi.Messages,
            data: {
                selectedTab: kd.Broker
            }
        };
    case ei.AGREEMENT_ROUTE:
        return {
            sidePanel: pi.Agreement
        };
    case ei.ACCOUNT_ACTIVITY_ROUTE:
        return {
            sidePanel: pi.AccountActivity
        };
    case ei.CONDITION_ROUTE:
        return {
            sidePanel: pi.Conditional,
            value: t
        };
    case ei.EASY_CHART_ROUTE:
        return {
            sidePanel: pi.EasyChart
        };
    default:
    }
}
var y = function(e) {
    return e[e.None = 0] = "None",
    e[e.Exchange = 1] = "Exchange",
    e[e.Rights = 2] = "Rights",
    e[e.ETFStock = 3] = "ETFStock",
    e[e.ETFFix = 4] = "ETFFix",
    e[e.ETFMixed = 5] = "ETFMixed",
    e[e.ETFZaminSakhteman = 6] = "ETFZaminSakhteman",
    e[e.ETFJasuraneh = 7] = "ETFJasuraneh",
    e[e.SandoghKala = 8] = "SandoghKala",
    e[e.NapeyvastehSiman = 9] = "NapeyvastehSiman",
    e[e.GovahiBourseKala = 10] = "GovahiBourseKala",
    e[e.Sekkeh = 11] = "Sekkeh",
    e[e.Maskan1 = 12] = "Maskan1",
    e[e.Tabaee = 13] = "Tabaee",
    e[e.Ekhtiar = 14] = "Ekhtiar",
    e[e.AtiSaham = 15] = "AtiSaham",
    e[e.AtiSabad = 16] = "AtiSabad",
    e[e.Fekri = 17] = "Fekri",
    e[e.PayehYellow = 18] = "PayehYellow",
    e[e.PayehOrange = 19] = "PayehOrange",
    e[e.PayehRed = 20] = "PayehRed",
    e[e.Koochak = 21] = "Koochak",
    e[e.Salaf = 22] = "Salaf",
    e[e.Bond1 = 23] = "Bond1",
    e[e.Bond2 = 24] = "Bond2",
    e[e.Bond3 = 25] = "Bond3",
    e[e.Bond4 = 26] = "Bond4",
    e[e.Bond5 = 27] = "Bond5",
    e[e.Bond6 = 28] = "Bond6",
    e[e.INDEX = 29] = "INDEX",
    e[e.bond7 = 30] = "bond7",
    e[e.EtfInEtf = 31] = "EtfInEtf",
    e[e.EtfAmlak = 32] = "EtfAmlak",
    e[e.NapeyvastehZaferan = 33] = "NapeyvastehZaferan",
    e[e.NapeyvastehSekkeh = 34] = "NapeyvastehSekkeh",
    e[e.NapeyvastehShisheh = 35] = "NapeyvastehShisheh",
    e[e.NapeyvastehMes = 36] = "NapeyvastehMes",
    e[e.NapeyvastehSangAhan = 37] = "NapeyvastehSangAhan",
    e[e.NapeyvastehMilgerd = 38] = "NapeyvastehMilgerd",
    e[e.ETFKhosusi = 39] = "ETFKhosusi",
    e[e.RightYellow = 40] = "RightYellow",
    e[e.RightOrange = 41] = "RightOrange",
    e[e.RightRed = 42] = "RightRed",
    e[e.EtfSector = 43] = "EtfSector",
    e[e.RightsKoochak = 44] = "RightsKoochak",
    e[e.BuyOptionTse = 45] = "BuyOptionTse",
    e[e.BuyOptionIfb = 46] = "BuyOptionIfb",
    e[e.SellOptionTse = 47] = "SellOptionTse",
    e[e.SellOptionIfb = 48] = "SellOptionIfb",
    e[e.Maskan2 = 50] = "Maskan2",
    e[e.ProMarket = 51] = "ProMarket",
    e[e.EnergyETF = 52] = "EnergyETF",
    e[e.AgreedMarket = 53] = "AgreedMarket",
    e
}(y || {});
var Ad = function(e) {
    return e.FirstStep = "FirstStep",
    e.SecondStep = "SecondStep",
    e.PaidInCapitalSurplus = "PaidInCapitalSurplus",
    e
}(Ad || {});
var ba = class ba {
}
;
ba.EtfMarketUnits = [y.ETFStock, y.ETFFix, y.ETFMixed, y.ETFZaminSakhteman, y.ETFJasuraneh, y.ETFKhosusi, y.EtfInEtf, y.EtfAmlak],
ba.BazarPayehMarketUnits = [y.PayehYellow, y.PayehOrange, y.PayehRed, y.RightYellow, y.RightOrange, y.RightRed],
ba.symbolFlow = {
    0: "\u0639\u0645\u0648\u0645\u06CC",
    1: "\u0628\u0648\u0631\u0633",
    2: "\u0641\u0631\u0627\u0628\u0648\u0631\u0633",
    3: "\u0622\u062A\u06CC - \u0627\u062E\u062A\u06CC\u0627\u0631",
    4: "\u067E\u0627\u06CC\u0647 \u0641\u0631\u0627\u0628\u0648\u0631\u0633",
    5: "\u06AF\u0648\u0627\u0647\u06CC \u0635\u0627\u062F\u0631\u0627\u062A\u06CC",
    6: "\u0628\u0648\u0631\u0633 \u0627\u0646\u0631\u0698\u06CC",
    7: "\u0628\u0648\u0631\u0633 \u06A9\u0627\u0644\u0627"
},
ba.PriorityTypeToText = {
    [Ad.FirstStep]: "\u0645\u0631\u062D\u0644\u0647 \u0627\u0648\u0644",
    [Ad.SecondStep]: "\u067E\u0630\u06CC\u0631\u0647 \u0646\u0648\u06CC\u0633\u06CC",
    [Ad.PaidInCapitalSurplus]: "\u0633\u0644\u0628 \u062D\u0642 \u062A\u0642\u062F\u0645"
},
ba.symbolMarketUnit = {
    0: "\u0633\u0627\u06CC\u0631",
    1: "\u0633\u0647\u0627\u0645",
    2: "\u062D\u0642 \u062A\u0642\u062F\u0645 \u0633\u0647\u0627\u0645",
    3: "\u0635\u0646\u062F\u0648\u0642 \u0633\u0647\u0627\u0645",
    4: "\u0635\u0646\u062F\u0648\u0642 \u062B\u0627\u0628\u062A",
    5: "\u0635\u0646\u062F\u0648\u0642 \u0645\u062E\u062A\u0644\u0637",
    6: "\u0635\u0646\u062F\u0648\u0642 \u0632\u0645\u06CC\u0646 \u0648 \u0633\u0627\u062E\u062A\u0645\u0627\u0646",
    7: "\u0635\u0646\u062F\u0648\u0642 \u062C\u0633\u0648\u0631\u0627\u0646\u0647",
    8: "\u0635\u0646\u062F\u0648\u0642 \u0628\u0648\u0631\u0633 \u06A9\u0627\u0644\u0627",
    9: "\u06AF\u0648\u0627\u0647\u06CC \u0633\u06CC\u0645\u0627\u0646",
    10: "\u06AF\u0648\u0627\u0647\u06CC \u0633\u067E\u0631\u062F\u0647 \u06A9\u0627\u0644\u0627\u06CC\u06CC",
    11: "\u06AF\u0648\u0627\u0647\u06CC \u0633\u06A9\u0647",
    12: "\u0627\u0648\u0631\u0627\u0642 \u0645\u0633\u06A9\u0646",
    13: "\u0627\u0648\u0631\u0627\u0642 \u062A\u0628\u0639\u06CC",
    14: "\u0627\u062E\u062A\u06CC\u0627\u0631 (\u062E\u0631\u06CC\u062F \u0648 \u0641\u0631\u0648\u0634)",
    15: "\u0622\u062A\u06CC \u0633\u0647\u0645",
    16: "\u0633\u0628\u062F \u0622\u062A\u06CC",
    17: "\u062F\u0627\u0631\u0627\u06CC\u06CC \u0641\u06A9\u0631\u06CC",
    18: "\u0628\u0627\u0632\u0627\u0631 \u067E\u0627\u06CC\u0647 \u0632\u0631\u062F",
    19: "\u0628\u0627\u0632\u0627\u0631 \u067E\u0627\u06CC\u0647 \u0646\u0627\u0631\u0646\u062C\u06CC",
    20: "\u0628\u0627\u0632\u0627\u0631 \u067E\u0627\u06CC\u0647 \u0642\u0631\u0645\u0632",
    21: "\u0634\u0631\u06A9\u062A\u0647\u0627\u06CC \u06A9\u0648\u0686\u06A9 \u0648 \u0645\u062A\u0648\u0633\u0637",
    22: "\u0633\u0644\u0641",
    23: "\u0627\u0648\u0631\u0627\u0642 \u0645\u0634\u0627\u0631\u06A9\u062A",
    24: "\u0627\u0648\u0631\u0627\u0642 \u0635\u06A9\u0648\u06A9(\u0627\u062C\u0627\u0631\u0647/\u0645\u0631\u0627\u0628\u062D\u0647/\u062F\u06CC\u0646)",
    25: "\u0627\u0648\u0631\u0627\u0642 \u0627\u0631\u0632 \u0635\u0627\u062F\u0631\u0627\u062A\u06CC",
    26: "\u0627\u0633\u0646\u0627\u062F \u062E\u0632\u0627\u0646\u0647",
    27: "\u0627\u0648\u0631\u0627\u0642 (\u0645\u0634\u0627\u0631\u06A9\u062A/ \u0627\u062C\u0627\u0631\u0647/ \u0645\u0631\u0627\u0628\u062D\u0647)",
    28: "\u0645\u0638\u0646\u0647 \u06CC\u0627\u0628\u06CC",
    29: "\u0634\u0627\u062E\u0635",
    30: "\u06AF\u0627\u0645",
    31: "\u0635\u0646\u062F\u0648\u0642 \u062F\u0631 \u0635\u0646\u062F\u0648\u0642",
    32: "\u0635\u0646\u062F\u0648\u0642 \u0627\u0645\u0644\u0627\u06A9",
    33: "\u06AF\u0648\u0627\u0647\u06CC \u0632\u0639\u0641\u0631\u0627\u0646",
    34: "\u06AF\u0648\u0627\u0647\u06CC \u0633\u06A9\u0647",
    35: "\u06AF\u0648\u0627\u0647\u06CC \u0634\u06CC\u0634\u0647",
    36: "\u06AF\u0648\u0627\u0647\u06CC \u0645\u0633",
    37: "\u06AF\u0648\u0627\u0647\u06CC \u0633\u0646\u06AF \u0622\u0647\u0646",
    38: "\u06AF\u0648\u0627\u0647\u06CC \u0645\u06CC\u0644\u06AF\u0631\u062F",
    39: "\u0635\u0646\u062F\u0648\u0642 \u062E\u0635\u0648\u0635\u06CC",
    40: "\u062D\u0642 \u062A\u0642\u062F\u0645 \u067E\u0627\u06CC\u0647 \u0632\u0631\u062F",
    41: "\u062D\u0642 \u062A\u0642\u062F\u0645 \u0628\u0627\u0632\u0627\u0631 \u067E\u0627\u06CC\u0647 \u0646\u0627\u0631\u0646\u062C\u06CC",
    42: "\u062D\u0642 \u062A\u0642\u062F\u0645 \u0628\u0627\u0632\u0627\u0631 \u067E\u0627\u06CC\u0647 \u0642\u0631\u0645\u0632",
    45: "\u0627\u062E\u062A\u06CC\u0627\u0631 \u062E\u0631\u06CC\u062F",
    46: "\u0627\u062E\u062A\u06CC\u0627\u0631 \u062E\u0631\u06CC\u062F",
    47: "\u0627\u062E\u062A\u06CC\u0627\u0631 \u0641\u0631\u0648\u0634",
    48: "\u0627\u062E\u062A\u06CC\u0627\u0631 \u0641\u0631\u0648\u0634",
    50: "\u0627\u0648\u0631\u0627\u0642 \u0645\u0633\u06A9\u0646",
    51: "\u0633\u0631\u0645\u0627\u06CC\u0647\u200C\u06AF\u0630\u0627\u0631\u06CC \u062D\u0631\u0641\u0647\u200C\u0627\u06CC",
    52: "\u0635\u0646\u062F\u0648\u0642 \u0628\u0648\u0631\u0633 \u0627\u0646\u0631\u0698\u06CC",
    53: "\u0628\u0627\u0632\u0627\u0631 \u062A\u0648\u0627\u0641\u0642\u06CC"
},
ba.validSymbolMarketUnitsForMarketMap = {
    1: "\u0633\u0647\u0627\u0645",
    2: "\u062D\u0642 \u062A\u0642\u062F\u0645 \u0633\u0647\u0627\u0645",
    3: "\u0635\u0646\u062F\u0648\u0642 \u0633\u0647\u0627\u0645",
    4: "\u0635\u0646\u062F\u0648\u0642 \u062B\u0627\u0628\u062A",
    5: "\u0635\u0646\u062F\u0648\u0642 \u0645\u062E\u062A\u0644\u0637",
    6: "\u0635\u0646\u062F\u0648\u0642 \u0632\u0645\u06CC\u0646 \u0648 \u0633\u0627\u062E\u062A\u0645\u0627\u0646",
    7: "\u0635\u0646\u062F\u0648\u0642 \u062C\u0633\u0648\u0631\u0627\u0646\u0647",
    8: "\u0635\u0646\u062F\u0648\u0642 \u0628\u0648\u0631\u0633 \u06A9\u0627\u0644\u0627",
    10: "\u06AF\u0648\u0627\u0647\u06CC \u0633\u067E\u0631\u062F\u0647 \u06A9\u0627\u0644\u0627\u06CC\u06CC",
    18: "\u0628\u0627\u0632\u0627\u0631 \u067E\u0627\u06CC\u0647 \u0632\u0631\u062F",
    19: "\u0628\u0627\u0632\u0627\u0631 \u067E\u0627\u06CC\u0647 \u0646\u0627\u0631\u0646\u062C\u06CC",
    20: "\u0628\u0627\u0632\u0627\u0631 \u067E\u0627\u06CC\u0647 \u0642\u0631\u0645\u0632",
    33: "\u06AF\u0648\u0627\u0647\u06CC \u0632\u0639\u0641\u0631\u0627\u0646",
    34: "\u06AF\u0648\u0627\u0647\u06CC \u0633\u06A9\u0647",
    40: "\u062D\u0642 \u062A\u0642\u062F\u0645 \u067E\u0627\u06CC\u0647 \u0632\u0631\u062F",
    41: "\u062D\u0642 \u062A\u0642\u062F\u0645 \u0628\u0627\u0632\u0627\u0631 \u067E\u0627\u06CC\u0647 \u0646\u0627\u0631\u0646\u062C\u06CC",
    42: "\u062D\u0642 \u062A\u0642\u062F\u0645 \u0628\u0627\u0632\u0627\u0631 \u067E\u0627\u06CC\u0647 \u0642\u0631\u0645\u0632"
},
ba.validOptionSymbolMarketUnitsForMarketMap = {
    45: "\u062D\u0642 \u062A\u0642\u062F\u0645 \u0628\u0627\u0632\u0627\u0631 \u067E\u0627\u06CC\u0647 \u0646\u0627\u0631\u0646\u062C\u06CC",
    46: "\u062D\u0642 \u062A\u0642\u062F\u0645 \u0628\u0627\u0632\u0627\u0631 \u067E\u0627\u06CC\u0647 \u0642\u0631\u0645\u0632",
    47: "\u062D\u0642 \u062A\u0642\u062F\u0645 \u0628\u0627\u0632\u0627\u0631 \u067E\u0627\u06CC\u0647 \u0642\u0631\u0645\u0632",
    48: "\u062D\u0642 \u062A\u0642\u062F\u0645 \u0628\u0627\u0632\u0627\u0631 \u067E\u0627\u06CC\u0647 \u0642\u0631\u0645\u0632"
};
var $b = ba;
var Rt = function(e) {
    return e[e.NotConnected = 0] = "NotConnected",
    e[e.Connecting = 1] = "Connecting",
    e[e.Connected = 2] = "Connected",
    e[e.Disconnected = 3] = "Disconnected",
    e[e.Unknown = 4] = "Unknown",
    e
}(Rt || {});
var Sa = function(e) {
    return e[e.Field = 0] = "Field",
    e[e.Full = 1] = "Full",
    e
}(Sa || {})
  , Ol = function(e) {
    return e.Raw = "RAW",
    e.Merge = "MERGE",
    e
}(Ol || {})
  , xa = function(e) {
    return e.Yes = "yes",
    e.No = "no",
    e
}(xa || {})
  , K = function(e) {
    return e[e.BestLimit = 1] = "BestLimit",
    e[e.Symbol = 2] = "Symbol",
    e[e.MarketWatch = 3] = "MarketWatch",
    e[e.SymbolHeader = 4] = "SymbolHeader",
    e[e.MarketDepthSymbol = 5] = "MarketDepthSymbol",
    e[e.OrderFormAskOrBid = 6] = "OrderFormAskOrBid",
    e[e.StockInfo = 7] = "StockInfo",
    e[e.OrderForm = 8] = "OrderForm",
    e[e.EasyFilter = 9] = "EasyFilter",
    e[e.Search = 10] = "Search",
    e[e.RecentSearch = 11] = "RecentSearch",
    e[e.Portfolio = 12] = "Portfolio",
    e[e.RealtimePortfolio = 13] = "RealtimePortfolio",
    e[e.Conditional = 14] = "Conditional",
    e[e.MarketAffecting = 15] = "MarketAffecting",
    e[e.BestOfMarket = 16] = "BestOfMarket",
    e[e.ReturnChart = 17] = "ReturnChart",
    e[e.DPortfolio = 18] = "DPortfolio",
    e[e.DRealtimePortfolio = 19] = "DRealtimePortfolio",
    e[e.TradeVolume = 20] = "TradeVolume",
    e[e.EasyFilterIndInst = 21] = "EasyFilterIndInst",
    e[e.GroupStateChange = 22] = "GroupStateChange",
    e[e.TextMessage = 23] = "TextMessage",
    e[e.Money = 24] = "Money",
    e[e.Order = 25] = "Order",
    e[e.OrderPlace = 26] = "OrderPlace",
    e[e.Index = 27] = "Index",
    e[e.MarketSheet = 28] = "MarketSheet",
    e[e.MarketSheetChartBuy = 29] = "MarketSheetChartBuy",
    e[e.MarketSheetChartSell = 30] = "MarketSheetChartSell",
    e[e.TodayActivity = 31] = "TodayActivity",
    e[e.ActiveStock = 32] = "ActiveStock",
    e[e.MarketViewTopRank = 33] = "MarketViewTopRank",
    e[e.SameGroup = 34] = "SameGroup",
    e[e.Performance = 35] = "Performance",
    e[e.PerformanceDetail = 36] = "PerformanceDetail",
    e[e.AlgoParent = 37] = "AlgoParent",
    e[e.PerformanceRecalculate = 38] = "PerformanceRecalculate",
    e[e.MtsCommand = 39] = "MtsCommand",
    e[e.OptionMarketView = 40] = "OptionMarketView",
    e[e.BlackScholesCalculator = 41] = "BlackScholesCalculator",
    e[e.OptionPosition = 42] = "OptionPosition",
    e[e.ContractInfo = 43] = "ContractInfo",
    e[e.OptionContract = 44] = "OptionContract",
    e[e.OptionCustomerStatus = 45] = "OptionCustomerStatus",
    e[e.OptionBaseSymbolInfo = 46] = "OptionBaseSymbolInfo",
    e[e.BaseSymbolInfo = 47] = "BaseSymbolInfo",
    e[e.OptionAveragePrice = 48] = "OptionAveragePrice",
    e
}(K || {});
var M = class M {
}
;
M.IndexSchema = {
    DayOfEvent: "timestamp",
    LastIndexValue: "aggregatedlast",
    YesterdayPrice: "prev-aggregatedlast",
    PercentVariation: "variationpreviousday"
},
M.TextMessageSchema = {
    timestamp: "timestamp",
    meta: "meta"
},
M.GroupStateChangeSchema = {
    group: "group",
    timestamp: "timestamp",
    stateCode: "state-code"
},
M.MarketDepthBestPriceSchema = {
    time: "timestamp",
    buyVolume1: "buy-volume-1",
    sellVolume1: "sell-volume-1",
    buyOrderCount1: "buy-order-count-1",
    sellOrderCount1: "sell-order-count-1",
    buyPrice1: "buy-price-1",
    sellPrice1: "sell-price-1",
    buyVolume2: "buy-volume-2",
    sellVolume2: "sell-volume-2",
    buyOrderCount2: "buy-order-count-2",
    sellOrderCount2: "sell-order-count-2",
    buyPrice2: "buy-price-2",
    sellPrice2: "sell-price-2",
    buyVolume3: "buy-volume-3",
    sellVolume3: "sell-volume-3",
    buyOrderCount3: "buy-order-count-3",
    sellOrderCount3: "sell-order-count-3",
    buyPrice3: "buy-price-3",
    sellPrice3: "sell-price-3",
    buyVolume4: "buy-volume-4",
    sellVolume4: "sell-volume-4",
    buyOrderCount4: "buy-order-count-4",
    sellOrderCount4: "sell-order-count-4",
    buyPrice4: "buy-price-4",
    sellPrice4: "sell-price-4",
    buyVolume5: "buy-volume-5",
    sellVolume5: "sell-volume-5",
    buyOrderCount5: "buy-order-count-5",
    sellOrderCount5: "sell-order-count-5",
    buyPrice5: "buy-price-5",
    sellPrice5: "sell-price-5"
},
M.MoneySchema = {
    timestamp: "timestamp",
    meta: "meta"
},
M.orderStateNewSchema = {
    timestamp: "timestamp",
    meta: "meta"
},
M.orderPlaceSchema = {
    isin: "isin",
    volumeAhead: "volume-ahead",
    placement: "placement"
},
M.SymbolSchema = {
    totalNumberOfSharesTraded: "total-number-of-shares-traded",
    totalNumberOfTrades: "total-number-of-trades",
    totalTradeValue: "total-trade-value",
    closingPrice: "closing-price",
    firstPrice: "opening-price",
    lastTradedPrice: "last-trade-price",
    maxDailyPrice: "max-daily-price",
    minDailyPrice: "min-daily-price",
    bestBuyLimitVolume: "buy-volume-1",
    bestBuyLimitPrice: "buy-price-1",
    bestSellLimitPrice: "sell-price-1",
    bestSellLimitVolume: "sell-volume-1",
    stateCode: "state-code",
    minValidBuyVolume: "min-valid-buy-volume",
    minValidSellVolume: "min-valid-sell-volume",
    maxValidBuyVolume: "max-valid-buy-volume",
    maxValidSellVolume: "max-valid-sell-volume",
    feeOfPreviousDaysClosingPrice: "prev-closing-price",
    maxDailyTradedPrice: "max-daily-traded-price",
    minDailyTradedPrice: "min-daily-traded-price",
    priceTickSize: "min-dealable-price",
    tradeDate: "trade-date2",
    lastTradedPriceVarPercent: "price-variation",
    navDate: "nav-date",
    navSubscription: "nav-subscription",
    navRedemption: "nav-redemption"
},
M.ActiveStockSchema = {
    firstTradedPrice: M.SymbolSchema.firstPrice,
    totalNumberOfTrades: M.SymbolSchema.totalNumberOfTrades,
    totalTradeValue: M.SymbolSchema.totalTradeValue,
    closePrice: M.SymbolSchema.closingPrice,
    lastTradedPrice: M.SymbolSchema.lastTradedPrice,
    totalNumberOfSharesTraded: M.SymbolSchema.totalNumberOfSharesTraded,
    stateCode: M.SymbolSchema.stateCode,
    tradeDate: M.SymbolSchema.tradeDate,
    feeOfPreviousDaysClosingPrice: M.SymbolSchema.feeOfPreviousDaysClosingPrice,
    maxDailyPrice: M.SymbolSchema.maxDailyPrice,
    minDailyPrice: M.SymbolSchema.minDailyPrice,
    navDate: M.SymbolSchema.navDate,
    navSubscription: M.SymbolSchema.navSubscription,
    navRedemption: M.SymbolSchema.navRedemption,
    lastTradedPriceVar: M.SymbolSchema.lastTradedPriceVarPercent,
    maxDailyTradedPrice: M.SymbolSchema.maxDailyTradedPrice,
    minDailyTradedPrice: M.SymbolSchema.minDailyTradedPrice,
    priceTickSize: M.SymbolSchema.priceTickSize,
    minValidBuyVolume: M.SymbolSchema.minValidBuyVolume,
    minValidSellVolume: M.SymbolSchema.minValidSellVolume,
    maxValidBuyVolume: M.SymbolSchema.maxValidBuyVolume,
    maxValidSellVolume: M.SymbolSchema.maxValidSellVolume,
    bidPrice: M.SymbolSchema.bestSellLimitPrice,
    askPrice: M.SymbolSchema.bestBuyLimitPrice
},
M.SameGroupSchema = {
    closePrice: M.SymbolSchema.closingPrice,
    firstTradedPrice: M.SymbolSchema.firstPrice,
    maxDailyPrice: M.SymbolSchema.maxDailyPrice,
    minDailyPrice: M.SymbolSchema.minDailyPrice,
    maxDailyTradedPrice: M.SymbolSchema.maxDailyTradedPrice,
    minDailyTradedPrice: M.SymbolSchema.minDailyTradedPrice,
    lastTradedPriceVarPercent: M.SymbolSchema.lastTradedPriceVarPercent,
    lastTradedPrice: M.SymbolSchema.lastTradedPrice,
    totalNumberOfSharesTraded: M.SymbolSchema.totalNumberOfSharesTraded,
    stateCode: M.SymbolSchema.stateCode,
    feeOfPreviousDaysClosingPrice: M.SymbolSchema.feeOfPreviousDaysClosingPrice,
    bidPrice: M.SymbolSchema.bestSellLimitPrice,
    askPrice: M.SymbolSchema.bestBuyLimitPrice
},
M.TradeVolumeSchema = {
    isin: "isin",
    timestamp: "timestamp",
    institutionCode: "institution-code",
    buyCountPerson: "buy-count-person",
    buyCountLegal: "buy-count-legal",
    buyVolumePerson: "buy-volume-person",
    buyVolumeLegal: "buy-volume-legal",
    sellCountPerson: "sell-count-person",
    sellCountLegal: "sell-count-legal",
    sellVolumePerson: "sell-volume-person",
    sellVolumeLegal: "sell-volume-legal"
},
M.SymbolHeaderSchema = {
    lastTradedPrice: M.SymbolSchema.lastTradedPrice,
    feeOfPreviousDaysClosingPrice: M.SymbolSchema.feeOfPreviousDaysClosingPrice,
    closePrice: M.SymbolSchema.closingPrice,
    totalNumberOfSharesTraded: M.SymbolSchema.totalNumberOfSharesTraded,
    stateCode: M.SymbolSchema.stateCode,
    lastTradedPriceVar: M.SymbolSchema.lastTradedPriceVarPercent
},
M.MarketDepthSymbolSchema = {
    maxDailyTradedPrice: M.SymbolSchema.maxDailyTradedPrice,
    minDailyTradedPrice: M.SymbolSchema.minDailyTradedPrice,
    maxDailyPrice: M.SymbolSchema.maxDailyPrice,
    minDailyPrice: M.SymbolSchema.minDailyPrice,
    lastTradedPrice: M.SymbolSchema.lastTradedPrice,
    closePrice: M.SymbolSchema.closingPrice,
    feeOfPreviousDaysClosingPrice: M.SymbolSchema.feeOfPreviousDaysClosingPrice,
    totalTradeValue: M.SymbolSchema.totalTradeValue,
    firstPrice: M.SymbolSchema.firstPrice,
    totalNumberOfSharesTraded: M.SymbolSchema.totalNumberOfSharesTraded
},
M.StockInfoSchema = {
    firstPrice: M.SymbolSchema.firstPrice,
    totalNumberOfTrades: M.SymbolSchema.totalNumberOfTrades,
    totalTradeValue: M.SymbolSchema.totalTradeValue,
    closePrice: M.SymbolSchema.closingPrice,
    lastTradedPrice: M.SymbolSchema.lastTradedPrice,
    totalNumberOfSharesTraded: M.SymbolSchema.totalNumberOfSharesTraded,
    stateCode: M.SymbolSchema.stateCode,
    tradeDate: M.SymbolSchema.tradeDate,
    feeOfPreviousDaysClosingPrice: M.SymbolSchema.feeOfPreviousDaysClosingPrice,
    maxDailyPrice: M.SymbolSchema.maxDailyPrice,
    minDailyPrice: M.SymbolSchema.minDailyPrice,
    navDate: M.SymbolSchema.navDate,
    navSubscription: M.SymbolSchema.navSubscription,
    navRedemption: M.SymbolSchema.navRedemption
},
M.DPortfolioSchema = {
    totalNumberOfSharesTraded: M.SymbolSchema.totalNumberOfSharesTraded,
    totalNumberOfTrades: M.SymbolSchema.totalNumberOfTrades,
    totalTradeValue: M.SymbolSchema.totalTradeValue,
    closingPrice: M.SymbolSchema.closingPrice,
    firstTradedPrice: M.SymbolSchema.firstPrice,
    lastTradedPrice: M.SymbolSchema.lastTradedPrice,
    maxDailyPrice: M.SymbolSchema.maxDailyPrice,
    minDailyPrice: M.SymbolSchema.minDailyPrice,
    minDailyTradedPrice: M.SymbolSchema.minDailyTradedPrice,
    maxDailyTradedPrice: M.SymbolSchema.maxDailyTradedPrice,
    bestBuyLimitVolume: M.SymbolSchema.bestBuyLimitVolume,
    bestBuyLimitPrice: M.SymbolSchema.bestBuyLimitPrice,
    bestSellLimitPrice: M.SymbolSchema.bestSellLimitPrice,
    bestSellLimitVolume: M.SymbolSchema.bestSellLimitVolume,
    stateCode: M.SymbolSchema.stateCode,
    feeOfPreviousDaysClosingPrice: M.SymbolSchema.feeOfPreviousDaysClosingPrice,
    lastTradedPriceVarPercent: M.SymbolSchema.lastTradedPriceVarPercent,
    tradeDate: M.SymbolSchema.tradeDate
},
M.DRealtimePortfolioSchema = {
    totalNumberOfSharesTraded: M.SymbolSchema.totalNumberOfSharesTraded,
    totalNumberOfTrades: M.SymbolSchema.totalNumberOfTrades,
    totalTradeValue: M.SymbolSchema.totalTradeValue,
    closePrice: M.SymbolSchema.closingPrice,
    firstPrice: M.SymbolSchema.firstPrice,
    lastTradedPrice: M.SymbolSchema.lastTradedPrice,
    maxDailyPrice: M.SymbolSchema.maxDailyPrice,
    minDailyPrice: M.SymbolSchema.minDailyPrice,
    bestBuyLimitVolume: M.SymbolSchema.bestBuyLimitVolume,
    bestBuyLimitPrice: M.SymbolSchema.bestBuyLimitPrice,
    bestSellLimitPrice: M.SymbolSchema.bestSellLimitPrice,
    bestSellLimitVolume: M.SymbolSchema.bestSellLimitVolume,
    stateCode: M.SymbolSchema.stateCode,
    feeOfPreviousDaysClosingPrice: M.SymbolSchema.feeOfPreviousDaysClosingPrice,
    lastTradedPriceVarPercent: M.SymbolSchema.lastTradedPriceVarPercent,
    tradeDate: M.SymbolSchema.tradeDate
},
M.MarketWatchSchema = {
    totalNumberOfSharesTraded: M.SymbolSchema.totalNumberOfSharesTraded,
    totalNumberOfTrades: M.SymbolSchema.totalNumberOfTrades,
    totalTradeValue: M.SymbolSchema.totalTradeValue,
    closingPrice: M.SymbolSchema.closingPrice,
    firstTradedPrice: M.SymbolSchema.firstPrice,
    lastTradedPrice: M.SymbolSchema.lastTradedPrice,
    maxDailyPrice: M.SymbolSchema.maxDailyPrice,
    minDailyPrice: M.SymbolSchema.minDailyPrice,
    bestBuyLimitVolume: M.SymbolSchema.bestBuyLimitVolume,
    bestBuyLimitPrice: M.SymbolSchema.bestBuyLimitPrice,
    bestSellLimitPrice: M.SymbolSchema.bestSellLimitPrice,
    bestSellLimitVolume: M.SymbolSchema.bestSellLimitVolume,
    stateCode: M.SymbolSchema.stateCode,
    feeOfPreviousDaysClosingPrice: M.SymbolSchema.feeOfPreviousDaysClosingPrice,
    lastTradedPriceVarPercent: M.SymbolSchema.lastTradedPriceVarPercent,
    maxDailyTradedPrice: M.SymbolSchema.maxDailyTradedPrice,
    minDailyTradedPrice: M.SymbolSchema.minDailyTradedPrice
},
M.MobilePortfolioSchema = {
    lastTradedPrice: M.SymbolSchema.lastTradedPrice,
    closingPrice: M.SymbolSchema.closingPrice,
    stateCode: M.SymbolSchema.stateCode,
    feeOfPreviousDaysClosingPrice: M.SymbolSchema.feeOfPreviousDaysClosingPrice,
    totalNumberOfSharesTraded: M.SymbolSchema.totalNumberOfSharesTraded,
    lastTradedPriceVarPercent: M.SymbolSchema.lastTradedPriceVarPercent
},
M.MobileRealTimePortfolioSchema = {
    LastTradedPrice: M.SymbolSchema.lastTradedPrice,
    ClosingPrice: M.SymbolSchema.closingPrice,
    stateCode: M.SymbolSchema.stateCode,
    feeOfPreviousDaysClosingPrice: M.SymbolSchema.feeOfPreviousDaysClosingPrice,
    TotalNumberOfSharesTraded: M.SymbolSchema.totalNumberOfSharesTraded,
    lastTradedPriceVarPercent: M.SymbolSchema.lastTradedPriceVarPercent
},
M.OrderFormSchema = {
    priceTickSize: M.SymbolSchema.priceTickSize,
    minValidBuyVolume: M.SymbolSchema.minValidBuyVolume,
    minValidSellVolume: M.SymbolSchema.minValidSellVolume,
    maxValidBuyVolume: M.SymbolSchema.maxValidBuyVolume,
    maxValidSellVolume: M.SymbolSchema.maxValidSellVolume,
    maxDailyPrice: M.SymbolSchema.maxDailyPrice,
    minDailyPrice: M.SymbolSchema.minDailyPrice,
    bidPrice: M.SymbolSchema.bestSellLimitPrice,
    askPrice: M.SymbolSchema.bestBuyLimitPrice,
    feeOfPreviousDaysClosingPrice: M.SymbolHeaderSchema.feeOfPreviousDaysClosingPrice
},
M.OrderFormAskOrBidSchema = {
    bidPrice: M.SymbolSchema.bestSellLimitPrice,
    askPrice: M.SymbolSchema.bestBuyLimitPrice
},
M.EasyFilterSchema = {
    ClosingPrice: M.SymbolSchema.closingPrice,
    LastTradedPrice: M.SymbolSchema.lastTradedPrice,
    TotalTradeValue: M.SymbolSchema.totalTradeValue,
    TotalNumberOfSharesTraded: M.SymbolSchema.totalNumberOfSharesTraded,
    BestBuyLimitPrice_1: M.SymbolSchema.bestBuyLimitPrice,
    BestSellLimitPrice_1: M.SymbolSchema.bestSellLimitPrice,
    BestBuyLimitQuantity_1: M.SymbolSchema.bestBuyLimitVolume,
    BestSellLimitQuantity_1: M.SymbolSchema.bestSellLimitVolume,
    SymbolStateId: M.SymbolSchema.stateCode,
    LowAllowedPrice: M.SymbolSchema.minDailyPrice,
    HighAllowedPrice: M.SymbolSchema.maxDailyPrice,
    LowPrice: M.SymbolSchema.minDailyTradedPrice,
    HighPrice: M.SymbolSchema.maxDailyTradedPrice,
    feeOfPreviousDaysClosingPrice: M.SymbolSchema.feeOfPreviousDaysClosingPrice,
    lastTradedPriceVar: M.SymbolSchema.lastTradedPriceVarPercent
},
M.EasyFilterIndInstSchema = {
    IndInstTrade_Individual_SellVolume: M.TradeVolumeSchema.sellVolumePerson,
    IndInstTrade_Individual_BuyVolume: M.TradeVolumeSchema.buyVolumePerson,
    IndInstTrade_Institutional_SellVolume: M.TradeVolumeSchema.sellVolumeLegal,
    IndInstTrade_Institutional_BuyVolume: M.TradeVolumeSchema.buyVolumeLegal
},
M.SearchSchema = {
    SymbolStateId: M.SymbolSchema.stateCode,
    LastTradedPrice: M.SymbolSchema.lastTradedPrice,
    feeOfPreviousDaysClosingPrice: M.SymbolSchema.feeOfPreviousDaysClosingPrice,
    TotalNumberOfSharesTraded: M.SymbolSchema.totalNumberOfSharesTraded,
    lastTradedPriceVar: M.SymbolSchema.lastTradedPriceVarPercent
},
M.RecentSearchSchema = {
    SymbolStateId: M.SymbolSchema.stateCode,
    LastTradedPrice: M.SymbolSchema.lastTradedPrice,
    feeOfPreviousDaysClosingPrice: M.SymbolSchema.feeOfPreviousDaysClosingPrice,
    TotalNumberOfSharesTraded: M.SymbolSchema.totalNumberOfSharesTraded,
    lastTradedPriceVar: M.SymbolSchema.lastTradedPriceVarPercent,
    closePrice: M.SymbolSchema.closingPrice
},
M.ConditionalSchema = {
    LastTradedPrice: M.SymbolSchema.lastTradedPrice,
    TotalNumberOfSharesTraded: M.SymbolSchema.totalNumberOfSharesTraded,
    BestBuyLimitQuantity_1: M.SymbolSchema.bestBuyLimitVolume,
    BestSellLimitQuantity_1: M.SymbolSchema.bestSellLimitVolume,
    ClosingPrice: M.SymbolSchema.closingPrice,
    BestBuyLimitPrice_1: M.SymbolSchema.bestBuyLimitPrice,
    BestSellLimitPrice_1: M.SymbolSchema.bestSellLimitPrice,
    TotalTradeValue: M.SymbolSchema.totalTradeValue,
    FeeOfPreviousDaysClosingPrice: M.SymbolSchema.feeOfPreviousDaysClosingPrice,
    lastTradedPriceVar: M.SymbolSchema.lastTradedPriceVarPercent
},
M.MarketAffectingSchema = {
    SymbolStateId: M.SymbolSchema.stateCode,
    LastTradedPrice: M.SymbolSchema.lastTradedPrice,
    FeeOfPreviousDaysClosingPrice: M.SymbolSchema.feeOfPreviousDaysClosingPrice,
    TotalNumberOfSharesTraded: M.SymbolSchema.totalNumberOfSharesTraded,
    lastTradedPriceVar: M.SymbolSchema.lastTradedPriceVarPercent
},
M.BestOfMarketSchema = {
    SymbolStateId: M.SymbolSchema.stateCode,
    LastTradedPrice: M.SymbolSchema.lastTradedPrice,
    lastTradedPriceVar: M.SymbolSchema.lastTradedPriceVarPercent,
    BestBuyLimitPrice_1: M.SymbolSchema.bestBuyLimitPrice,
    BestSellLimitPrice_1: M.SymbolSchema.bestSellLimitPrice,
    BestSellLimitQuantity_1: M.SymbolSchema.bestSellLimitVolume,
    BestBuyLimitQuantity_1: M.SymbolSchema.bestBuyLimitVolume
},
M.MarketViewTopRankSchema = {
    totalNumberOfSharesTraded: M.SymbolSchema.totalNumberOfSharesTraded,
    totalNumberOfTrades: M.SymbolSchema.totalNumberOfTrades,
    totalTradeValue: M.SymbolSchema.totalTradeValue,
    lastTradedPrice: M.SymbolSchema.lastTradedPrice,
    tradedPriceVar: M.SymbolSchema.lastTradedPriceVarPercent,
    stateCode: M.SymbolSchema.stateCode,
    closePrice: M.SymbolSchema.closingPrice,
    feeOfPreviousDaysClosingPrice: M.SymbolSchema.feeOfPreviousDaysClosingPrice,
    bestBuyLimitVolume: M.SymbolSchema.bestBuyLimitVolume,
    bestSellLimitVolume: M.SymbolSchema.bestSellLimitVolume
},
M.TodayActivity = {
    SymbolStateId: M.SymbolSchema.stateCode
},
M.OptionMarketViewSchema = {
    stateCode: M.SymbolSchema.stateCode,
    lastTradedPrice: M.SymbolSchema.lastTradedPrice,
    lastTradedPriceVarPercent: M.SymbolSchema.lastTradedPriceVarPercent,
    closingPrice: M.SymbolSchema.closingPrice,
    totalNumberOfSharesTraded: M.SymbolSchema.totalNumberOfSharesTraded,
    totalTradeValue: M.SymbolSchema.totalTradeValue,
    feeOfPreviousDaysClosingPrice: M.SymbolSchema.feeOfPreviousDaysClosingPrice,
    bestBuyLimitVolume: M.SymbolSchema.bestBuyLimitVolume,
    bestBuyLimitPrice: M.SymbolSchema.bestBuyLimitPrice,
    bestSellLimitPrice: M.SymbolSchema.bestSellLimitPrice,
    bestSellLimitVolume: M.SymbolSchema.bestSellLimitVolume
},
M.BlackScholesCalculatorSchema = {
    lastTradedPrice: M.SymbolSchema.lastTradedPrice
},
M.ContractInfoSchema = {
    lastTradedPrice: M.SymbolSchema.lastTradedPrice,
    totalTradeValue: M.SymbolSchema.totalTradeValue,
    tradedPriceVar: M.SymbolSchema.lastTradedPriceVarPercent,
    totalNumberOfSharesTraded: M.SymbolSchema.totalNumberOfSharesTraded,
    closingPrice: M.SymbolSchema.closingPrice,
    stateCode: M.SymbolSchema.stateCode
},
M.OptionBaseSymbolInfo = {
    lastTradedPrice: M.SymbolSchema.lastTradedPrice,
    tradedPriceVar: M.SymbolSchema.lastTradedPriceVarPercent,
    closingPrice: M.SymbolSchema.closingPrice,
    totalTradeValue: M.SymbolSchema.totalTradeValue,
    totalNumberOfSharesTraded: M.SymbolSchema.totalNumberOfSharesTraded,
    feeOfPreviousDaysClosingPrice: M.SymbolSchema.feeOfPreviousDaysClosingPrice,
    stateCode: M.SymbolSchema.stateCode
},
M.BaseSymbolSchema = {
    lastTradedPrice: M.SymbolSchema.lastTradedPrice,
    tradedPriceVar: M.SymbolSchema.lastTradedPriceVarPercent,
    closingPrice: M.SymbolSchema.closingPrice,
    totalTradeValue: M.SymbolSchema.totalTradeValue,
    totalNumberOfSharesTraded: M.SymbolSchema.totalNumberOfSharesTraded,
    feeOfPreviousDaysClosingPrice: M.SymbolSchema.feeOfPreviousDaysClosingPrice
},
M.MarketSheetSchema = {
    BuyCount: "buy-count",
    SellCount: "sell-count",
    BuyVolume: "buy-volume",
    SellVolume: "sell-volume"
},
M.MarketSheetBuyChartSchema = {
    meta: "meta"
},
M.MarketSheetSellChartSchema = {
    meta: "meta"
},
M.PerformanceSchema = {
    meta: "meta"
},
M.PerformanceDetailSchema = {
    meta: "meta"
},
M.AlgoParentSchema = {
    meta: "meta"
},
M.PerformanceRecalculateSchema = {
    meta: "meta"
},
M.MtsCommandSchema = {
    meta: "meta"
},
M.OptionPositionSchema = {
    meta: "meta"
},
M.OptionContractSchema = {
    initialMargin: "initial-margin",
    requiredMargin: "required-margin",
    maintenanceMargin: "maintenance-margin",
    openPositions: "open-positions"
},
M.OptionCustomerStatusSchema = {
    meta: "meta"
},
M.OptionAveragePriceSchema = {
    meta: "meta"
};
var se = M;
var Sc = class Sc {
}
;
Sc.LsSchemas = [{
    type: K.BestLimit,
    schema: se.MarketDepthBestPriceSchema
}, {
    type: K.ActiveStock,
    schema: se.ActiveStockSchema
}, {
    type: K.TradeVolume,
    schema: se.TradeVolumeSchema
}, {
    type: K.EasyFilterIndInst,
    schema: se.EasyFilterIndInstSchema
}, {
    type: K.GroupStateChange,
    schema: se.GroupStateChangeSchema
}, {
    type: K.TextMessage,
    schema: se.TextMessageSchema
}, {
    type: K.Order,
    schema: se.orderStateNewSchema
}, {
    type: K.OrderPlace,
    schema: se.orderPlaceSchema
}, {
    type: K.Money,
    schema: se.MoneySchema
}, {
    type: K.Symbol,
    schema: se.SymbolSchema
}, {
    type: K.SymbolHeader,
    schema: se.SymbolHeaderSchema
}, {
    type: K.OrderFormAskOrBid,
    schema: se.OrderFormAskOrBidSchema
}, {
    type: K.MarketDepthSymbol,
    schema: se.MarketDepthSymbolSchema
}, {
    type: K.StockInfo,
    schema: se.StockInfoSchema
}, {
    type: K.OrderForm,
    schema: se.OrderFormSchema
}, {
    type: K.EasyFilter,
    schema: se.EasyFilterSchema
}, {
    type: K.Search,
    schema: se.SearchSchema
}, {
    type: K.RecentSearch,
    schema: se.RecentSearchSchema
}, {
    type: K.MarketWatch,
    schema: se.MarketWatchSchema
}, {
    type: K.Portfolio,
    schema: se.MobilePortfolioSchema
}, {
    type: K.RealtimePortfolio,
    schema: se.MobileRealTimePortfolioSchema
}, {
    type: K.Conditional,
    schema: se.ConditionalSchema
}, {
    type: K.MarketAffecting,
    schema: se.MarketAffectingSchema
}, {
    type: K.BestOfMarket,
    schema: se.BestOfMarketSchema
}, {
    type: K.DPortfolio,
    schema: se.DPortfolioSchema
}, {
    type: K.DRealtimePortfolio,
    schema: se.DRealtimePortfolioSchema
}, {
    type: K.TodayActivity,
    schema: se.TodayActivity
}, {
    type: K.Index,
    schema: se.IndexSchema
}, {
    type: K.MarketSheet,
    schema: se.MarketSheetSchema
}, {
    type: K.MarketSheetChartBuy,
    schema: se.MarketSheetBuyChartSchema
}, {
    type: K.MarketSheetChartSell,
    schema: se.MarketSheetSellChartSchema
}, {
    type: K.MarketViewTopRank,
    schema: se.MarketViewTopRankSchema
}, {
    type: K.SameGroup,
    schema: se.SameGroupSchema
}, {
    type: K.Performance,
    schema: se.PerformanceSchema
}, {
    type: K.PerformanceDetail,
    schema: se.PerformanceDetailSchema
}, {
    type: K.AlgoParent,
    schema: se.AlgoParentSchema
}, {
    type: K.PerformanceRecalculate,
    schema: se.PerformanceRecalculateSchema
}, {
    type: K.MtsCommand,
    schema: se.MtsCommandSchema
}, {
    type: K.OptionMarketView,
    schema: se.OptionMarketViewSchema
}, {
    type: K.BlackScholesCalculator,
    schema: se.BlackScholesCalculatorSchema
}, {
    type: K.OptionPosition,
    schema: se.OptionPositionSchema
}, {
    type: K.ContractInfo,
    schema: se.ContractInfoSchema
}, {
    type: K.OptionContract,
    schema: se.OptionContractSchema
}, {
    type: K.OptionBaseSymbolInfo,
    schema: se.OptionBaseSymbolInfo
}, {
    type: K.BaseSymbolInfo,
    schema: se.BaseSymbolSchema
}, {
    type: K.OptionCustomerStatus,
    schema: se.OptionCustomerStatusSchema
}, {
    type: K.OptionAveragePrice,
    schema: se.OptionAveragePriceSchema
}],
Sc.LsSchemasTopic = [{
    schema: K.BestLimit,
    topic: "bestlimit"
}, {
    schema: K.ActiveStock,
    topic: "symbol"
}, {
    schema: K.TradeVolume,
    topic: "tradevolume"
}, {
    schema: K.EasyFilterIndInst,
    topic: "tradevolume"
}, {
    schema: K.GroupStateChange,
    topic: "groupstatechange"
}, {
    schema: K.TextMessage,
    topic: "textmessage"
}, {
    schema: K.Order,
    topic: "order"
}, {
    schema: K.OrderPlace,
    topic: "orderplace"
}, {
    schema: K.Money,
    topic: "money"
}, {
    schema: K.Symbol,
    topic: "symbol"
}, {
    schema: K.SymbolHeader,
    topic: "symbol"
}, {
    schema: K.MarketDepthSymbol,
    topic: "symbol"
}, {
    schema: K.StockInfo,
    topic: "symbol"
}, {
    schema: K.OrderForm,
    topic: "symbol"
}, {
    schema: K.EasyFilter,
    topic: "symbol"
}, {
    schema: K.Search,
    topic: "symbol"
}, {
    schema: K.RecentSearch,
    topic: "symbol"
}, {
    schema: K.MarketWatch,
    topic: "symbol"
}, {
    schema: K.Portfolio,
    topic: "symbol"
}, {
    schema: K.RealtimePortfolio,
    topic: "symbol"
}, {
    schema: K.Conditional,
    topic: "symbol"
}, {
    schema: K.MarketAffecting,
    topic: "symbol"
}, {
    schema: K.BestOfMarket,
    topic: "symbol"
}, {
    schema: K.ReturnChart,
    topic: "symbol"
}, {
    schema: K.DPortfolio,
    topic: "symbol"
}, {
    schema: K.DRealtimePortfolio,
    topic: "symbol"
}, {
    schema: K.OrderFormAskOrBid,
    topic: "symbol"
}, {
    schema: K.TodayActivity,
    topic: "symbol"
}, {
    schema: K.SameGroup,
    topic: "symbol"
}, {
    schema: K.Index,
    topic: "index"
}, {
    schema: K.MarketSheet,
    topic: "marketsheet"
}, {
    schema: K.MarketSheetChartBuy,
    topic: "marketsheet-details-buy"
}, {
    schema: K.MarketSheetChartSell,
    topic: "marketsheet-details-sell"
}, {
    schema: K.MarketViewTopRank,
    topic: "symbol"
}, {
    schema: K.Performance,
    topic: "performance"
}, {
    schema: K.PerformanceDetail,
    topic: "performancedetail"
}, {
    schema: K.AlgoParent,
    topic: "algoparent"
}, {
    schema: K.PerformanceRecalculate,
    topic: "performancerecalculate"
}, {
    schema: K.MtsCommand,
    topic: "mts-command"
}, {
    schema: K.OptionMarketView,
    topic: "symbol"
}, {
    schema: K.BlackScholesCalculator,
    topic: "symbol"
}, {
    schema: K.OptionPosition,
    topic: "option-position"
}, {
    schema: K.ContractInfo,
    topic: "symbol"
}, {
    schema: K.OptionContract,
    topic: "option-contract"
}, {
    schema: K.OptionCustomerStatus,
    topic: "option-customer-status"
}, {
    schema: K.OptionBaseSymbolInfo,
    topic: "symbol"
}, {
    schema: K.BaseSymbolInfo,
    topic: "symbol"
}, {
    schema: K.OptionAveragePrice,
    topic: "option-average-price"
}],
Sc.LsAdapterName = [{
    topic: "bestlimit",
    value: "BESTLIMIT_ADAPTER"
}, {
    topic: "symbol",
    value: "RLC_ADAPTER"
}, {
    topic: "tradevolume",
    value: "SLE_ADAPTER"
}, {
    topic: "groupstatechange",
    value: "RLC_ADAPTER"
}, {
    topic: "textmessage",
    value: "SLE_ADAPTER"
}, {
    topic: "money",
    value: "SLE_ADAPTER"
}, {
    topic: "order",
    value: "SLE_ADAPTER"
}, {
    topic: "performance",
    value: "THIRDPARTY_ADAPTER"
}, {
    topic: "performancedetail",
    value: "THIRDPARTY_ADAPTER"
}, {
    topic: "algoparent",
    value: "THIRDPARTY_ADAPTER"
}, {
    topic: "orderplace",
    value: "SLE_ADAPTER"
}, {
    topic: "index",
    value: "SLE_ADAPTER"
}, {
    topic: "marketsheet",
    value: "MARKETSHEET_ADAPTER"
}, {
    topic: "marketsheet-details-buy",
    value: "MARKETSHEET_ADAPTER"
}, {
    topic: "marketsheet-details-sell",
    value: "MARKETSHEET_ADAPTER"
}, {
    topic: "performancerecalculate",
    value: "THIRDPARTY_ADAPTER"
}, {
    topic: "mts-command",
    value: "THIRDPARTY_ADAPTER"
}, {
    topic: "option-position",
    value: "SLE_ADAPTER"
}, {
    topic: "option-contract",
    value: "SLE_ADAPTER"
}, {
    topic: "option-customer-status",
    value: "SLE_ADAPTER"
}, {
    topic: "option-average-price",
    value: "SLE_ADAPTER"
}],
Sc.SnapshotSchemas = [K.BestLimit, K.TradeVolume, K.GroupStateChange, K.Symbol, K.SymbolHeader, K.MarketDepthSymbol, K.StockInfo, K.OrderForm, K.EasyFilter, K.EasyFilterIndInst, K.RecentSearch, K.Conditional, K.MarketAffecting, K.BestOfMarket, K.ReturnChart, K.TodayActivity, K.Index, K.MarketWatch, K.Portfolio, K.RealtimePortfolio, K.DPortfolio, K.DRealtimePortfolio, K.OrderFormAskOrBid, K.MarketViewTopRank, K.ActiveStock, K.SameGroup, K.OptionMarketView, K.BlackScholesCalculator, K.ContractInfo, K.OptionContract, K.OptionBaseSymbolInfo, K.BaseSymbolInfo],
Sc.RawModeSchemas = [K.Order, K.MarketSheetChartBuy, K.MarketSheetChartSell, K.Performance, K.PerformanceDetail, K.AlgoParent, K.OptionPosition, K.OptionCustomerStatus, K.OptionAveragePrice],
Sc.FullModeChangeSchemas = [K.MarketWatch, K.Portfolio, K.RealtimePortfolio, K.DPortfolio, K.MarketViewTopRank, K.DRealtimePortfolio, K.SymbolHeader, K.ActiveStock, K.MarketDepthSymbol, K.TradeVolume, K.MarketSheet, K.BestLimit, K.OrderForm, K.SameGroup, K.OptionMarketView, K.ContractInfo, K.OptionContract, K.OptionBaseSymbolInfo, K.BaseSymbolInfo, K.Search];
var ti = Sc;
var Pl = class {
    constructor(t, n, i) {
        this.title = t,
        this.data = n,
        this.onMessageCallBack = i
    }
}
;
var jb = ( () => {
    let t = class t {
        agInit() {}
        refresh() {}
    }
    ;
    t.\u0275fac = function(r) {
        return new (r || t)
    }
    ,
    t.\u0275cmp = Ye({
        type: t,
        selectors: [["ag-grid-no-rows"]],
        decls: 1,
        vars: 0,
        template: function(r, s) {
            r & 1 && me(0, "empty-result-warning")
        },
        dependencies: [n_],
        encapsulation: 2,
        changeDetection: 0
    });
    let e = t;
    return e
}
)();
var oN = [{
    p: "\u0622",
    eng: "a"
}, {
    p: "\u0627",
    eng: "b"
}, {
    p: "\u0628",
    eng: "c"
}, {
    p: "\u067E",
    eng: "d"
}, {
    p: "\u062A",
    eng: "e"
}, {
    p: "\u062B",
    eng: "f"
}, {
    p: "\u062C",
    eng: "g"
}, {
    p: "\u0686",
    eng: "h"
}, {
    p: "\u062D",
    eng: "i"
}, {
    p: "\u062E",
    eng: "j"
}, {
    p: "\u062F",
    eng: "k"
}, {
    p: "\u0630",
    eng: "l"
}, {
    p: "\u0631",
    eng: "m"
}, {
    p: "\u0632",
    eng: "n"
}, {
    p: "\u0698",
    eng: "o"
}, {
    p: "\u0633",
    eng: "p"
}, {
    p: "\u0634",
    eng: "q"
}, {
    p: "\u0636",
    eng: "r"
}, {
    p: "\u0635",
    eng: "s"
}, {
    p: "\u0637",
    eng: "t"
}, {
    p: "\u0638",
    eng: "u"
}, {
    p: "\u0639",
    eng: "v"
}, {
    p: "\u063A",
    eng: "w"
}, {
    p: "\u0641",
    eng: "x"
}, {
    p: "\u0642",
    eng: "y"
}, {
    p: "\u06A9",
    eng: "z1"
}, {
    p: "\u06AF",
    eng: "z2"
}, {
    p: "\u0644",
    eng: "z3"
}, {
    p: "\u0645",
    eng: "z4"
}, {
    p: "\u0646",
    eng: "z5"
}, {
    p: "\u0648",
    eng: "z6"
}, {
    p: "\u0647",
    eng: "z7"
}, {
    p: "\u06CC",
    eng: "z8"
}, {
    p: "\u064A",
    eng: "z9"
}]
  , Fo = (e="") => {
    let t = "";
    e || (e = "");
    for (let n = 0; n < e?.length; n++) {
        let i = e[n]
          , r = oN.find(s => s.p === i);
        r ? t += r.eng : t += i
    }
    return t
}
  , Soe = (e, t, n=!1) => e.map(i => ({
    source: i,
    enChared: Fo(i[t])
})).sort( (i, r) => {
    let s = 0;
    return i.enChared < r.enChared && (s = -1),
    i.enChared > r.enChared ? s = 1 : s = 0,
    s * (n ? -1 : 1)
}
).map(i => i.source);
var xoe = (e, t, n) => e.map(i => ({
    source: i,
    enChared: Fo(i[t])
})).sort( (i, r) => n === "asc" ? i.enChared < r.enChared ? -1 : i.enChared > r.enChared ? 1 : 0 : r.enChared < i.enChared ? -1 : r.enChared > i.enChared ? 1 : 0).map(i => i.source);
var qb = e => e == null ? "" : (+e).toLocaleString()
  , Ooe = e => e == null || isNaN(e) ? "-" : (+e).toLocaleString()
  , Poe = e => e.replace(/,/g, "")
  , aN = e => e ? e.substring(e.length - 1, e.length) != "1" ? e : e.substring(0, e.length - 1) : ""
  , Moe = e => {
    let t = e.data.symbolFa || e.data.name || e.data.symbolName;
    return aN(t)
}
  , cN = e => {
    let t = e.slice(0, 1);
    return e.replace(t, t.toLowerCase())
}
  , koe = jb
  , Aoe = '<div dir="rtl" class="loading"></div>'
  , Ioe = e => {
    switch (e) {
    case se.SymbolSchema.lastTradedPriceVarPercent:
        return "priceVar";
    case se.SymbolSchema.totalNumberOfSharesTraded:
        return "totalNumberOfSharesTraded";
    case se.SymbolSchema.totalNumberOfTrades:
        return "totalNumberOfTrades";
    case se.SymbolSchema.totalTradeValue:
        return "totalTradeValue";
    case se.SymbolSchema.closingPrice:
        return "closingPrice";
    case se.SymbolSchema.firstPrice:
        return "firstTradedPrice";
    case se.SymbolSchema.lastTradedPrice:
        return "lastTradedPrice";
    case se.SymbolSchema.maxDailyPrice:
        return "highAllowedPrice";
    case se.SymbolSchema.minDailyPrice:
        return "lowAllowedPrice";
    case se.SymbolSchema.bestBuyLimitVolume:
        return "bestBuyQuantity";
    case se.SymbolSchema.bestBuyLimitPrice:
        return "bestBuyPrice";
    case se.SymbolSchema.bestSellLimitVolume:
        return "bestSellQuantity";
    case se.SymbolSchema.bestSellLimitPrice:
        return "bestSellPrice";
    case se.SymbolSchema.stateCode:
        return "stateColor";
    case se.SymbolSchema.minDailyTradedPrice:
        return "minDailyTradedPrice";
    case se.SymbolSchema.maxDailyTradedPrice:
        return "maxDailyTradedPrice";
    case se.TradeVolumeSchema.sellVolumePerson:
        return "indSV";
    case se.TradeVolumeSchema.buyVolumePerson:
        return "indBV";
    case se.TradeVolumeSchema.sellVolumeLegal:
        return "insSV";
    case se.TradeVolumeSchema.buyVolumeLegal:
        return "insBV";
    default:
        return cN(e)
    }
}
;
var Roe = (e, t) => e ? (+e.toFixed(t)).toLocaleString() : ""
  , Doe = (e, t) => e === t ? 0 : e == null ? -1 : t == null ? 1 : e === t ? 0 : e == null ? -1 : t == null ? 1 : +e - +t
  , Noe = (e, t) => {
    let n = Fo(e)
      , i = Fo(t);
    return n < i ? -1 : n > i ? 1 : 0
}
  , lN = function(e) {
    return e[e.MarketWatch = 0] = "MarketWatch",
    e[e.Portfolio = 1] = "Portfolio",
    e[e.Realtime = 2] = "Realtime",
    e[e.EasyFilter = 3] = "EasyFilter",
    e[e.Position = 4] = "Position",
    e[e.OptionMarketView = 5] = "OptionMarketView",
    e
}(lN || {});
var hu = "red"
  , Yf = "green"
  , mg = "yellow";
var Mt = function(e) {
    return e[e.P = 0] = "P",
    e[e.S = 1] = "S",
    e[e.C = 2] = "C",
    e
}(Mt || {})
  , ni = function(e) {
    return e[e.Exchange = 1] = "Exchange",
    e[e.BondETFMaskan = 2] = "BondETFMaskan",
    e[e.Gold = 3] = "Gold",
    e[e.Glass = 4] = "Glass",
    e[e.Cement = 5] = "Cement",
    e[e.Fix = 6] = "Fix",
    e[e.Energy = 7] = "Energy",
    e
}(ni || {});
var xc = class xc {
}
;
xc.OpenMarketEndTime = 1230,
xc.OpenMarketGroupStates = ["O", "P", "S"],
xc.GroupTypes = {
    [ni.Exchange]: ["16", "19", "91", "1N", "1Z", "21", "61", "71", "C1", "D1", "G1", "L1", "N1", "N2", "P1", "QC", "S1", "V1", "Z1", "ZS", "NS", "51", "T1"],
    [ni.BondETFMaskan]: ["17", "N4", "Q1", "M1"],
    [ni.Gold]: ["QB", "QS"],
    [ni.Glass]: ["QA"],
    [ni.Cement]: ["QA"],
    [ni.Fix]: ["27", "12", "1A", "I1", "I2", "H1"],
    [ni.Energy]: ["EZ"]
},
xc.IntegratedGroupTypes = [{
    groupType: ni.Exchange,
    headers: ["\u0633\u0647\u0627\u0645 \u0648 \u062D\u0642 \u062A\u0642\u062F\u0645 \u0633\u0647\u0627\u0645", "\u0635\u0646\u062F\u0648\u0642\u200C\u0647\u0627\u06CC \u0633\u0647\u0627\u0645\u06CC \u0648 \u0645\u062E\u062A\u0644\u0637"],
    titles: [{
        text: "\u067E\u06CC\u0634 \u06AF\u0634\u0627\u06CC\u0634",
        classes: ["w-40", "w-md-30"]
    }, {
        text: "\u0645\u0639\u0627\u0645\u0644\u0627\u062A \u067E\u06CC\u0648\u0633\u062A\u0647",
        classes: ["flex-fill"]
    }],
    days: [1, 2, 3, 4, 5],
    times: [{
        value: "08:45",
        classes: ["w-40", "w-md-30"],
        state: Mt.P
    }, {
        value: "09:00",
        classes: [],
        state: Mt.S
    }, {
        value: "12:30",
        classes: ["text-end", "flex-grow-1"],
        state: Mt.C
    }],
    progress: ["w-40 w-md-30 bg-warning", "flex-grow-1 bg-primary"],
    weekText: "\u0634\u0646\u0628\u0647 \u062A\u0627 \u0686\u0647\u0627\u0631\u0634\u0646\u0628\u0647"
}, {
    groupType: ni.Fix,
    headers: ["\u0627\u0648\u0631\u0627\u0642 \u0628\u0627 \u062F\u0631\u0622\u0645\u062F \u062B\u0627\u0628\u062A \u0641\u0631\u0627\u0628\u0648\u0631\u0633 (\u0645\u0634\u0627\u0631\u06A9\u062A/ \u0627\u062C\u0627\u0631\u0647/ \u0645\u0631\u0627\u0628\u062D\u0647)", "\u0635\u0646\u062F\u0648\u0642\u0647\u0627\u06CC \u062F\u0631\u0622\u0645\u062F \u062B\u0627\u0628\u062A"],
    titles: [{
        text: "\u067E\u06CC\u0634 \u06AF\u0634\u0627\u06CC\u0634",
        classes: ["w-40", "w-md-30"]
    }, {
        text: "\u0645\u0639\u0627\u0645\u0644\u0627\u062A \u067E\u06CC\u0648\u0633\u062A\u0647",
        classes: ["flex-fill"]
    }],
    days: [1, 2, 3, 4, 5],
    times: [{
        value: "08:25",
        classes: ["w-40", "w-md-30"],
        state: Mt.P
    }, {
        value: "08:30",
        classes: [],
        state: Mt.S
    }, {
        value: "15:00",
        classes: ["text-end", "flex-grow-1"],
        state: Mt.C
    }],
    progress: ["w-40 w-md-30 bg-warning", "flex-grow-1 bg-primary"],
    weekText: "\u0634\u0646\u0628\u0647 \u062A\u0627 \u0686\u0647\u0627\u0631\u0634\u0646\u0628\u0647"
}, {
    groupType: ni.BondETFMaskan,
    headers: ["\u0627\u0648\u0631\u0627\u0642 \u062A\u0633\u0647\u06CC\u0644\u0627\u062A \u0645\u0633\u06A9\u0646", "\u0627\u0648\u0631\u0627\u0642 \u0628\u0627 \u062F\u0631\u0622\u0645\u062F \u062B\u0627\u0628\u062A \u0628\u0648\u0631\u0633 (\u0645\u0634\u0627\u0631\u06A9\u062A/ \u0627\u062C\u0627\u0631\u0647/ \u0645\u0631\u0627\u0628\u062D\u0647)", "\u0635\u0646\u062F\u0648\u0642\u200C\u0647\u0627 \u0648 \u0633\u067E\u0631\u062F\u0647\u200C\u0647\u0627\u06CC \u06A9\u0627\u0644\u0627\u06CC\u06CC \u0628\u0647 \u063A\u06CC\u0631 \u0627\u0632 \u0637\u0644\u0627 (\u067E\u0633\u062A\u0647\u060C \u0632\u0639\u0641\u0631\u0627\u0646 \u0648 ...)"],
    titles: [{
        text: "\u067E\u06CC\u0634 \u06AF\u0634\u0627\u06CC\u0634",
        classes: ["w-40", "w-md-30"]
    }, {
        text: "\u0645\u0639\u0627\u0645\u0644\u0627\u062A \u067E\u06CC\u0648\u0633\u062A\u0647",
        classes: ["flex-fill"]
    }],
    days: [1, 2, 3, 4, 5],
    times: [{
        value: "08:45",
        classes: ["w-40", "w-md-30"],
        state: Mt.P
    }, {
        value: "09:00",
        classes: [],
        state: Mt.S
    }, {
        value: "15:00",
        classes: ["text-end", "flex-grow-1"],
        state: Mt.C
    }],
    progress: ["w-40 w-md-30 bg-warning", "flex-grow-1 bg-primary"],
    weekText: "\u0634\u0646\u0628\u0647 \u062A\u0627 \u0686\u0647\u0627\u0631\u0634\u0646\u0628\u0647"
}, {
    groupType: ni.Gold,
    headers: ["\u0635\u0646\u062F\u0648\u0642\u200C\u0647\u0627 \u0648 \u0633\u067E\u0631\u062F\u0647\u200C\u0647\u0627\u06CC \u06A9\u0627\u0644\u0627\u06CC\u06CC \u0637\u0644\u0627 (\u0639\u06CC\u0627\u0631\u060C \u0633\u06A9\u0647 \u0645\u0631\u06A9\u0632\u06CC \u0648 ...)"],
    titles: [{
        text: "\u067E\u06CC\u0634 \u06AF\u0634\u0627\u06CC\u0634",
        classes: ["w-40", "w-md-30"]
    }, {
        text: "\u0645\u0639\u0627\u0645\u0644\u0627\u062A \u067E\u06CC\u0648\u0633\u062A\u0647",
        classes: ["flex-fill"]
    }],
    days: [1, 2, 3, 4, 5],
    times: [{
        value: "11:30",
        classes: ["w-40", "w-md-30"],
        state: Mt.P
    }, {
        value: "12:00",
        classes: [],
        state: Mt.S
    }, {
        value: "15:00",
        classes: ["text-end", "flex-grow-1"],
        state: Mt.C
    }],
    progress: ["w-40 w-md-30 bg-warning", "flex-grow-1 bg-primary"],
    weekText: "\u0634\u0646\u0628\u0647 \u062A\u0627 \u0686\u0647\u0627\u0631\u0634\u0646\u0628\u0647"
}, {
    groupType: ni.Energy,
    headers: ["\u0635\u0646\u062F\u0648\u0642\u200C\u0647\u0627\u06CC \u0628\u0648\u0631\u0633 \u0627\u0646\u0631\u0698\u06CC"],
    titles: [{
        text: "\u067E\u06CC\u0634 \u06AF\u0634\u0627\u06CC\u0634",
        classes: ["w-40", "w-md-30"]
    }, {
        text: "\u0645\u0639\u0627\u0645\u0644\u0627\u062A \u067E\u06CC\u0648\u0633\u062A\u0647",
        classes: ["flex-fill"]
    }],
    days: [1, 2, 3, 4, 5],
    times: [{
        value: "10:45",
        classes: ["w-40", "w-md-30"],
        state: Mt.P
    }, {
        value: "11:00",
        classes: [],
        state: Mt.S
    }, {
        value: "14:00",
        classes: ["text-end", "flex-grow-1"],
        state: Mt.C
    }],
    progress: ["w-40 w-md-30 bg-warning", "flex-grow-1 bg-primary"],
    weekText: "\u0634\u0646\u0628\u0647 \u062A\u0627 \u0686\u0647\u0627\u0631\u0634\u0646\u0628\u0647"
}, {
    groupType: ni.Glass,
    headers: ["\u06AF\u0648\u0627\u0647\u06CC \u0633\u067E\u0631\u062F\u0647 \u06A9\u0627\u0644\u0627\u06CC\u06CC \u0634\u06CC\u0634\u0647"],
    titles: [{
        text: "\u067E\u06CC\u0634 \u06AF\u0634\u0627\u06CC\u0634",
        classes: ["w-75"]
    }, {
        text: "\u06AF\u0634\u0627\u06CC\u0634",
        classes: ["flex-fill"]
    }],
    days: [2],
    times: [{
        value: "12:45",
        classes: ["w-75"],
        state: Mt.P
    }, {
        value: "14:00",
        classes: [],
        state: Mt.C
    }],
    progress: ["bg-warning w-75", "bg-secondary flex-fill opacity-2"],
    weekText: "\u062F\u0648\u0634\u0646\u0628\u0647"
}, {
    groupType: ni.Cement,
    headers: ["\u06AF\u0648\u0627\u0647\u06CC \u0633\u067E\u0631\u062F\u0647 \u06A9\u0627\u0644\u0627\u06CC\u06CC \u0633\u06CC\u0645\u0627\u0646"],
    titles: [{
        text: "\u067E\u06CC\u0634 \u06AF\u0634\u0627\u06CC\u0634",
        classes: ["w-75"]
    }, {
        text: "\u06AF\u0634\u0627\u06CC\u0634",
        classes: ["flex-fill"]
    }],
    days: [2, 4],
    times: [{
        value: "12:45",
        classes: ["w-75"],
        state: Mt.P
    }, {
        value: "14:00",
        classes: [],
        state: Mt.C
    }],
    progress: ["bg-warning w-75", "bg-secondary flex-fill opacity-2"],
    weekText: "\u062F\u0648\u0634\u0646\u0628\u0647\u060C \u0633\u0647\u200C\u0634\u0646\u0628\u0647"
}],
xc.ExceptionSymbols = [],
xc.ExceptionGroups = [{
    group: "Q1",
    marketUnit: y.Sekkeh,
    groupType: ni.Gold,
    elseGroupType: ni.BondETFMaskan
}, {
    group: "QA",
    marketUnit: y.NapeyvastehSiman,
    groupType: ni.Cement,
    elseGroupType: ni.Glass
}];
var Lo = xc;
var du = e => {
    if (e = e?.trim(),
    e != null)
        switch (e) {
        case "AS":
        case "AR":
            return mg;
        case "A":
        case "65":
            return Yf;
        case "AG":
        case "IG":
        case "IS":
        case "IR":
        case "I":
        case "73":
            return hu
        }
    return ""
}
  , qoe = e => {
    if (e != null)
        switch (e = e.trim(),
        e) {
        case "I":
        case "73":
            return "\u0645\u0645\u0646\u0648\u0639";
        case "A":
        case "65":
            return "\u0645\u062C\u0627\u0632";
        case "AG":
            return "\u0645\u062C\u0627\u0632-\u0645\u0633\u062F\u0648\u062F";
        case "AS":
            return "\u0645\u062C\u0627\u0632-\u0645\u062A\u0648\u0642\u0641";
        case "AR":
            return "\u0645\u062C\u0627\u0632-\u0645\u062D\u0641\u0648\u0638";
        case "IG":
            return "\u0645\u0645\u0646\u0648\u0639-\u0645\u0633\u062F\u0648\u062F";
        case "IS":
            return "\u0645\u0645\u0646\u0648\u0639-\u0645\u062A\u0648\u0642\u0641";
        case "IR":
            return "\u0645\u0645\u0646\u0648\u0639-\u0645\u062D\u0641\u0648\u0638";
        default:
            return ""
        }
    return ""
}
;
var zoe = e => {
    if (!e)
        return "";
    switch (e) {
    case Yf:
        return "\u0645\u062C\u0627\u0632";
    case hu:
        return "\u0645\u0645\u0646\u0648\u0639-\u0645\u062A\u0648\u0642\u0641";
    case mg:
        return "\u0645\u062C\u0627\u0632 \u0645\u062D\u0641\u0648\u0638";
    default:
        return ""
    }
}
  , Xoe = (e, t, n) => {
    let i = +Object.keys(Lo.GroupTypes).find(o => Lo.GroupTypes[o].includes(e));
    if (n) {
        let o = Lo.ExceptionSymbols.find(a => a.symbolIsin === n);
        o && (i = o.groupType)
    }
    let r = Lo.ExceptionGroups.find(o => o.group === e);
    return r && (r.marketUnit === t ? i = r.groupType : i = r.elseGroupType),
    Lo.IntegratedGroupTypes.find(o => o.groupType === i)
}
  , uN = (e, t) => {
    let n = e.split(":")
      , i = +(n[0] + n[1]);
    if (t) {
        let r = t.times.find(c => c.state === Mt.P)?.value?.split(":")
          , s = t.times.findIndex(c => c.state === Mt.S) > -1 ? t.times.find(c => c.state === Mt.S)?.value?.split(":") : t.times.find(c => c.state === Mt.C)?.value?.split(":")
          , o = t.times.find(c => c.state === Mt.S)?.value?.split(":")
          , a = t.times.find(c => c.state === Mt.C)?.value?.split(":");
        if (i >= +(r[0] + r[1]) && i < +(s[0] + s[1]))
            return Mt.P;
        if (i >= +(a[0] + a[1]) || i < +(r[0] + r[1]))
            return Mt.C;
        if (i >= +(o[0] + o[1]) && i < +(a[0] + a[1]))
            return Mt.S
    }
}
  , Koe = (e, t, n) => {
    if (!n)
        return !1;
    let i = uN(e, t)
      , r = t?.times?.find(a => a.state === Mt.P)?.value?.split(":")
      , s = t?.times?.find(a => a.state === Mt.C)?.value?.split(":")
      , o = +(e.split(":")[0] + e.split(":")[1]);
    return !r || !s ? !1 : i === Mt.P || i === Mt.S || o >= +(r?.[0] + r?.[1]) - 1 && o <= +(s?.[0] + s?.[1])
}
  , Yoe = (e, t, n) => n ? e?.toUpperCase() === "O" ? {
    clockClass: "text-warning",
    tooltip: "\u06AF\u0634\u0627\u06CC\u0634",
    iconName: $t.Clock
} : t === Mt.P ? {
    clockClass: "text-warning",
    tooltip: "\u067E\u06CC\u0634 \u06AF\u0634\u0627\u06CC\u0634",
    iconName: $t.Clock
} : t === Mt.S && e === "P" ? {
    clockClass: "text-warning",
    tooltip: "\u067E\u06CC\u0634 \u06AF\u0634\u0627\u06CC\u0634",
    iconName: $t.Clock
} : t === Mt.S && e === "S" ? {
    clockClass: "text-success",
    tooltip: "\u0645\u0639\u0627\u0645\u0644\u0627\u062A \u067E\u06CC\u0648\u0633\u062A\u0647",
    iconName: $t.Clock
} : t === Mt.C ? {
    clockClass: "text-danger",
    tooltip: "\u0628\u0633\u062A\u0647",
    iconName: $t.ClockError
} : {
    clockClass: "",
    tooltip: "",
    iconName: $t.Clock
} : {
    clockClass: "text-danger",
    tooltip: "\u0628\u0633\u062A\u0647",
    iconName: $t.ClockError
};
var Qf = e => {
    let t = "";
    for (let n = 0; n < e.length; n++) {
        let i = e.charCodeAt(n);
        if (i >= 1776 && i <= 1785) {
            let r = i - 1728;
            t = t + String.fromCharCode(r)
        } else if (i >= 1632 && i <= 1641) {
            let r = i - 1584;
            t = t + String.fromCharCode(r)
        } else
            t = t + String.fromCharCode(i)
    }
    return t
}
;
var Joe = e => e.toString().replace(/\d+/g, t => {
    let n = "";
    for (let i = 0, r = t.length; i < r; i++)
        n += String.fromCharCode(t.charCodeAt(i) + 1728);
    return n
}
)
  , Ml = () => {
    let e = new Date().getTime();
    return typeof performance < "u" && typeof performance.now == "function" && (e += performance.now()),
    "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, t => {
        let n = (e + Math.random() * 16) % 16 | 0;
        return e = Math.floor(e / 16),
        (t === "x" ? n : n & 3 | 8).toString(16)
    }
    )
}
;
var Zoe = (e, t) => {
    let n = [];
    for (let i = 0, r = e.length; i < r; i += t)
        n.push(e.substring(i, i + t));
    return n
}
  , hN = e => {
    let t = e.toLowerCase();
    return t = t.replace(/a/g, "\u0634"),
    t = t.replace(/b/g, "\u0630"),
    t = t.replace(/c/g, "\u0632"),
    t = t.replace(/d/g, "\u06CC"),
    t = t.replace(/e/g, "\u062B"),
    t = t.replace(/f/g, "\u0628"),
    t = t.replace(/g/g, "\u0644"),
    t = t.replace(/h/g, "\u0627"),
    t = t.replace(/i/g, "\u0647"),
    t = t.replace(/j/g, "\u062A"),
    t = t.replace(/k/g, "\u0646"),
    t = t.replace(/l/g, "\u0645"),
    t = t.replace(/m/g, "\u067E"),
    t = t.replace(/n/g, "\u062F"),
    t = t.replace(/o/g, "\u062E"),
    t = t.replace(/p/g, "\u062D"),
    t = t.replace(/q/g, "\u0636"),
    t = t.replace(/r/g, "\u0642"),
    t = t.replace(/s/g, "\u0633"),
    t = t.replace(/t/g, "\u0641"),
    t = t.replace(/u/g, "\u0639"),
    t = t.replace(/v/g, "\u0631"),
    t = t.replace(/w/g, "\u0635"),
    t = t.replace(/x/g, "\u0637"),
    t = t.replace(/y/g, "\u063A"),
    t = t.replace(/z/g, "\u0638"),
    t = t.replace(/\[/g, "\u062C"),
    t = t.replace(/\]/g, "\u0686"),
    t = t.replace(/;/g, "\u06A9"),
    t = t.replace(/'/g, "\u06AF"),
    t = t.replace(/,/g, "\u0648"),
    t = t.replace(/A/g, "\u0624"),
    t = t.replace(/S/g, "\u0626"),
    t = t.replace(/G/g, "\u0623"),
    t = t.replace(/H/g, "\u0622"),
    t = t.replace(/X/g, "\u0637"),
    t = t.replace(/C/g, "\u0698"),
    t = t.replace(/N/g, "\u0654"),
    t = t.replace(/M/g, "\u0621"),
    t = t.replace(/\\/g, "\u067E"),
    t = t.replace(/`/g, "\u067E"),
    t
}
  , eae = e => {
    let t = e;
    return t = t.replace(new RegExp("\u06F0","g"), "0"),
    t = t.replace(new RegExp("\u06F1","g"), "1"),
    t = t.replace(new RegExp("\u06F2","g"), "2"),
    t = t.replace(new RegExp("\u06F3","g"), "3"),
    t = t.replace(new RegExp("\u06F4","g"), "4"),
    t = t.replace(new RegExp("\u06F5","g"), "5"),
    t = t.replace(new RegExp("\u06F6","g"), "6"),
    t = t.replace(new RegExp("\u06F7","g"), "7"),
    t = t.replace(new RegExp("\u06F8","g"), "8"),
    t = t.replace(new RegExp("\u06F9","g"), "9"),
    t
}
  , dN = (e, t=!1) => {
    let n = e;
    return n = n.replace(new RegExp("\u064A","g"), "\u06CC"),
    n = n.replace(new RegExp("\u0643","g"), "\u06A9"),
    t && (n = hN(n)),
    n
}
;
var tae = e => /[0-9]/.test(e)
  , nae = e => {
    let t = "";
    if (e)
        for (let n = 0; n < e.length; n++)
            t += e.charCodeAt(n);
    return +("0." + t.slice(-10))
}
  , iae = e => /^[A-Za-z0-9:.,% ]*$/.test(e)
  , rae = e => /^[-0-9-:%. ]*$/.test(dN(e).replaceAll("\u200C", ""));
String.prototype.withSeparator = function(e=",") {
    return this.replace(/\B(?=(\d{3})+(?!\d))/g, e)
}
;
var Ti = p5(o_());
var Sr = ( () => {
    let t = class t {
        static ticksToDate(i) {
            if (!i)
                return null;
            let r = +i / 1e4
              , s = Math.abs(new Date(0,0,1).setFullYear(1));
            return new Date(r - s)
        }
        static getPersianMonth(i) {
            let s = (0,
            Ti.default)(new Date(i)).locale("fa").format("YYYY/M/D")
              , o = "";
            switch (parseInt(s.substr(5, 2).replace("/", ""))) {
            case 1:
                o = "\u0641\u0631\u0648\u0631\u062F\u06CC\u0646";
                break;
            case 2:
                o = "\u0627\u0631\u062F\u06CC\u0628\u0647\u0634\u062A";
                break;
            case 3:
                o = "\u062E\u0631\u062F\u0627\u062F";
                break;
            case 4:
                o = "\u062A\u06CC\u0631";
                break;
            case 5:
                o = "\u0645\u0631\u062F\u0627\u062F";
                break;
            case 6:
                o = "\u0634\u0647\u0631\u06CC\u0648\u0631";
                break;
            case 7:
                o = "\u0645\u0647\u0631";
                break;
            case 8:
                o = "\u0622\u0628\u0627\u0646";
                break;
            case 9:
                o = "\u0622\u0630\u0631";
                break;
            case 10:
                o = "\u062F\u06CC";
                break;
            case 11:
                o = "\u0628\u0647\u0645\u0646";
                break;
            case 12:
                o = "\u0627\u0633\u0641\u0646\u062F";
                break
            }
            return o
        }
        static getPersianDayOfWeek(i) {
            return ["\u06CC\u06A9\u0634\u0646\u0628\u0647", "\u062F\u0648\u0634\u0646\u0628\u0647", "\u0633\u0647 \u0634\u0646\u0628\u0647", "\u0686\u0647\u0627\u0631\u0634\u0646\u0628\u0647", "\u067E\u0646\u062C \u0634\u0646\u0628\u0647", "\u062C\u0645\u0639\u0647", "\u0634\u0646\u0628\u0647"][new Date(i).getDay()]
        }
        static getJDayOfMonth(i) {
            let s = (0,
            Ti.default)(new Date(i)).locale("fa").format("YYYY/M/D");
            return s.substring(s.lastIndexOf("/") + 1)
        }
        static getJDateLongWithDay(i, r=!0) {
            let o = ["\u06CC\u06A9\u0634\u0646\u0628\u0647", "\u062F\u0648\u0634\u0646\u0628\u0647", "\u0633\u0647 \u0634\u0646\u0628\u0647", "\u0686\u0647\u0627\u0631\u0634\u0646\u0628\u0647", "\u067E\u0646\u062C \u0634\u0646\u0628\u0647", "\u062C\u0645\u0639\u0647", "\u0634\u0646\u0628\u0647"][new Date(i).getDay()]
              , c = (0,
            Ti.default)(new Date(i)).locale("fa").format("YYYY/M/D")
              , l = "";
            switch (parseInt(c.substr(5, 2).replace("/", ""))) {
            case 1:
                l = "\u0641\u0631\u0648\u0631\u062F\u06CC\u0646";
                break;
            case 2:
                l = "\u0627\u0631\u062F\u06CC\u0628\u0647\u0634\u062A";
                break;
            case 3:
                l = "\u062E\u0631\u062F\u0627\u062F";
                break;
            case 4:
                l = "\u062A\u06CC\u0631";
                break;
            case 5:
                l = "\u0645\u0631\u062F\u0627\u062F";
                break;
            case 6:
                l = "\u0634\u0647\u0631\u06CC\u0648\u0631";
                break;
            case 7:
                l = "\u0645\u0647\u0631";
                break;
            case 8:
                l = "\u0622\u0628\u0627\u0646";
                break;
            case 9:
                l = "\u0622\u0630\u0631";
                break;
            case 10:
                l = "\u062F\u06CC";
                break;
            case 11:
                l = "\u0628\u0647\u0645\u0646";
                break;
            case 12:
                l = "\u0627\u0633\u0641\u0646\u062F";
                break
            }
            let u = new Date;
            u.setDate(u.getDate() + 1),
            u.setHours(0, 0, 0, 0);
            let h = new Date;
            h.setDate(h.getDate()),
            h.setHours(0, 0, 0, 0);
            let d = new Date(i).setHours(0, 0, 0, 0);
            return r && (d.valueOf() === u.valueOf() && (o = "\u0641\u0631\u062F\u0627"),
            d.valueOf() === h.valueOf() && (o = "\u0627\u0645\u0631\u0648\u0632")),
            o + " - " + c.substring(c.lastIndexOf("/") + 1) + " " + l
        }
        static getJDateLongString(i, r=!0) {
            let s = t.getJDateLongWithDay(i, r)
              , a = (0,
            Ti.default)(new Date(i)).locale("fa").format("YYYY/M/D");
            return s + " " + a.substr(0, 4)
        }
        static isValidDate(i) {
            return new Date(i).getFullYear() > 1800
        }
        static getformatTime(i) {
            let r = (c, l) => ("000" + c).slice(-l)
              , s = Math.floor(i / 3600)
              , o = Math.floor(i % 3600 / 60)
              , a = i % 60;
            return `${s ? r(s, 2) + ":" : ""}${r(o, 2)}:${r(a, 2)}`
        }
        static calculateShamsiDateDifference(i, r) {
            let s = this.getJDate(i, "YYYY/MM/DD")
              , o = this.getJDate(r, "YYYY/MM/DD")
              , a = +o.slice(0, 4) - +s.slice(0, 4)
              , c = +o.slice(5, 7) - +s.slice(5, 7)
              , l = +o.slice(8, 10) - +s.slice(8, 10);
            return l < 0 && (c -= 1,
            l += Ti.default.jDaysInMonth(+o.slice(0, 4), +o.slice(5, 7) - 1)),
            c < 0 && (a -= 1,
            c += 12),
            {
                years: a,
                months: c,
                days: l
            }
        }
    }
    ;
    t.getJDayOfWeek = i => i < 0 || i > 6 ? "" : ["\u06CC\u06A9\u0634\u0646\u0628\u0647", "\u062F\u0648\u0634\u0646\u0628\u0647", "\u0633\u0647 \u0634\u0646\u0628\u0647", "\u0686\u0647\u0627\u0631\u0634\u0646\u0628\u0647", "\u067E\u0646\u062C \u0634\u0646\u0628\u0647", "\u062C\u0645\u0639\u0647", "\u0634\u0646\u0628\u0647"][i],
    t.isCurrentDateInDateRange = (i, r, s, o, a, c) => {
        let l = Ti.default.from(i, "fa", "YYYY/M/D").toDate();
        l.setHours(s, o, 0, 0);
        let u = Ti.default.from(r, "fa", "YYYY/M/D").toDate();
        u.setHours(a, c, 0, 0);
        let h = new Date;
        return l <= h && u >= h
    }
    ,
    t.isCurrentTimeInTimeRange = (i, r, s, o, a, c) => {
        let l = Ti.default.from(i, "fa", "YYYY/M/D").toDate()
          , u = Ti.default.from(i, "fa", "YYYY/M/D").toDate()
          , h = new Date;
        if (!r)
            return l.setHours(s, o, 0, 0),
            u.setHours(a, c, 59, 59),
            l <= h && u >= h;
        let d = Ti.default.from(r, "fa", "YYYY/M/D").toDate();
        if (l.setHours(s, o, 0, 0),
        d.setHours(a, c, 59, 59),
        l > h || d < h)
            return !1;
        let f = new Date;
        f.setHours(s, o, 0, 0);
        let g = new Date;
        return g.setHours(a, c, 59, 59),
        f <= h && g >= h
    }
    ,
    t.convertFormattedNumberToLocaleDate = i => new Date(i.replace(/^(\d{4})(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)$/, "$4:$5:$6 $2/$3/$1")).toLocaleString(),
    t.getJDate = (i, r) => i && t.isValidDate(i) ? (0,
    Ti.default)(i).locale("fa").format(r ?? "YYYY/M/D") : "",
    t.getDateWithTimeFromNumber = (i, r=!0) => {
        if (i) {
            let s = +i.slice(0, 4)
              , o = +i.slice(4, 6)
              , a = +i.slice(6, 8)
              , c = r ? i.slice(8, 10) : "0"
              , l = r ? i.slice(10, 12) : "0"
              , u = r ? i.slice(12, 14) : "0";
            return new Date(`${s}/${o}/${a} ${c}:${l}:${u}`)
        }
        return null
    }
    ,
    t.getJDateWithTimeFromNumber = i => {
        if (i) {
            let r = +i.slice(0, 4)
              , s = +i.slice(4, 6)
              , o = +i.slice(6, 8)
              , a = i.slice(8, 10)
              , c = i.slice(10, 12)
              , l = i.slice(12, 14)
              , u = new Date;
            return u.setUTCFullYear(r, s - 1, o),
            t.getJDate(u) + "  " + a + ":" + c + ":" + l
        }
        return null
    }
    ,
    t.getJDateWithTimeFromNumberSetTimeZone = (i, r) => {
        if (i) {
            let s = -new Date().getTimezoneOffset()
              , o = +i.slice(0, 4)
              , a = +i.slice(4, 6)
              , c = +i.slice(6, 8)
              , l = i.slice(8, 10)
              , u = i.slice(10, 12)
              , h = i.slice(12, 14)
              , d = new Date;
            d.setUTCFullYear(o, a - 1, c),
            d.setHours(+l),
            d.setMinutes(+u),
            d.setSeconds(+h);
            let f = (0,
            Ti.default)(d).add(s, "m").toDate();
            return (r ? "" : t.getJDate(f) + "  ") + ("0" + f.getHours()).slice(-2) + ":" + ("0" + f.getMinutes()).slice(-2) + ":" + ("0" + f.getSeconds()).slice(-2)
        }
        return null
    }
    ,
    t.getTimeFromNumber = i => {
        if (i) {
            let r = i.slice(8, 10)
              , s = i.slice(10, 12)
              , o = i.slice(12, 14);
            return r + ":" + s + ":" + o
        }
        return null
    }
    ,
    t.getFormattedJDate = i => i && t.isValidDate(i) ? (0,
    Ti.default)(i).locale("fa").format("YYYY/MM/DD") : null,
    t.getFormattedJTime = i => i && t.isValidDate(i) ? (0,
    Ti.default)(i).locale("fa").format("HH:mm:ss") : null,
    t.getFormattedJDateTime = i => i && t.isValidDate(i) ? (0,
    Ti.default)(i).locale("fa").format("HH:mm:ss YYYY/MM/DD") : null,
    t.jDateToDate = i => {
        if (i) {
            i = Qf(i);
            let r = Ti.default.from(i, "fa", "YYYY/MM/D").locale("en").format("YYYY-MM-DD");
            return new Date(r)
        }
        return null
    }
    ,
    t.getFormattedDate = i => {
        let r = i.getFullYear().toString()
          , s = (i.getMonth() + 1).toString()
          , o = i.getDate().toString();
        return o.length === 1 && (o = "0" + o),
        s.length === 1 && (s = "0" + s),
        r + "-" + s + "-" + o
    }
    ,
    t.gregorianToJalali = (i, r, s) => {
        let o = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], a = [31, 31, 31, 31, 31, 31, 30, 30, 30, 30, 30, 29], c = ["\u06CC\u06A9 \u0634\u0646\u0628\u0647", "\u062F\u0648 \u0634\u0646\u0628\u0647", "\u0633\u0647 \u0634\u0646\u0628\u0647", "\u0686\u0647\u0627\u0631 \u0634\u0646\u0628\u0647", "\u067E\u0646\u062C \u0634\u0646\u0628\u0647", "\u062C\u0645\u0639\u0647", "\u0634\u0646\u0628\u0647"], l, u, h, d, f = i - 1600, g = r - 1, p = s - 1, v = 365 * f + Math.floor((f + 3) / 4) - Math.floor((f + 99) / 100) + Math.floor((f + 399) / 400);
        for (l = 0; l < g; ++l)
            v += o[l];
        for (g > 1 && (f % 4 === 0 && f % 100 !== 0 || f % 400 === 0) && ++v,
        v += p,
        u = v - 79,
        h = Math.floor(u / 12053),
        u %= 12053,
        d = 979 + 33 * h + 4 * Math.floor(u / 1461),
        u %= 1461,
        u >= 366 && (d += Math.floor((u - 1) / 365),
        u = (u - 1) % 365),
        l = 0; l < 11 && u >= a[l]; ++l)
            u -= a[l];
        let b = new Date(i,r - 1,s);
        return `${c[b.getDay()]}  ${d}/${l + 1}/${u + 1}`
    }
    ,
    t.utcToTehran = (i, r) => i + r + 36e5 * 3.5,
    t.persianDateToGoDate = i => {
        if (!i)
            return i;
        let[r,s,o] = i.split(" ")[0].split("/").map(Number);
        return Ti.default.utc(`${r}/${s}/${o}`, "jYYYY/jMM/jDD").startOf("day").toISOString()
    }
    ,
    t.daysBetweenTwoDates = (i, r) => (r.setHours(0),
    r.setMinutes(0),
    r.setSeconds(0),
    i.setHours(0),
    i.setMinutes(0),
    i.setSeconds(0),
    Math.ceil((+r.setHours(0) - +i) / (1e3 * 60 * 60 * 24))),
    t.georgianDateToShamsi = i => Intl.DateTimeFormat("fa-IR", {
        year: "numeric",
        month: "numeric",
        day: "numeric",
        weekday: "short"
    }).format(i),
    t.getDifferTimestampInSeconds = i => {
        let r = i;
        return (new Date().getTime() - r) / 1e3
    }
    ;
    let e = t;
    return e
}
)();
var Jf = "Android"
  , vg = "iOS"
  , zb = "unknown"
  , Xb = "Desktop"
  , lae = "easyChartLayout";
var uae = "myAdjustmentType";
var hae = new Date(2006,2,21)
  , dae = 15
  , Kb = 825
  , _g = 1500;
var Yb = 824;
var kl = class {
    constructor(t, n) {
        this.desktopValidVersion = t,
        this.mobileValidVersion = n
    }
    isValid(t, n) {
        return this.checkBrowserVersion(n, t ? this.mobileValidVersion : this.desktopValidVersion)
    }
    checkBrowserVersion(t, n) {
        return t >= n
    }
}
  , yg = new Map([["chrome", new kl(72,71)], ["edge", new kl(79,79)], ["firefox", new kl(69,79)], ["opera", new kl(58,50)], ["samsung", new kl(10,10)]]);
var Qb = [{
    browserName: "chrome",
    linksInfo: [{
        os: "android",
        icon: "assets/images/bazzar.svg",
        link: "https://cafebazaar.ir/app/com.android.chrome",
        linkTitle: "\u0644\u06CC\u0646\u06A9 \u0628\u0627\u0632\u0627\u0631"
    }, {
        os: "android",
        icon: "assets/images/google-play.svg",
        link: "https://play.google.com/store/apps/details?id=com.android.chrome&hl=en_IN&pli=1",
        linkTitle: "\u0644\u06CC\u0646\u06A9 \u06AF\u0648\u06AF\u0644"
    }, {
        os: "ios",
        icon: "assets/images/apple.svg",
        link: "https://apps.apple.com/us/app/google-chrome/id535886823",
        linkTitle: "\u0627\u067E \u0627\u0633\u062A\u0648\u0631"
    }, {
        os: "ios",
        icon: "assets/images/sibche.svg",
        link: "https://sibche.com/applications/google-chrome",
        linkTitle: "\u0633\u06CC\u0628 \u0686"
    }, {
        os: "desktop",
        icon: "assets/images/link.svg",
        link: "https://www.google.com/chrome/",
        linkTitle: "\u062F\u0627\u0646\u0644\u0648\u062F \u0645\u0631\u0648\u0631\u06AF\u0631"
    }]
}, {
    browserName: "safari",
    linksInfo: [{
        os: "ios",
        icon: "assets/images/apple.svg",
        link: "https://apps.apple.com/us/app/safari/id1146562112",
        linkTitle: "\u0627\u067E \u0627\u0633\u062A\u0648\u0631"
    }, {
        os: "desktop",
        icon: "assets/images/link.svg",
        link: "https://apps.apple.com/us/app/safari/id1146562112",
        linkTitle: "\u062F\u0627\u0646\u0644\u0648\u062F \u0645\u0631\u0648\u0631\u06AF\u0631"
    }]
}, {
    browserName: "firefox",
    linksInfo: [{
        os: "ios",
        icon: "assets/images/apple.svg",
        link: "https://apps.apple.com/us/app/firefox-private-safe-browser/id989804926",
        linkTitle: "\u0627\u067E \u0627\u0633\u062A\u0648\u0631"
    }, {
        os: "android",
        icon: "assets/images/bazzar.svg",
        link: "https://cafebazaar.ir/app/org.mozilla.firefox",
        linkTitle: "\u06A9\u0627\u0641\u0647 \u0628\u0627\u0632\u0627\u0631"
    }, {
        os: "android",
        icon: "assets/images/google-play.svg",
        link: "https://play.google.com/store/apps/details?id=org.mozilla.firefox&hl=en&gl=US",
        linkTitle: "\u06AF\u0648\u06AF\u0644 \u067E\u0644\u06CC"
    }, {
        os: "desktop",
        icon: "assets/images/link.svg",
        link: "https://www.mozilla.org/en-US/firefox/new/",
        linkTitle: "\u062F\u0627\u0646\u0644\u0648\u062F \u0645\u0631\u0648\u0631\u06AF\u0631"
    }]
}, {
    browserName: "edge",
    linksInfo: [{
        os: "ios",
        icon: "assets/images/apple.svg",
        link: "https://apps.apple.com/us/app/microsoft-edge-web-browser/id1288723196",
        linkTitle: "\u0627\u067E \u0627\u0633\u062A\u0648\u0631"
    }, {
        os: "android",
        icon: "assets/images/bazzar.svg",
        link: "https://cafebazaar.ir/app/com.microsoft.emmx",
        linkTitle: "\u06A9\u0627\u0641\u0647 \u0628\u0627\u0632\u0627\u0631"
    }, {
        os: "desktop",
        icon: "assets/images/link.svg",
        link: "https://www.microsoft.com/en-us/edge?form=MA13FJ&exp=e00",
        linkTitle: "\u062F\u0627\u0646\u0644\u0648\u062F \u0645\u0631\u0648\u0631\u06AF\u0631"
    }]
}, {
    browserName: "opera",
    linksInfo: [{
        os: "ios",
        icon: "assets/images/apple.svg",
        link: "https://apps.apple.com/us/app/opera-browser-private-vpn/id1411869974",
        linkTitle: "\u0627\u067E \u0627\u0633\u062A\u0648\u0631"
    }, {
        os: "android",
        icon: "assets/images/google-play.svg",
        link: "https://play.google.com/store/apps/details?id=com.opera.browser&hl=en&gl=US",
        linkTitle: "\u06AF\u0648\u06AF\u0644 \u067E\u0644\u06CC"
    }, {
        os: "desktop",
        icon: "assets/images/link.svg",
        link: "https://www.opera.com/download",
        linkTitle: "\u062F\u0627\u0646\u0644\u0648\u062F \u0645\u0631\u0648\u0631\u06AF\u0631"
    }]
}, {
    browserName: "samsung",
    linksInfo: [{
        os: "android",
        icon: "assets/images/bazzar.svg",
        link: "https://cafebazaar.ir/app/com.sec.android.app.sbrowser",
        linkTitle: "\u06A9\u0627\u0641\u0647 \u0628\u0627\u0632\u0627\u0631"
    }, {
        os: "android",
        icon: "assets/images/google-play.svg",
        link: "https://play.google.com/store/search?q=samsung%20browser&c=apps&hl=en&gl=US",
        linkTitle: "\u06AF\u0648\u06AF\u0644 \u067E\u0644\u06CC"
    }]
}];
var mae = e => {
    let t = i_(Math.floor(e / 10)).replace("\u0628\u06CC\u0644\u06CC\u0648\u0646", "\u0647\u0645\u062A") + " \u062A\u0648\u0645\u0627\u0646";
    return t?.split(" ")?.length === 3 && t.split(" ").at(1) === "\u0647\u0645\u062A" ? t.replace("\u062A\u0648\u0645\u0627\u0646", "") : t
}
;
var vae = e => {
    let t = "";
    return e = Math.round(e),
    e < 1e6 ? t = (+e).toLocaleString() : e >= 1e6 && e < 1e9 ? t = `${(Math.ceil(e / 1e3) / 1e3).toString()} M` : t = `${(Math.ceil(e / 1e6) / 1e3).toString()} B`,
    t
}
  , _ae = (e, t) => t > 0 ? +(e / t * 100).toFixed(1) : 0;
var yae = (e, t=0) => {
    let n = ""
      , i = Math.abs(Math.floor(e));
    return e == null ? "" : (t == 0 ? i < 1e9 ? n = i.toLocaleString() : n = `${(i / 1e6).toLocaleString()} M` : t == 1 && (i < 1e6 ? n = (+i).toLocaleString() : i >= 1e6 && i < 1e9 ? n = `${(Math.ceil(i / 1e3) / 1e3).toLocaleString()} M` : n = `${(Math.ceil(i / 1e6) / 1e3).toLocaleString()} B`),
    `${e < 0 ? "-" : ""}${n}`)
}
;
function bae(e, t) {
    return Math.floor(Math.random() * (t - e + 1) + e)
}
function Sae(e) {
    return !e && e !== 0
}
var Oae = e => {
    navigator.clipboard.writeText(e).then(function() {}, function() {})
}
  , Zf = e => sn(window, "unload").subscribe( () => {
    e()
}
);
function wc(e, t=100) {
    let n = li(t).pipe(Ge( () => e()), gr( () => n.unsubscribe())).subscribe()
}
var Pae = e => z(No).params.pipe(mt(t => t[e]), $e(t => t[e]))
  , Mae = () => {
    window && (window.console.log = () => null,
    window.console.assert = () => null,
    window.console.clear = () => null,
    window.console.count = () => null,
    window.console.countReset = () => null,
    window.console.debug = () => null,
    window.console.dir = () => null,
    window.console.error = () => null,
    window.console.group = () => null,
    window.console.groupCollapsed = () => null,
    window.console.groupEnd = () => null,
    window.console.info = () => null,
    window.console.table = () => null,
    window.console.time = () => null,
    window.console.timeEnd = () => null,
    window.console.timeStamp = () => null,
    window.console.trace = () => null,
    window.console.warn = () => null)
}
;
var Iae = e => Jb(e) || Zb(e)
  , Jb = e => [y.BuyOptionTse, y.BuyOptionIfb].includes(e)
  , Zb = e => [y.SellOptionTse, y.SellOptionIfb].includes(e)
  , wa = function(e) {
    return e.ITM = "ITM",
    e.OTM = "OTM",
    e.ATM = "ATM",
    e.Unknown = "-",
    e
}(wa || {});
function Rae(e, t, n) {
    if (Jb(e))
        return t < n ? wa.ITM : t > n ? wa.OTM : t == n ? wa.ATM : wa.Unknown;
    if (Zb(e))
        return t < n ? wa.OTM : t > n ? wa.ITM : t == n ? wa.ATM : wa.Unknown
}
var Yt = function(e) {
    return e[e.DEV = 0] = "DEV",
    e[e.STAGE = 1] = "STAGE",
    e[e.PROD = 2] = "PROD",
    e[e.PEN = 3] = "PEN",
    e[e.Feature = 4] = "Feature",
    e
}(Yt || {});
function Cc(e, t) {
    return {
        authority: e === Yt.STAGE ? "https://account-stg-dnd.emofid.com" : "https://login.emofid.com",
        client_id: e === Yt.PROD ? "easy_pkce" : "easy_pkce_test",
        redirect_uri: `${t}/auth-callback`,
        post_logout_redirect_uri: t,
        response_type: "code",
        scope: "easy2_api mts_api openid profile",
        filterProtocolClaims: !0,
        loadUserInfo: !1,
        silent_redirect_uri: `${t}/silent-refresh.html`
    }
}
var xn = class {
}
;
var Ec = {
    appUrl: "https://d.easytrader.ir",
    version: "2.6.0",
    build: "17972"
};
var pu = ve(C({}, Ec), {
    env: Yt.PROD,
    setting: {
        mtsPath: "https://api-mts.orbis.easytrader.ir/",
        lsUrl: "https://ls.easytrader.ir/",
        marketSheetLsUrl: ["https://ls-marketsheet.easytrader.ir/"],
        appLogApiPath: "https://stage-applogapi.easytrader.ir/api/",
        dataTracking: !1,
        tradingViewStorageURL: "https://api-mts.orbis.easytrader.ir/saveload",
        rocketChat: !0,
        appSettingsUrl: "https://api-mts.orbis.easytrader.ir/settings/",
        easy2ReferralUrl: "https://d.easytrader.emofid.com"
    },
    sentry: {
        dsn: "https://81e2e944aea3427fbd3d051e84c2bec2@sapi.emofid.com/50",
        debug: !1,
        environment: "d-client.prod",
        maxBreadcrumbs: 100,
        attachStacktrace: !0,
        tracesSampleRate: 1,
        breadcrumb: {
            console: !1,
            sentry: !1,
            dom: !1,
            history: !1,
            fetch: !1,
            xhr: !1
        },
        error: {
            error: !0,
            unhandled: !0
        }
    },
    unleash: {
        url: "https://unleash-edge.orbis.easytrader.ir/api/frontend",
        appName: "default",
        server: "default:production.0e68018c80f689af9e553daac3555bc646ddf639cf1774b8505dc4e2",
        refreshInterval: 0,
        environment: "production"
    },
    postHog: {
        url: "https://phog-api.emofid.com",
        _p: "phc_AFnureGmuRsrF10KMGzsgk2sAZIcCGduwuaiGW7X2Pr",
        active: !1
    },
    chatBot: {
        url: "https://chatbot.emofid.com/livechat",
        isActive: !0
    },
    oidcSettings: Cc(Yt.PROD, Ec.appUrl)
});
var Il = ve(C({}, Ec), {
    env: Yt.STAGE,
    setting: {
        mtsPath: "https://stage-api-mts.easytrader.ir/",
        appLogApiPath: "https://stage-applogapi.easytrader.ir/api/",
        lsUrl: "https://stage-ls.easytrader.ir",
        marketSheetLsUrl: ["https://stage-ls-marketsheet1.easytrader.ir", "https://stage-ls-marketsheet2.easytrader.ir"],
        dataTracking: !1,
        tradingViewStorageURL: "https://stage-api-mts.easytrader.ir/saveload",
        rocketChat: !0,
        appSettingsUrl: "https://stage-api-mts.easytrader.ir/settings/",
        easy2ReferralUrl: "https://dstage.emofid.com"
    },
    sentry: {
        dsn: "https://81e2e944aea3427fbd3d051e84c2bec2@sapi.emofid.com/50",
        debug: !1,
        environment: "d-client.local",
        maxBreadcrumbs: 100,
        attachStacktrace: !0,
        tracesSampleRate: 1,
        breadcrumb: {
            console: !1,
            sentry: !1,
            dom: !1,
            history: !1,
            fetch: !1,
            xhr: !1
        },
        error: {
            error: !0,
            unhandled: !0
        }
    },
    unleash: {
        url: "https://unleash-edge.orbis.easytrader.ir/api/frontend",
        appName: "default",
        server: "default:development.05fae8107ad0ba6a1833dec208ac59215149d326a1490b94a456a84b",
        refreshInterval: 0,
        environment: "development"
    },
    postHog: {
        url: "https://phog-api.emofid.com",
        _p: "phc_AFnureGmuRsrF10KMGzsgk2sAZIcCGduwuaiGW7X2Pr",
        active: !1
    },
    chatBot: {
        url: "https://stage-chatbot.emofid.com/livechat",
        isActive: !0
    },
    oidcSettings: Cc(Yt.STAGE, Ec.appUrl)
});
var qae = ve(C({}, Il), {
    unleash: ve(C({}, Il.unleash), {
        environment: "production"
    })
});
var eS = "http://localhost:4200"
  , Jae = ve(C({}, pu), {
    version: "2.5.0",
    build: "0.0.0",
    env: Yt.DEV,
    chatBot: ve(C({}, pu.chatBot), {
        isActive: !1
    }),
    appUrl: eS,
    oidcSettings: Cc(Yt.DEV, eS),
    unleash: C({}, Il.unleash)
});
var sce = ve(C({}, pu), {
    chatBot: ve(C({}, pu.chatBot), {
        isActive: !1
    }),
    env: Yt.Feature,
    unleash: C({}, Il.unleash),
    oidcSettings: Cc(Yt.Feature, Ec.appUrl)
});
function vce(e, t) {
    return ue(this, null, function*() {
        let i = yield ue(this, null, function*() {
            let o = `${e.setting.mtsPath}boot/api/build-number?deviceType=${t}`
              , a = yield fetch(o);
            return a.ok ? yield a.json() : null
        })
          , r = e.build;
        if (console.table({
            buildNumber: r
        }),
        console.table(i),
        r && (i?.obsoleteBuildNumbers.includes(r) || +r < +(i?.minimumRequiredVersion ?? 1)) && "serviceWorker"in navigator && e.env !== Yt.DEV) {
            let o = yield navigator.serviceWorker.getRegistrations();
            for (let a of o)
                yield a.unregister();
            window.location.reload()
        }
    })
}
var gu = ( () => {
    let t = class t {
    }
    ;
    t.code = {
        TEDPIX: "IRX6XTPI0006",
        Hamvazn: "IRX6XTPI0026",
        IFX: "IRXZXOCI0006",
        Sekke: "IRK1K00197C1",
        Ayar: "IRTKMOFD0001",
        Foolad: "IRO1FOLD0001"
    };
    let e = t;
    return e
}
)();
var Id = {
    delayToRemoveAfterClose: 0,
    delayToActiveAfterOpen: 0
}
  , Sg = 10;
var Rd = function(e) {
    return e.crm = "crm/api/",
    e.oms = "core/api/",
    e.option = "option/api/",
    e.algo = "algo/api/order",
    e.algoHistory = "algo/api/order-history",
    e.symbol = "symbols/api/",
    e.easy = "easy/api/",
    e.ipg = "ipg/api/",
    e.portfolio = "portfolio/api/",
    e.marketSheet = "ms/api/MarketSheet/",
    e.fund = "fund/api/",
    e.wallet = "mofidcard/api/",
    e.tbs = "tbs/api/",
    e.assets = "assetmodule/api/",
    e.contract = "contract/api/",
    e.marketReport = "marketreport/api/",
    e
}(Rd || {});
var Dd = function(e) {
    return e.Escape = "escape",
    e.F1 = "f1",
    e.F2 = "f2",
    e.F3 = "f3",
    e.F4 = "f4",
    e.F9 = "f9",
    e.Plus = "+",
    e.Minus = "-",
    e
}(Dd || {})
  , Nd = function(e) {
    return e[e.Escape = 27] = "Escape",
    e[e.F1 = 112] = "F1",
    e[e.F2 = 113] = "F2",
    e[e.F3 = 114] = "F3",
    e[e.F4 = 115] = "F4",
    e[e.F9 = 120] = "F9",
    e[e.Plus = 43] = "Plus",
    e[e.Minus = 45] = "Minus",
    e[e.Enter = 13] = "Enter",
    e
}(Nd || {})
  , pN = function(e) {
    return e.Escape = "Escape",
    e.F1 = "F1",
    e.F2 = "F2",
    e.F3 = "F3",
    e.F4 = "F4",
    e.F9 = "F9",
    e.Plus = "Plus",
    e.Minus = "Minus",
    e.Enter = "Enter",
    e
}(pN || {});
var Qt = function(e) {
    return e[e.Details = 0] = "Details",
    e[e.Orders = 1] = "Orders",
    e[e.Messages = 2] = "Messages",
    e[e.SameGroup = 3] = "SameGroup",
    e[e.Calculator = 4] = "Calculator",
    e[e.OptionChain = 5] = "OptionChain",
    e[e.Analytics = 6] = "Analytics",
    e[e.CorporateActions = 7] = "CorporateActions",
    e[e.EasyChart = 8] = "EasyChart",
    e[e.Notes = 9] = "Notes",
    e[e.ConditionalAlerts = 10] = "ConditionalAlerts",
    e
}(Qt || {})
  , nt = class {
    constructor(t) {
        this.marketUnit = t,
        this.AllTabs = {
            [Qt.Details]: {
                htmlId: "symbol-detail-tab-details",
                dataCy: "symbol-detail-tab-details",
                name: "details",
                title: "\u062C\u0632\u0626\u06CC\u0627\u062A",
                icon: "symbol-detail",
                iconFill: "symbol-detail-fill",
                tab: Qt.Details
            },
            [Qt.Orders]: {
                title: "\u0633\u0641\u0627\u0631\u0634\u200C\u0647\u0627",
                htmlId: "symbol-detail-tab-orders",
                dataCy: "symbol-detail-tab-orders",
                name: "orders",
                icon: "basket",
                iconFill: "basket-fill",
                tab: Qt.Orders
            },
            [Qt.Messages]: {
                title: "\u067E\u06CC\u0627\u0645\u200C\u0647\u0627",
                htmlId: "symbol-detail-tab-messages",
                dataCy: "symbol-detail-tab-messages",
                name: "messages",
                icon: "comment-load",
                iconFill: "comment-load-fill",
                hasBadge: !0,
                tab: Qt.Messages
            },
            [Qt.SameGroup]: {
                title: "\u0647\u0645\u06AF\u0631\u0648\u0647\u06CC",
                htmlId: "symbol-detail-tab-sameGroup",
                dataCy: "symbol-detail-tab-sameGroup",
                name: "sameGroup",
                icon: "same-industry",
                iconFill: "same-industry-fill",
                tab: Qt.SameGroup
            },
            [Qt.Analytics]: {
                title: "\u0627\u0631\u0632\u06CC\u0627\u0628\u06CC \u0646\u0645\u0627\u062F",
                htmlId: "symbol-detail-tab-analytics",
                dataCy: "symbol-detail-tab-analytics",
                name: "analytics",
                icon: "symbol-check",
                newBadge: !1,
                tab: Qt.Analytics
            },
            [Qt.CorporateActions]: {
                title: "\u0627\u0641\u0632\u0627\u06CC\u0634 \u0633\u0631\u0645\u0627\u06CC\u0647 \u0648 \u0645\u062C\u0627\u0645\u0639",
                htmlId: "symbol-detail-tab-corporateActions",
                dataCy: "symbol-detail-tab-corporateActions",
                name: "corporateActions",
                icon: "bank",
                newBadge: !1,
                tab: Qt.CorporateActions
            },
            [Qt.EasyChart]: {
                title: "\u0627\u06CC\u0632\u06CC \u0686\u0627\u0631\u062A",
                htmlId: "symbol-detail-tab-easychart",
                dataCy: "symbol-detail-tab-easychart",
                name: "easychart",
                icon: "easychart",
                tab: Qt.EasyChart
            },
            [Qt.Notes]: {
                title: "\u06CC\u0627\u062F\u062F\u0627\u0634\u062A",
                htmlId: "symbol-detail-tab-notes",
                dataCy: "symbol-detail-tab-notes",
                name: "notes",
                icon: "note",
                tab: Qt.Notes
            },
            [Qt.ConditionalAlerts]: {
                title: "\u0647\u0634\u062F\u0627\u0631 \u0634\u0631\u0637\u06CC",
                htmlId: "symbol-detail-tab-conditionalAlerts",
                dataCy: "symbol-detail-tab-conditionalAlerts",
                name: "conditionalAlerts",
                icon: "bell-ring",
                tab: Qt.ConditionalAlerts
            },
            [Qt.Calculator]: {
                title: "\u0645\u0627\u0634\u06CC\u0646 \u062D\u0633\u0627\u0628",
                htmlId: "symbol-detail-tab-calculator",
                dataCy: "symbol-detail-tab-calculator",
                name: "calculator",
                icon: "calculator",
                iconFill: "calculator-fill",
                tab: Qt.Calculator
            }
        },
        this.allowShowNAVvalueInSymbolHeader = !1,
        this.allowShowIndInstWidget = !0,
        this.allowAnalyticsTab = !1,
        this.allowEasyChartTab = !1,
        this.allowContractInfo = !1,
        this.allowBasicIsinInfo = !1,
        this.allowToShowIndividualTradingTrend = !1,
        this.allowToCallTechnicalAnalysis = !1,
        this.allowToCallFundamentalAnalysis = !1,
        this.allowToShowSameGroupSignSection = !1,
        this.allowToShowCalculatorAndNotToShowSameGroup = !1,
        this.allowCorporateActionsSection = !1,
        this.allowCalculator = !1,
        this.allowOptionChain = !1,
        this.allowToShowSymbolInfoSection = !0,
        this.allowToShowReturnChartSection = !0,
        this.showNewBadgeOnMoreTabs = !0,
        this.OptionMarketUnit = [y.BuyOptionIfb, y.BuyOptionTse, y.SellOptionIfb, y.SellOptionTse],
        this.NotAllowAnalyticsTabUnitCodes = [y.None, y.NapeyvastehSiman, y.GovahiBourseKala, y.Sekkeh, y.Rights, y.ETFFix, y.Maskan1, y.Maskan2, y.Tabaee, y.Ekhtiar, y.AtiSaham, y.AtiSabad, y.Fekri, y.Salaf, y.Bond1, y.Bond2, y.Bond3, y.Bond4, y.Bond5, y.Bond6, y.bond7, y.INDEX, y.NapeyvastehZaferan, y.NapeyvastehSekkeh, y.NapeyvastehShisheh, y.NapeyvastehMes, y.NapeyvastehSangAhan, y.NapeyvastehMilgerd, y.RightYellow, y.RightOrange, y.RightRed, y.RightsKoochak, ...this.OptionMarketUnit],
        this.AllowToShowIndividualTradingTrendUnitCodes = [y.Exchange, y.ETFStock, y.ETFFix, y.ETFMixed, y.ETFZaminSakhteman, y.ETFJasuraneh, y.SandoghKala, y.PayehYellow, y.PayehOrange, y.PayehRed, y.Koochak, y.EtfSector, y.ProMarket, y.EnergyETF, y.AgreedMarket],
        this.AllowToCallTechnicalAnalysisUnitCodes = [y.Exchange, y.ETFMixed, y.ETFStock, y.ETFZaminSakhteman, y.ETFJasuraneh, y.SandoghKala, y.NapeyvastehSiman, y.GovahiBourseKala, y.Sekkeh, y.Koochak, y.EtfInEtf, y.ETFKhosusi, y.EtfAmlak, y.Bond5, y.Bond6, y.INDEX, y.PayehYellow, y.PayehOrange, y.PayehRed, y.ProMarket, y.EnergyETF, y.AgreedMarket],
        this.AllowToCallFundamentalAnalysisUnitCodes = [y.Exchange, y.PayehYellow, y.PayehOrange, y.PayehRed, y.Koochak, y.ProMarket, y.AgreedMarket],
        this.NotAllowEasyChartTabUnitCodes = [y.Rights, y.NapeyvastehSiman, y.NapeyvastehZaferan, y.NapeyvastehSekkeh, y.Tabaee, y.AtiSabad, y.Fekri, y.Salaf, y.Bond1, y.Bond2, y.Bond3, y.Bond4, y.Bond5, y.Bond6, y.bond7, y.INDEX, y.NapeyvastehShisheh, y.NapeyvastehMes, y.NapeyvastehSangAhan, y.NapeyvastehMilgerd, y.RightYellow, y.RightOrange, y.RightRed, y.RightsKoochak],
        this.NotAllowSameGroupSignSectionUnitCodes = [y.Rights, y.ETFStock, y.ETFFix, y.ETFMixed, y.ETFZaminSakhteman, y.ETFJasuraneh, y.SandoghKala, y.NapeyvastehSiman, y.GovahiBourseKala, y.Sekkeh, y.Maskan1, y.Maskan2, y.Tabaee, y.Ekhtiar, y.AtiSaham, y.AtiSabad, y.Fekri, y.Koochak, y.Salaf, y.Bond1, y.Bond2, y.Bond3, y.Bond4, y.Bond5, y.Bond6, y.INDEX, y.bond7, y.EtfInEtf, y.EtfAmlak, y.NapeyvastehZaferan, y.NapeyvastehSekkeh, y.NapeyvastehShisheh, y.NapeyvastehMes, y.NapeyvastehSangAhan, y.NapeyvastehMilgerd, y.ETFKhosusi, y.RightYellow, y.RightOrange, y.RightRed, y.EtfSector, y.RightsKoochak, y.EnergyETF],
        this.NotAllowCorporateActionsSectionUnitCodes = [y.ETFStock, y.Rights, y.RightsKoochak, y.ETFFix, y.ETFMixed, y.ETFZaminSakhteman, y.ETFJasuraneh, y.SandoghKala, y.NapeyvastehSiman, y.GovahiBourseKala, y.Sekkeh, y.Maskan1, y.Maskan2, y.Tabaee, y.Ekhtiar, y.AtiSaham, y.AtiSabad, y.Fekri, y.Salaf, y.Bond1, y.Bond2, y.Bond3, y.Bond4, y.Bond5, y.Bond6, y.INDEX, y.bond7, y.EtfInEtf, y.EtfAmlak, y.NapeyvastehZaferan, y.NapeyvastehSekkeh, y.NapeyvastehShisheh, y.NapeyvastehMes, y.NapeyvastehSangAhan, y.NapeyvastehMilgerd, y.ETFKhosusi, y.EtfSector, y.EnergyETF, ...this.OptionMarketUnit],
        this.AllowShowNAVvalueInSymbolHeaderMarketUnits = [y.ETFStock, y.ETFFix, y.ETFMixed, y.ETFZaminSakhteman, y.ETFJasuraneh, y.SandoghKala, y.EnergyETF, y.EtfInEtf, y.EtfAmlak, y.ETFKhosusi, y.EtfSector],
        this.AllowShowIndInstMarketUnits = [y.Exchange, y.Rights, y.ETFStock, y.ETFFix, y.ETFMixed, y.ETFZaminSakhteman, y.ETFJasuraneh, y.SandoghKala, y.PayehYellow, y.PayehOrange, y.PayehRed, y.Koochak, y.EtfInEtf, y.EtfAmlak, y.ETFKhosusi, y.RightYellow, y.RightOrange, y.RightRed, y.EtfSector, y.RightsKoochak, y.ProMarket, y.EnergyETF, y.AgreedMarket, ...this.OptionMarketUnit],
        this.AllowCalculatorTabUnitCodes = [...this.OptionMarketUnit],
        this.AllowOptionChainTabUnitCodes = [...this.OptionMarketUnit],
        this.AllowContractInfoMarketUnits = [...this.OptionMarketUnit],
        this.NotAllowToShowSymbolInfoMarketUnits = [...this.OptionMarketUnit],
        this.NotAllowToShowReturnChartMarketUnits = [...this.OptionMarketUnit],
        this.AllowToShowCalculatorAndNotToShowSameGroupUnitCodes = [...this.OptionMarketUnit],
        this.marketUnit = t,
        this.allowShowNAVvalueInSymbolHeader = this.AllowShowNAVvalueInSymbolHeaderMarketUnits.includes(t),
        this.allowShowIndInstWidget = this.AllowShowIndInstMarketUnits.includes(t),
        this.allowToShowIndividualTradingTrend = this.AllowToShowIndividualTradingTrendUnitCodes.includes(t),
        this.allowToCallTechnicalAnalysis = this.AllowToCallTechnicalAnalysisUnitCodes.includes(t),
        this.allowToCallFundamentalAnalysis = this.AllowToCallFundamentalAnalysisUnitCodes.includes(t),
        this.allowToShowSameGroupSignSection = !this.NotAllowSameGroupSignSectionUnitCodes.includes(t),
        this.allowToShowCalculatorAndNotToShowSameGroup = this.AllowToShowCalculatorAndNotToShowSameGroupUnitCodes.includes(t),
        this.allowCorporateActionsSection = !this.NotAllowCorporateActionsSectionUnitCodes.includes(t),
        this.allowAnalyticsTab = !this.NotAllowAnalyticsTabUnitCodes.includes(t),
        this.allowEasyChartTab = !this.NotAllowEasyChartTabUnitCodes.includes(t) && !this.AllowOptionChainTabUnitCodes.includes(t),
        this.allowCalculator = this.AllowCalculatorTabUnitCodes.includes(t),
        this.allowContractInfo = this.AllowContractInfoMarketUnits.includes(t),
        this.allowBasicIsinInfo = this.AllowContractInfoMarketUnits.includes(t),
        this.allowOptionChain = this.AllowOptionChainTabUnitCodes.includes(t),
        this.allowToShowSymbolInfoSection = !this.NotAllowToShowSymbolInfoMarketUnits.includes(t),
        this.allowToShowReturnChartSection = !this.NotAllowToShowReturnChartMarketUnits.includes(t),
        this.setTabs()
    }
    setTabs(t=!1) {
        this.allowedTabs = this.AllTabs,
        this.allowToShowCalculatorAndNotToShowSameGroup ? delete this.allowedTabs[Qt.SameGroup] : delete this.allowedTabs[Qt.Calculator],
        this.allowAnalyticsTab || delete this.allowedTabs[Qt.Analytics],
        this.allowEasyChartTab || delete this.allowedTabs[Qt.EasyChart],
        this.allowCorporateActionsSection || delete this.allowedTabs[Qt.CorporateActions],
        this.allowCalculator || delete this.allowedTabs[Qt.Calculator],
        this.allowOptionChain || t ? this.allowedTabs[Qt.OptionChain] = {
            title: "\u0632\u0646\u062C\u06CC\u0631\u0647 \u0622\u067E\u0634\u0646 \u0646\u0645\u0627\u062F",
            htmlId: "symbol-detail-tab-option-chain",
            dataCy: "symbol-detail-tab-option-chain",
            name: "optionChain",
            icon: "option",
            newBadge: !0,
            tab: Qt.OptionChain
        } : delete this.allowedTabs[Qt.OptionChain];
        try {
            let n = JSON.parse(localStorage.getItem("symbolDetailsTabNewBadgeState") ?? "{}");
            Object.entries(this.allowedTabs).filter( ([,i]) => i.newBadge).forEach( ([i,r]) => {
                r.newBadge = n[r.name] ?? !0,
                this.allowedTabs[i] = C({}, r)
            }
            ),
            this.showNewBadgeOnMoreTabs = !!Object.values(this.allowedTabs).filter(i => i.newBadge).length
        } catch {
            localStorage.removeItem("symbolDetailsTabNewBadgeState")
        }
        return Object.values(this.allowedTabs).sort( (n, i) => n.tab - i.tab)
    }
}
  , Bce = new Map([[y.None, new nt(y.None)], [y.Exchange, new nt(y.Exchange)], [y.Rights, new nt(y.Rights)], [y.ETFStock, new nt(y.ETFStock)], [y.ETFFix, new nt(y.ETFFix)], [y.ETFMixed, new nt(y.ETFMixed)], [y.ETFZaminSakhteman, new nt(y.ETFZaminSakhteman)], [y.ETFJasuraneh, new nt(y.ETFJasuraneh)], [y.SandoghKala, new nt(y.SandoghKala)], [y.NapeyvastehSiman, new nt(y.NapeyvastehSiman)], [y.GovahiBourseKala, new nt(y.GovahiBourseKala)], [y.Sekkeh, new nt(y.Sekkeh)], [y.Maskan1, new nt(y.Maskan1)], [y.Maskan2, new nt(y.Maskan2)], [y.Tabaee, new nt(y.Tabaee)], [y.Ekhtiar, new nt(y.Ekhtiar)], [y.AtiSaham, new nt(y.AtiSaham)], [y.AtiSabad, new nt(y.AtiSabad)], [y.Fekri, new nt(y.Fekri)], [y.PayehYellow, new nt(y.PayehYellow)], [y.PayehOrange, new nt(y.PayehOrange)], [y.PayehRed, new nt(y.PayehRed)], [y.Koochak, new nt(y.Koochak)], [y.Salaf, new nt(y.Salaf)], [y.Bond1, new nt(y.Bond1)], [y.Bond2, new nt(y.Bond2)], [y.Bond3, new nt(y.Bond3)], [y.Bond4, new nt(y.Bond4)], [y.Bond5, new nt(y.Bond5)], [y.Bond6, new nt(y.Bond6)], [y.INDEX, new nt(y.INDEX)], [y.bond7, new nt(y.bond7)], [y.EtfInEtf, new nt(y.EtfInEtf)], [y.EtfAmlak, new nt(y.EtfAmlak)], [y.NapeyvastehZaferan, new nt(y.NapeyvastehZaferan)], [y.NapeyvastehSekkeh, new nt(y.NapeyvastehSekkeh)], [y.NapeyvastehShisheh, new nt(y.NapeyvastehShisheh)], [y.NapeyvastehMes, new nt(y.NapeyvastehMes)], [y.NapeyvastehSangAhan, new nt(y.NapeyvastehSangAhan)], [y.NapeyvastehMilgerd, new nt(y.NapeyvastehMilgerd)], [y.ETFKhosusi, new nt(y.ETFKhosusi)], [y.RightYellow, new nt(y.RightYellow)], [y.RightOrange, new nt(y.RightOrange)], [y.RightRed, new nt(y.RightRed)], [y.EtfSector, new nt(y.EtfSector)], [y.RightsKoochak, new nt(y.RightsKoochak)], [y.BuyOptionTse, new nt(y.BuyOptionTse)], [y.BuyOptionIfb, new nt(y.BuyOptionIfb)], [y.SellOptionTse, new nt(y.SellOptionTse)], [y.SellOptionIfb, new nt(y.SellOptionIfb)], [y.ProMarket, new nt(y.ProMarket)], [y.EnergyETF, new nt(y.EnergyETF)], [y.AgreedMarket, new nt(y.AgreedMarket)]]);
var Gce = {
    0: "\u0647\u0645\u0647",
    1: "\u062F\u0631\u06CC\u0627\u0641\u062A",
    2: "\u067E\u0631\u062F\u0627\u062E\u062A",
    3: "\u062E\u0631\u06CC\u062F",
    4: "\u0641\u0631\u0648\u0634"
}
  , Vce = {
    0: "\u0645\u06CC\u0627\u0646\u06AF\u06CC\u0646",
    1: "\u062D\u0633\u0627\u0628\u062F\u0627\u0631\u06CC",
    2: "\u062D\u0633\u0627\u0628\u062F\u0627\u0631\u06CC \u0628\u0627 \u062D\u0627\u0645\u06CC"
};
var gN = function(e) {
    return e[e.ASC = 0] = "ASC",
    e[e.DESC = 1] = "DESC",
    e
}(gN || {})
  , mN = function(e) {
    return e[e.Equal = 0] = "Equal",
    e[e.GreatThan = 1] = "GreatThan",
    e[e.LessThan = 2] = "LessThan",
    e[e.GreatEqualThan = 3] = "GreatEqualThan",
    e[e.LessEqualThan = 4] = "LessEqualThan",
    e[e.NotEqual = 5] = "NotEqual",
    e[e.Between = 6] = "Between",
    e[e.Contains = 7] = "Contains",
    e[e.StartsWith = 8] = "StartsWith",
    e[e.ArrayOfElement = 9] = "ArrayOfElement",
    e[e.Any = 10] = "Any",
    e
}(mN || {});
var ii = function(e) {
    return e.info = "info",
    e.success = "success",
    e.warning = "warning",
    e.danger = "danger",
    e.secondary = "secondary",
    e.globalSecondary = "globalSecondary",
    e.pinkRose = "pinkRose",
    e
}(ii || {});
var vN = function(e) {
    return e.algo = "f_orbis_algo",
    e.ai_market_assistant = "ai-market-assistant",
    e.easyChart = "easy-chart",
    e.bank_gateway_saman = "bank-gateway-Saman",
    e.bank_gateway_Mellat = "bank-gateway-Mellat",
    e.bank_gateway_Pasargad = "bank-gateway-Pasargad",
    e.bank_gateway_Parsian = "bank-gateway-Parsian",
    e.bank_gateway_Sadad = "bank-gateway-Sadad",
    e.bank_gateway_Ap = "bank-gateway-Ap",
    e.payment_v2 = "payment-service",
    e
}(vN || {});
var t3 = function(e) {
    return e[e.Buy = 0] = "Buy",
    e[e.Sell = 1] = "Sell",
    e[e.Cross = 2] = "Cross",
    e[e.None = 3] = "None",
    e
}(t3 || {});
var xg = {
    firstTradedPrice: 0,
    lastTradedPrice: 0,
    lastTradedPriceVar: 0,
    lastTradedPriceVarPercent: 0,
    feeOfPreviousDaysClosingPrice: 0,
    closingPrice: 0,
    closingPriceVarPercent: 0,
    totalNumberOfTrades: 0,
    totalTradeValue: 0,
    totalNumberOfSharesTraded: 0,
    stateCode: "",
    stateColor: "",
    tradeDate: "",
    navDate: "",
    navSubscription: 0,
    navRedemption: 0,
    priceTickSize: 0,
    maxDailyPrice: 0,
    minDailyPrice: 0,
    maxDailyTradedPrice: 0,
    minDailyTradedPrice: 0,
    minValidBuyVolume: 0,
    minValidSellVolume: 0,
    maxValidBuyVolume: 0,
    maxValidSellVolume: 0,
    bidPrice: 0,
    askPrice: 0
};
var yn = function(e) {
    return e[e.Unknown = -1] = "Unknown",
    e[e.Mobile = 0] = "Mobile",
    e[e.Desktop = 1] = "Desktop",
    e
}(yn || {});
var xr = function(e) {
    return e[e.None = 0] = "None",
    e[e.General = 1] = "General",
    e[e.DateError = 2] = "DateError",
    e[e.Easy2User = 3] = "Easy2User",
    e[e.GuestUser = 4] = "GuestUser",
    e[e.LoggedOutFromOtherTab = 5] = "LoggedOutFromOtherTab",
    e[e.InternetIsDisconnected = 6] = "InternetIsDisconnected",
    e[e.ForceContract2 = 7] = "ForceContract2",
    e[e.OnlineOptionUser = 8] = "OnlineOptionUser",
    e
}(xr || {})
  , n3 = function(e) {
    return e.EContract2 = "Econtract_2.0",
    e.OptionBuy = "TradeOptionContractEasyTrader_1.0",
    e.OptionSell = "ShortSellEasyTrader_1.0",
    e.Algo = "SmartTrade_1.0",
    e.OptionBuyOnline = "TradeOptionContract_1.0",
    e.OptionSellOnline = "ShortSell_1.0",
    e
}(n3 || {});
var Vn = {
    isGuestUser: "isGuestUser",
    mwHelp: "mwHelp",
    olHelp: "olHelp",
    sdHelp: "sdHelp",
    loggedIn: "loggedIn",
    funds: "funds",
    defaultIsin: "defaultIsin",
    sortStore: "SORT_STORE",
    marketMapFilters: "MARKET_MAP_FILTERS",
    optionMarketMapFilters: "OPTION_MARKET_MAP_FILTERS",
    bankGateways: "BankGateways",
    setting: "settings",
    symbol: "all-symbols",
    uuid: "uuid"
}
  , Tc = ( () => {
    let t = class t {
        setItem(i, r) {
            localStorage.setItem(i, r)
        }
        getItem(i) {
            return localStorage.getItem(i)
        }
        removeItem(i) {
            localStorage.removeItem(i)
        }
    }
    ;
    t.\u0275fac = function(r) {
        return new (r || t)
    }
    ,
    t.\u0275prov = re({
        token: t,
        factory: t.\u0275fac,
        providedIn: "root"
    });
    let e = t;
    return e
}
)();
var Wr = ( () => {
    let t = class t {
        constructor() {
            this.userCheckedSubject = new Ne(!1),
            this.userChecked$ = this.userCheckedSubject.asObservable(),
            this.isGuestUserSub = new Ne(sessionStorage.getItem(Vn.isGuestUser) === "true"),
            this.isGuestUserObs$ = this.isGuestUserSub.asObservable(),
            this.isEasy2User = !1
        }
        get isGuestUser() {
            return sessionStorage.getItem(Vn.isGuestUser) === "true"
        }
        set isGuestUser(i) {
            sessionStorage.setItem(Vn.isGuestUser, String(i)),
            this.isGuestUserSub.next(i)
        }
        userChecked() {
            this.userCheckedSubject.getValue() || this.userCheckedSubject.next(!0)
        }
        userUnChecked() {
            this.userCheckedSubject.next(!1)
        }
        getValue() {
            return this.userCheckedSubject.getValue()
        }
    }
    ;
    t.\u0275fac = function(r) {
        return new (r || t)
    }
    ,
    t.\u0275prov = re({
        token: t,
        factory: t.\u0275fac,
        providedIn: "root"
    });
    let e = t;
    return e
}
)();
var mu = class {
    constructor(t) {
        this.error = t
    }
}
;
var Fd = class extends mu {
}
;
var cle = ( () => {
    let t = class t {
        constructor(i) {
            this.environment = i
        }
        handleError(i) {
            this.environment.env === Yt.PROD ? i instanceof Error ? wl(i) : [500, 504, 401, 403].includes(i?.status) || wl(new Error(JSON.stringify(i))) : (console.debug(),
            console.error(`\u{1F6AB}\u{1F6AB}\u{1F6AB} -------- \u{1F92C}\u{1F92C}\u{1F92C}
\r`, i))
        }
    }
    ;
    t.\u0275fac = function(r) {
        return new (r || t)(xe(xn))
    }
    ,
    t.\u0275prov = re({
        token: t,
        factory: t.\u0275fac,
        providedIn: "root"
    });
    let e = t;
    return e
}
)();
var i3 = ( () => {
    let t = class t {
        constructor() {
            this.environment = z(xn),
            this.http = z($v),
            this.userService = z(Wr)
        }
        get restrictionError() {
            return {
                status: 400,
                error: "\u062F\u0633\u062A\u0631\u0633\u06CC \u063A\u06CC\u0631 \u0645\u062C\u0627\u0632"
            }
        }
        getCached(i, r, s) {
            return I0(this.getCachedFromLocalStorage(i), this.getFromApiAndSetToLocalStorage(i, r, s))
        }
        get(i, r) {
            return this.httpGet(i, r).pipe(N0({
                count: r?.maxRetryAttempts ?? 0,
                delay: r?.delayMs ?? 1e3
            }), on(s => this.handleError(s)))
        }
        getBlob(i, r, s=0, o=1e3) {
            return this.http.get(i, r).pipe(N0({
                count: s,
                delay: o
            }), on(a => this.handleError(a)))
        }
        post(i, r) {
            return this.httpPost(i, r?.body, r).pipe(N0({
                count: r?.maxRetryAttempts ?? 0,
                delay: r?.delayMs ?? 1e3
            }), on(s => this.handleError(s)))
        }
        put(i, r) {
            return this.httpPut(i, r?.body, r).pipe(N0({
                count: r?.maxRetryAttempts ?? 0,
                delay: r?.delayMs ?? 1e3
            }), on(s => this.handleError(s)))
        }
        delete(i, r) {
            return this.httpDelete(i, r?.body, r).pipe(N0({
                count: r?.maxRetryAttempts ?? 0,
                delay: r?.delayMs ?? 1e3
            }), on(s => this.handleError(s)))
        }
        httpGet(i, r) {
            return this.checkGuestUserRestriction(r) ? Be([]) : r?.dontCheckSameLogin ? this.http.get(i, r?.options) : this.userService.userChecked$.pipe(Jn(s => s), ui( () => this.http.get(i, r?.options)))
        }
        httpPost(i, r, s) {
            return this.checkGuestUserRestriction(s) ? this.handleError(this.restrictionError) : s?.dontCheckSameLogin ? this.http.post(i, r, s?.options) : this.userService.userChecked$.pipe(Jn(o => o), ui( () => this.http.post(i, r, s?.options)))
        }
        httpPut(i, r, s) {
            return this.checkGuestUserRestriction(s) ? this.handleError(this.restrictionError) : (s?.dontCheckSameLogin && this.http.put(i, r, s?.options),
            this.userService.userChecked$.pipe(Jn(o => o), ui( () => this.http.put(i, r, s?.options))))
        }
        httpDelete(i, r, s) {
            if (this.checkGuestUserRestriction(s))
                return this.handleError(this.restrictionError);
            let o = ve(C({}, s?.options), {
                body: r
            });
            return s?.dontCheckSameLogin && this.http.delete(i, o),
            this.userService.userChecked$.pipe(Jn(a => a), ui( () => this.http.delete(i, o)))
        }
        checkGuestUserRestriction(i) {
            return i?.guestUserRestriction && this.userService.isGuestUser
        }
        getCachedFromLocalStorage(i) {
            let r = localStorage.getItem(i);
            return Be(r ? JSON.parse(r) : null)
        }
        getFromApiAndSetToLocalStorage(i, r, s) {
            return this.get(r, s).pipe(Ge(o => {
                localStorage.setItem(i, JSON.stringify(o))
            }
            ), on( () => this.getCachedFromLocalStorage(i)))
        }
        handleError(i) {
            if (this.environment.env !== Yt.PROD && console.log(`Error ${i.status}:`, i),
            i.status === 400) {
                if (i.error?.errors) {
                    let s = "";
                    return Object.keys(i.error.errors).forEach(o => {
                        i.error.errors[o].forEach(a => {
                            s += a + "\u060C "
                        }
                        )
                    }
                    ),
                    Hr( () => new Fd(s.slice(0, -2)))
                }
                let r = i.error?.detail ?? i.error;
                return Hr( () => new Fd(r))
            }
            return i.status === 404 ? Hr( () => new ev(i.error)) : (i.status,
            Hr( () => i))
        }
    }
    ;
    t.\u0275fac = function(r) {
        return new (r || t)
    }
    ,
    t.\u0275prov = re({
        token: t,
        factory: t.\u0275fac,
        providedIn: "root"
    });
    let e = t;
    return e
}
)();
var gn = ( () => {
    let t = class t {
        constructor() {
            this.environment = z(xn),
            this.httpService = z(i3)
        }
        get mtsPath() {
            return this.environment.setting.mtsPath
        }
        get apiUrls() {
            return Rd
        }
    }
    ;
    t.\u0275fac = function(r) {
        return new (r || t)
    }
    ,
    t.\u0275prov = re({
        token: t,
        factory: t.\u0275fac,
        providedIn: "root"
    });
    let e = t;
    return e
}
)();
var Nle = ( () => {
    let t = class t extends gn {
        constructor() {
            super(...arguments),
            this.loadingSubject = new Ne(!1),
            this.loading$ = this.loadingSubject.asObservable(),
            this.retryLoadingSubject = new Ne(!1),
            this.retryLoading$ = this.retryLoadingSubject.asObservable()
        }
        showLoaderUntilComplete(i) {
            return Be(null).pipe(Ge( () => {
                this.loadingOn()
            }
            ), ui( () => i), gr( () => {
                this.loadingOff()
            }
            ), on(r => (this.retryLoadingOn(),
            this.httpService.handleError(r))))
        }
        loadingOn() {
            this.retryLoadingOff(),
            this.loadingSubject.next(!0)
        }
        loadingOff() {
            this.loadingSubject.next(!1)
        }
        retryLoadingOn() {
            this.retryLoadingSubject.next(!0)
        }
        retryLoadingOff() {
            this.retryLoadingSubject.next(!1)
        }
    }
    ;
    t.\u0275fac = ( () => {
        let i;
        return function(s) {
            return (i || (i = On(t)))(s || t)
        }
    }
    )(),
    t.\u0275prov = re({
        token: t,
        factory: t.\u0275fac
    });
    let e = t;
    return e
}
)();
if (typeof Promise > "u") {
    (function() {
        function e(ne) {
            return typeof ne == "function" || typeof ne == "object" && ne !== null
        }
        function t(ne) {
            return typeof ne == "function"
        }
        function n(ne) {
            return typeof ne == "object" && ne !== null
        }
        var i;
        Array.isArray ? i = Array.isArray : i = function(ne) {
            return Object.prototype.toString.call(ne) === "[object Array]"
        }
        ;
        var r = i, s = 0, o, a = function(_e, Oe) {
            w[s] = _e,
            w[s + 1] = Oe,
            s += 2,
            s === 2 && (o ? o(k) : N())
        };
        function c(ne) {
            o = ne
        }
        function l(ne) {
            a = ne
        }
        var u = typeof window < "u" ? window : void 0
          , h = u || {}
          , d = h.MutationObserver || h.WebKitMutationObserver
          , f = typeof process < "u" && {}.toString.call(process) === "[object process]"
          , g = typeof Uint8ClampedArray < "u" && typeof importScripts < "u" && typeof MessageChannel < "u";
        function p() {
            return function() {
                process.nextTick(k)
            }
        }
        function v() {
            var ne = 0
              , _e = new d(k)
              , Oe = document.createTextNode("");
            return _e.observe(Oe, {
                characterData: !0
            }),
            function() {
                Oe.data = ne = ++ne % 2
            }
        }
        function b() {
            var ne = new MessageChannel;
            return ne.port1.onmessage = k,
            function() {
                ne.port2.postMessage(0)
            }
        }
        function S() {
            return function() {
                setTimeout(k, 1)
            }
        }
        var w = new Array(1e3);
        function k() {
            for (var ne = 0; ne < s; ne += 2) {
                var _e = w[ne]
                  , Oe = w[ne + 1];
                _e(Oe),
                w[ne] = void 0,
                w[ne + 1] = void 0
            }
            s = 0
        }
        function B() {
            return S()
        }
        var N;
        f ? N = p() : d ? N = v() : g ? N = b() : u === void 0 && typeof z8 == "function" ? N = B() : N = S();
        function E() {}
        var F = void 0
          , O = 1
          , V = 2
          , X = new U;
        function x() {
            return new TypeError("You cannot resolve a promise with itself")
        }
        function j() {
            return new TypeError("A promises callback cannot return that same promise.")
        }
        function fe(ne) {
            try {
                return ne.then
            } catch (_e) {
                return X.error = _e,
                X
            }
        }
        function he(ne, _e, Oe, ht) {
            try {
                ne.call(_e, Oe, ht)
            } catch (At) {
                return At
            }
        }
        function Re(ne, _e, Oe) {
            a(function(ht) {
                var At = !1
                  , rn = he(Oe, _e, function(An) {
                    At || (At = !0,
                    _e !== An ? it(ht, An) : Ue(ht, An))
                }, function(An) {
                    At || (At = !0,
                    A(ht, An))
                }, "Settle: " + (ht._label || " unknown promise"));
                !At && rn && (At = !0,
                A(ht, rn))
            }, ne)
        }
        function Xe(ne, _e) {
            _e._state === O ? Ue(ne, _e._result) : _e._state === V ? A(ne, _e._result) : q(_e, void 0, function(Oe) {
                it(ne, Oe)
            }, function(Oe) {
                A(ne, Oe)
            })
        }
        function pt(ne, _e) {
            if (_e.constructor === ne.constructor)
                Xe(ne, _e);
            else {
                var Oe = fe(_e);
                Oe === X ? A(ne, X.error) : Oe === void 0 ? Ue(ne, _e) : t(Oe) ? Re(ne, _e, Oe) : Ue(ne, _e)
            }
        }
        function it(ne, _e) {
            ne === _e ? A(ne, x()) : e(_e) ? pt(ne, _e) : Ue(ne, _e)
        }
        function de(ne) {
            ne._onerror && ne._onerror(ne._result),
            L(ne)
        }
        function Ue(ne, _e) {
            ne._state === F && (ne._result = _e,
            ne._state = O,
            ne._subscribers.length !== 0 && a(L, ne))
        }
        function A(ne, _e) {
            ne._state === F && (ne._state = V,
            ne._result = _e,
            a(de, ne))
        }
        function q(ne, _e, Oe, ht) {
            var At = ne._subscribers
              , rn = At.length;
            ne._onerror = null,
            At[rn] = _e,
            At[rn + O] = Oe,
            At[rn + V] = ht,
            rn === 0 && ne._state && a(L, ne)
        }
        function L(ne) {
            var _e = ne._subscribers
              , Oe = ne._state;
            if (_e.length !== 0) {
                for (var ht, At, rn = ne._result, An = 0; An < _e.length; An += 3)
                    ht = _e[An],
                    At = _e[An + Oe],
                    ht ? Ve(Oe, ht, At, rn) : At(rn);
                ne._subscribers.length = 0
            }
        }
        function U() {
            this.error = null
        }
        var te = new U;
        function Ce(ne, _e) {
            try {
                return ne(_e)
            } catch (Oe) {
                return te.error = Oe,
                te
            }
        }
        function Ve(ne, _e, Oe, ht) {
            var At = t(Oe), rn, An, yo, wh;
            if (At) {
                if (rn = Ce(Oe, ht),
                rn === te ? (wh = !0,
                An = rn.error,
                rn = null) : yo = !0,
                _e === rn) {
                    A(_e, j());
                    return
                }
            } else
                rn = ht,
                yo = !0;
            _e._state !== F || (At && yo ? it(_e, rn) : wh ? A(_e, An) : ne === O ? Ue(_e, rn) : ne === V && A(_e, rn))
        }
        function De(ne, _e) {
            try {
                _e(function(ht) {
                    it(ne, ht)
                }, function(ht) {
                    A(ne, ht)
                })
            } catch (Oe) {
                A(ne, Oe)
            }
        }
        function ge(ne, _e) {
            var Oe = this;
            Oe._instanceConstructor = ne,
            Oe.promise = new ne(E),
            Oe._validateInput(_e) ? (Oe._input = _e,
            Oe.length = _e.length,
            Oe._remaining = _e.length,
            Oe._init(),
            Oe.length === 0 ? Ue(Oe.promise, Oe._result) : (Oe.length = Oe.length || 0,
            Oe._enumerate(),
            Oe._remaining === 0 && Ue(Oe.promise, Oe._result))) : A(Oe.promise, Oe._validationError())
        }
        ge.prototype._validateInput = function(ne) {
            return r(ne)
        }
        ,
        ge.prototype._validationError = function() {
            return new Error("Array Methods must be provided an Array")
        }
        ,
        ge.prototype._init = function() {
            this._result = new Array(this.length)
        }
        ;
        var kt = ge;
        ge.prototype._enumerate = function() {
            for (var ne = this, _e = ne.length, Oe = ne.promise, ht = ne._input, At = 0; Oe._state === F && At < _e; At++)
                ne._eachEntry(ht[At], At)
        }
        ,
        ge.prototype._eachEntry = function(ne, _e) {
            var Oe = this
              , ht = Oe._instanceConstructor;
            n(ne) ? ne.constructor === ht && ne._state !== F ? (ne._onerror = null,
            Oe._settledAt(ne._state, _e, ne._result)) : Oe._willSettleAt(ht.resolve(ne), _e) : (Oe._remaining--,
            Oe._result[_e] = ne)
        }
        ,
        ge.prototype._settledAt = function(ne, _e, Oe) {
            var ht = this
              , At = ht.promise;
            At._state === F && (ht._remaining--,
            ne === V ? A(At, Oe) : ht._result[_e] = Oe),
            ht._remaining === 0 && Ue(At, ht._result)
        }
        ,
        ge.prototype._willSettleAt = function(ne, _e) {
            var Oe = this;
            q(ne, void 0, function(ht) {
                Oe._settledAt(O, _e, ht)
            }, function(ht) {
                Oe._settledAt(V, _e, ht)
            })
        }
        ;
        function xt(ne) {
            return new kt(this,ne).promise
        }
        var fn = xt;
        function Ot(ne) {
            var _e = this
              , Oe = new _e(E);
            if (!r(ne))
                return A(Oe, new TypeError("You must pass an array to race.")),
                Oe;
            var ht = ne.length;
            function At(yo) {
                it(Oe, yo)
            }
            function rn(yo) {
                A(Oe, yo)
            }
            for (var An = 0; Oe._state === F && An < ht; An++)
                q(_e.resolve(ne[An]), void 0, At, rn);
            return Oe
        }
        var xi = Ot;
        function Xt(ne) {
            var _e = this;
            if (ne && typeof ne == "object" && ne.constructor === _e)
                return ne;
            var Oe = new _e(E);
            return it(Oe, ne),
            Oe
        }
        var He = Xt;
        function er(ne) {
            var _e = this
              , Oe = new _e(E);
            return A(Oe, ne),
            Oe
        }
        var ns = er
          , Bi = 0;
        function is() {
            throw new TypeError("You must pass a resolver function as the first argument to the promise constructor")
        }
        function al() {
            throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.")
        }
        var Kn = pn;
        function pn(ne) {
            this._id = Bi++,
            this._state = void 0,
            this._result = void 0,
            this._subscribers = [],
            E !== ne && (t(ne) || is(),
            this instanceof pn || al(),
            De(this, ne))
        }
        pn.all = fn,
        pn.race = xi,
        pn.resolve = He,
        pn.reject = ns,
        pn._setScheduler = c,
        pn._setAsap = l,
        pn._asap = a,
        pn.prototype = {
            constructor: pn,
            then: function(ne, _e) {
                var Oe = this
                  , ht = Oe._state;
                if (ht === O && !ne || ht === V && !_e)
                    return this;
                var At = new this.constructor(E)
                  , rn = Oe._result;
                if (ht) {
                    var An = arguments[ht - 1];
                    a(function() {
                        Ve(ht, At, An, rn)
                    })
                } else
                    q(Oe, At, ne, _e);
                return At
            },
            catch: function(ne) {
                return this.then(null, ne)
            }
        };
        function ca() {
            var ne;
            if (typeof global < "u")
                ne = global;
            else if (typeof self < "u")
                ne = self;
            else
                try {
                    ne = Function("return this")()
                } catch {
                    throw new Error("polyfill failed because global object is unavailable in this environment")
                }
            var _e = ne.Promise;
            _e && Object.prototype.toString.call(_e.resolve()) === "[object Promise]" && !_e.cast || (Kn.all = Kn.all,
            Kn.race = Kn.race,
            Kn.reject = Kn.reject,
            Kn.resolve = Kn.resolve,
            Kn.prototype.constructor = Kn.prototype.constructor,
            Kn.prototype.then = Kn.prototype.then,
            ne.Promise = Kn)
        }
        var tc = ca;
        tc()
    }
    ).call(window)
}
var St = function() {
    var e = function(t) {
        this.name = "IllegalStateException",
        this.message = t
    };
    return e.prototype = {
        toString: function() {
            return ["[", this.name, this.message, "]"].join("|")
        }
    },
    e
}()
  , vt = function() {
    var e = typeof window < "u" && typeof navigator < "u" && typeof document < "u"
      , t = typeof importScripts < "u"
      , n = typeof process == "object" && (/node(\.exe)?$/.test(process.execPath) || process.node && process.v8 || process.versions && process.versions.node && process.versions.v8);
    if (e && !document.getElementById)
        throw new St("Not supported browser");
    var i = {
        isBrowserDocument: function() {
            return e
        },
        isBrowser: function() {
            return !n && (e || t)
        },
        isNodeJS: function() {
            return !e && n
        },
        isWebWorker: function() {
            return !e && !n && t
        },
        isOther: function() {
            return !e && !n && !t
        },
        browserDocumentOrDie: function() {
            if (!this.isBrowserDocument())
                throw new St("Trying to load a browser-only module on non-browser environment")
        }
    };
    return i.isBrowserDocument = i.isBrowserDocument,
    i.isBrowser = i.isBrowser,
    i.isNodeJS = i.isNodeJS,
    i.isWebWorker = i.isWebWorker,
    i.browserDocumentOrDie = i.browserDocumentOrDie,
    i
}()
  , Et = function() {
    var e = new RegExp("^\\s*([\\s\\S]*?)\\s*$")
      , t = new RegExp(",","g")
      , n = new RegExp("\\.","g")
      , i = {
        getTimeStamp: function() {
            return new Date().getTime()
        },
        randomG: function(r) {
            return r = r || 1e3,
            Math.round(Math.random() * r)
        },
        trim: function(r) {
            return r.replace(e, "$1")
        },
        getNumber: function(r, s) {
            return r ? r.replace ? (s ? (r = r.replace(n, ""),
            r = r.replace(t, ".")) : r = r.replace(t, ""),
            new Number(r)) : r : 0
        },
        isArray: function(r) {
            return r && r.join && typeof r.join == "function"
        },
        addEvent: function(r, s, o) {
            return vt.isBrowserDocument() ? (typeof r.addEventListener < "u" ? r.addEventListener(s, o, !1) : typeof r.attachEvent < "u" && r.attachEvent("on" + s, o),
            !0) : !1
        },
        removeEvent: function(r, s, o) {
            return vt.isBrowserDocument() ? (typeof r.removeEventListener < "u" ? r.removeEventListener(s, o, !1) : typeof r.detachEvent < "u" && r.detachEvent("on" + s, o),
            !0) : !1
        }
    };
    return i.getTimeStamp = i.getTimeStamp,
    i.randomG = i.randomG,
    i.trim = i.trim,
    i.getNumber = i.getNumber,
    i.isArray = i.isArray,
    i.addEvent = i.addEvent,
    i.removeEvent = i.removeEvent,
    i
}()
  , G = function() {
    var e = {
        handleError5: !1,
        REFRESH_STATUS_INTERVAL: 1e3,
        REFRESH_STATUS_INTERVAL_TOLERANCE: 200,
        STOP_SEARCH_TIMEOUT: 1e4,
        FRAME_NAME_INDEX: 1,
        TIMESTAMP_INDEX: 0,
        HOST_INDEX: 2,
        BUILD_INDEX: 3,
        PROTOCOL_INDEX: 4,
        BLOB_INDEX: 5,
        NULL_VALUE: "N",
        ALONE_CHECK_TIMEOUT: 200,
        MAIN_CLIENT: "MAIN",
        WORKER_BRIDGE_GLOBAL: "wbridge",
        FRAME_BRIDGE_GLOBAL: "fbridge",
        PROMISE_TIMEOUT: 1,
        PROMISE_FAILURE: 2,
        BUILD: "1811",
        LIBRARY_VERSION: "8.0.9",
        LIBRARY_NAME: "javascript",
        LIBRARY_TAG: "javascript_client",
        LS_CID: "pcYgxn8m8%20feOojyA1U661o3g2.pz47Ag7s",
        PAGE_PROTOCOL: vt.isBrowserDocument() && (document.location.protocol == "http:" || document.location.protocol == "https:") ? document.location.protocol : "file:",
        STREAM: "lightstreamer.stream",
        PROTOCOL: "lightstreamer.protocol",
        SESSION: "lightstreamer.session",
        REQUESTS: "lightstreamer.requests",
        SUBSCRIPTIONS: "lightstreamer.subscriptions",
        MESSAGES: "lightstreamer.messages",
        ACTIONS: "lightstreamer.actions",
        SHARING: "lightstreamer.sharing",
        CROSSTAB: "lightstreamer.crosstab",
        STATS: "lightstreamer.stats",
        MPN: "lightstreamer.mpn",
        STORAGE_PREFIX: "Lightstreamer_",
        LIGHTSTREAMER_PATH: "lightstreamer",
        _UNORDERED_MESSAGES: "UNORDERED_MESSAGES",
        UNCHANGED: {
            length: -1,
            toString: function() {
                return "[UNCHANGED]"
            }
        },
        CONNECTING: "CONNECTING",
        CONNECTED: "CONNECTED:",
        SENSE: "STREAM-SENSING",
        WS_STREAMING: "WS-STREAMING",
        HTTP_STREAMING: "HTTP-STREAMING",
        STALLED: "STALLED",
        WS_POLLING: "WS-POLLING",
        HTTP_POLLING: "HTTP-POLLING",
        DISCONNECTED: "DISCONNECTED",
        WILL_RETRY: "DISCONNECTED:WILL-RETRY",
        TRYING_RECOVERY: "DISCONNECTED:TRYING-RECOVERY",
        WS_ALL: "WS",
        HTTP_ALL: "HTTP",
        RAW: "RAW",
        DISTINCT: "DISTINCT",
        COMMAND: "COMMAND",
        MERGE: "MERGE",
        MASTER: "MASTER",
        TLCP_VERSION: "TLCP-2.1.0"
    };
    return e
}()
  , vi = function() {
    var e = vt.isBrowser() ? null : !1
      , t = vt.isBrowser() ? navigator.userAgent.toLowerCase() : null;
    function n(g, p, v) {
        return !p || !g ? !0 : v === !0 ? g <= p : v === !1 ? g >= p : g == p
    }
    function i(g) {
        return t.indexOf(g) > -1
    }
    function r(g) {
        var p = e;
        return function() {
            return p === null && (p = i(g)),
            p
        }
    }
    function s(g) {
        var p = e;
        return function() {
            if (p === null) {
                p = !0;
                for (var v = 0; v < g.length; v++)
                    p = p && g[v]()
            }
            return p
        }
    }
    function o(g) {
        var p = e;
        return function() {
            if (p === null) {
                p = !1;
                for (var v = 0; v < g.length; v++)
                    p = p || g[v]()
            }
            return p
        }
    }
    function a(g, p) {
        var v = e
          , b = e;
        return function(S, w) {
            return v === null && (v = g(),
            b = v ? p() : null),
            v ? n(b, S, w) : !1
        }
    }
    function c(g) {
        var p = e;
        return function() {
            if (p === null) {
                var v = g.exec(t);
                if (v && v.length >= 2)
                    return v[1]
            }
            return null
        }
    }
    function l() {
        if (opera.version) {
            var g = opera.version();
            return g = g.replace(new RegExp("[^0-9.]+","g"), ""),
            parseInt(g)
        } else
            return 7
    }
    function u() {
        return typeof opera < "u"
    }
    function h(g) {
        return function() {
            return !g()
        }
    }
    var d = e
      , f = {
        isProbablyRekonq: r("rekonq"),
        isProbablyAWebkit: r("webkit"),
        isProbablyPlaystation: r("playstation 3"),
        isProbablyChrome: a(r("chrome/"), c(new RegExp("chrome/([0-9]+)","g"))),
        isProbablyAKhtml: function() {
            return d === null && (d = document.childNodes && !document.all && !navigator.taintEnabled && !navigator.accentColorName),
            d
        },
        isProbablyKonqueror: a(r("konqueror"), c(new RegExp("konqueror/([0-9.]+)","g"))),
        isProbablyIE: function(g, p) {
            return !!(a(r("msie"), c(new RegExp("msie\\s([0-9]+)[.;]","g")))(g, p) || a(r("rv:11.0"), function() {
                return "11"
            })(g, p))
        },
        isProbablyEdge: r("edge"),
        isProbablyFX: a(r("firefox"), c(new RegExp("firefox\\/(\\d+\\.?\\d*)"))),
        isProbablyOldOpera: a(u, l)
    };
    return f.isProbablyAndroidBrowser = s([r("android"), f.isProbablyAWebkit, h(f.isProbablyChrome)]),
    f.isProbablyOperaMobile = s([f.isProbablyOldOpera, r("opera mobi")]),
    f.isProbablyApple = a(s([r("safari"), o([r("ipad"), r("iphone"), r("ipod"), s([h(f.isProbablyAndroidBrowser), h(f.isProbablyChrome), h(f.isProbablyRekonq)])])]), c(new RegExp("version\\/(\\d+\\.?\\d*)"))),
    f.isProbablyRekonq = f.isProbablyRekonq,
    f.isProbablyChrome = f.isProbablyChrome,
    f.isProbablyAWebkit = f.isProbablyAWebkit,
    f.isProbablyPlaystation = f.isProbablyPlaystation,
    f.isProbablyAndroidBrowser = f.isProbablyAndroidBrowser,
    f.isProbablyOperaMobile = f.isProbablyOperaMobile,
    f.isProbablyApple = f.isProbablyApple,
    f.isProbablyAKhtml = f.isProbablyAKhtml,
    f.isProbablyKonqueror = f.isProbablyKonqueror,
    f.isProbablyIE = f.isProbablyIE,
    f.isProbablyEdge = f.isProbablyEdge,
    f.isProbablyFX = f.isProbablyFX,
    f.isProbablyOldOpera = f.isProbablyOldOpera,
    f
}()
  , Zd = function() {
    var e = function() {
        this.data = []
    };
    return e.prototype = {
        add: function(t) {
            this.data.push(t)
        },
        remove: function(t) {
            var n = this.find(t);
            return n < 0 ? !1 : (this.data.splice(n, 1),
            !0)
        },
        contains: function(t) {
            return this.find(t) >= 0
        },
        find: function(t) {
            for (var n = 0; n < this.data.length; n++)
                if (this.data[n] === t)
                    return n;
            return -1
        },
        forEach: function(t) {
            for (var n = 0; n < this.data.length; n++)
                t(this.data[n])
        },
        asArray: function() {
            return [].concat(this.data)
        },
        clean: function() {
            this.data = []
        }
    },
    e.prototype.add = e.prototype.add,
    e.prototype.remove = e.prototype.remove,
    e.prototype.forEach = e.prototype.forEach,
    e.prototype.asArray = e.prototype.asArray,
    e.prototype.clean = e.prototype.clean,
    e
}()
  , Bt = function() {
    var e = new Zd
      , t = new Zd
      , n = new Zd
      , i = 1e3
      , r = !1
      , s = {
        onloadDone: "onloadDone",
        onloadInprogress: "onloadInprogress",
        unloaded: "unloaded",
        unloading: "unloading",
        preunloading: "preunloading"
    }
      , o = {};
    for (var a in s)
        o[s[a]] = a;
    function c(b) {
        return h(b, o.onloadDone, o.onloadInprogress, t, "onloadEvent")
    }
    function l(b) {
        return h(b, o.unloaded, o.unloading, e, "unloadEvent")
    }
    function u(b) {
        return h(b, o.preunloading, o.preunloading, n, "preUnloadEvent")
    }
    function h(b, S, w, k, B) {
        return function() {
            b[S] || (b[w] = !0,
            k.forEach(function(N) {
                try {
                    d(N, B)
                } catch {}
            }),
            S != "preunloading" && k.clean(),
            b[S] = !0,
            b[w] = !1)
        }
    }
    function d(b, S) {
        b[S] ? b[S]() : b()
    }
    function f(b, S) {
        setTimeout(function() {
            d(b, S)
        }, 0)
    }
    function g(b, S, w, k) {
        setTimeout(function() {
            w ? k ? b.apply(w, k) : b.apply(w) : k ? b.apply(null, k) : b()
        }, S)
    }
    function p() {
        r = !0
    }
    var v = {
        onloadDone: !1,
        onloadInprogress: !1,
        unloaded: !1,
        unloading: !1,
        preunloading: !1,
        isLoaded: function() {
            return this.onloadDone
        },
        isUnloaded: function() {
            return this.unloaded
        },
        isUnloading: function() {
            return this.unloading
        },
        addOnloadHandler: function(b) {
            this.isPreOnload() ? t.add(b) : f(b, "onloadEvent")
        },
        addUnloadHandler: function(b) {
            this.isPreUnload() ? e.add(b) : f(b, "unloadEvent")
        },
        addBeforeUnloadHandler: function(b) {
            n.add(b),
            this.preunloading && f(b, "preUnloadEvent")
        },
        removeOnloadHandler: function(b) {
            t.remove(b)
        },
        removeUnloadHandler: function(b) {
            e.remove(b)
        },
        removeBeforeUnloadHandler: function(b) {
            n.remove(b)
        },
        isPreOnload: function() {
            return !(this.onloadDone || this.onloadInprogress)
        },
        isPreUnload: function() {
            return !(this.unloaded || this.unloading)
        },
        attachToWindow: function() {
            if (Et.addEvent(window, "unload", this.closeFun),
            Et.addEvent(window, "beforeunload", this.beforeCloseFun),
            document && typeof document.readyState < "u") {
                var b = document.readyState;
                if (b.toUpperCase() == "COMPLETE") {
                    this.asynchExecution();
                    return
                } else
                    g(this.controlReadyStateLoad, i, this)
            } else if (this.isInBody()) {
                this.asynchExecution();
                return
            }
            var S = Et.addEvent(window, "load", this.readyFun);
            if (!S)
                this.asynchExecution();
            else if (vi.isProbablyOldOpera()) {
                var w = !1;
                vi.isProbablyOldOpera(9, !1) && (w = !0,
                Et.addEvent(document, "DOMContentLoaded", p)),
                g(this.controlOperaLoad, i, this, [w])
            }
        },
        asynchExecution: function() {
            g(this.readyFun, 0)
        },
        controlReadyStateLoad: function() {
            if (!this.onloadDone) {
                var b = document.readyState;
                b.toUpperCase() == "COMPLETE" ? this.readyFun() : g(this.controlReadyStateLoad, i, this)
            }
        },
        controlOperaLoad: function(b) {
            this.onloadDone || (r || !b && this.isInBody() ? this.readyFun() : g(this.controlOperaLoad, i, this, [b]))
        },
        isInBody: function() {
            return typeof document.getElementsByTagName < "u" && typeof document.getElementById < "u" && (document.getElementsByTagName("body")[0] != null || document.body != null)
        }
    };
    return v.readyFun = c(v),
    v.closeFun = l(v),
    v.beforeCloseFun = u(v),
    vt.isBrowserDocument() ? v.attachToWindow() : v.asynchExecution(),
    v.addOnloadHandler = v.addOnloadHandler,
    v.addUnloadHandler = v.addUnloadHandler,
    v.addBeforeUnloadHandler = v.addBeforeUnloadHandler,
    v.removeOnloadHandler = v.removeOnloadHandler,
    v.removeUnloadHandler = v.removeUnloadHandler,
    v.removeBeforeUnloadHandler = v.removeBeforeUnloadHandler,
    v.isLoaded = v.isLoaded,
    v.isUnloaded = v.isUnloaded,
    v.isUnloading = v.isUnloading,
    v
}()
  , Ug = "Lightstreamer"
  , Ut = {
    wstatus: Bt,
    toString: function() {
        return "[" + Ug + " " + this.library + " client version " + this.version + " build " + this.build + "]"
    },
    exportGlobal: function(e, t, n, i) {
        i = i || "_";
        var r = i + e;
        return this[r] || (this[r] = {}),
        this[r][t] = n,
        Ug + "." + r + "." + t
    },
    hasGlobal: function(e, t, n) {
        n = n || "_";
        var i = n + e;
        return this[i] && this[i][t]
    },
    getGlobal: function(e, t, n) {
        n = n || "_";
        var i = n + e;
        return this[i] ? this[i][t] : null
    },
    cleanGlobal: function(e, t, n) {
        n = n || "_";
        var i = n + e;
        if (this[i] && this[i][t]) {
            delete this[i][t];
            for (var r in this[i])
                return;
            delete this[i]
        }
    },
    cleanAllGlobals: function(e, t) {
        t = t || "_";
        var n = t + e;
        this[n] && delete this[n]
    },
    localSharedEngines: {},
    addSharableEngine: function(e, t) {
        var n = this.localSharedEngines;
        n[e] || (n[e] = []),
        n[e].push(t)
    },
    removeSharableEngine: function(e, t) {
        var n = this.localSharedEngines[e];
        if (n) {
            for (var i = 0; i < n.length; i++)
                n[i] == t && n.splice(i, 1);
            n.length == 0 && delete n[e]
        }
    },
    getSharableEngine: function(e) {
        if (this.localSharedEngines[e]) {
            var t = this.localSharedEngines[e];
            if (t && t.length > 0)
                return t[0]
        }
        return null
    }
};
vt.isBrowserDocument() && (window.OpenAjax && window.OpenAjax.hub && window.OpenAjax.hub.registerLibrary(Ug, "http://www.lightstreamer.com/", Ut.version),
window.Lightstreamer = Ut);
Ut.library = G.LIBRARY_NAME;
Ut.version = G.LIBRARY_VERSION;
Ut.build = G.BUILD;
var Se = function() {
    var e = 50
      , t = !1
      , n = []
      , i = Et.getTimeStamp()
      , r = 3 * 60 * 60 * 1e3
      , s = i + r
      , o = []
      , a = null
      , c = 0;
    function l(w, k) {
        return w.time === k.time ? w.orderId - k.orderId : w.time - k.time
    }
    var u = vt.isBrowserDocument() && (document.location.protocol == "http:" || document.location.protocol == "https:") ? document.location.protocol + "//" + document.location.hostname + (document.location.port ? ":" + document.location.port : "") : "*"
      , h = function() {}
      , d = h
      , f = !1;
    function g() {
        f = !1,
        b()
    }
    function p() {
        f || (f = !0,
        d())
    }
    function v() {
        if (a)
            clearInterval(a);
        else if (vt.isBrowserDocument() && typeof postMessage < "u") {
            d = function() {
                try {
                    window.postMessage("Lightstreamer.run", u)
                } catch {
                    try {
                        window.postMessage("Lightstreamer.run", u)
                    } catch {}
                }
            }
            ;
            var w = function(k) {
                (k.data == "Lightstreamer.run" && u == "*" || k.origin == u) && g()
            };
            Et.addEvent(window, "message", w),
            p(),
            f == !1 && (Et.removeEvent(window, "message", w),
            d = h)
        } else
            vt.isNodeJS() && typeof process < "u" && process.nextTick && (d = function() {
                process.nextTick(g)
            }
            );
        a = setInterval(b, e)
    }
    function b() {
        if (Bt.unloaded) {
            clearInterval(a);
            return
        }
        var w = i;
        if (i = Et.getTimeStamp(),
        i < w && (i = w),
        n.length > 0) {
            t && (n.sort(l),
            t = !1);
            for (var k; n.length > 0 && n[0].time <= i && !Bt.unloaded; )
                k = n.shift(),
                k.fun && (S.executeTask(k),
                k.step && o.push(k))
        }
        n.length <= 0 && (c = 0);
        for (var B; o.length > 0; )
            B = o.shift(),
            B.step && (B.orderId = c++,
            S.addPackedTimedTask(B, B.step, !0));
        i >= s && (s = i + r,
        n = [].concat(n))
    }
    var S = {
        toString: function() {
            return ["[", "Executor", e, n.length, "]"].join("|")
        },
        getQueueLength: function() {
            return n.length
        },
        packTask: function(w, k, B) {
            return {
                fun: w,
                context: k || null,
                params: B || null,
                orderId: c++
            }
        },
        addPackedTimedTask: function(w, k, B) {
            if (w.step = B ? k : null,
            w.time = i + parseInt(k),
            isNaN(w.time))
                try {
                    throw new Error
                } catch (E) {
                    var N = "Executor error for time: " + k;
                    throw E.stack && (N += " " + E.stack),
                    N
                }
            n.push(w),
            t = !0
        },
        addRepetitiveTask: function(w, k, B, N) {
            return this.addTimedTask(w, k, B, N, !0)
        },
        stopRepetitiveTask: function(w) {
            w && (w.fun = null,
            w.step = null)
        },
        addTimedTask: function(w, k, B, N, E) {
            var F = this.packTask(w, B, N);
            return this.addPackedTimedTask(F, k, E),
            k == 0 && p(),
            F
        },
        modifyTaskParam: function(w, k, B) {
            w.params[k] = B
        },
        modifyAllTaskParams: function(w, k) {
            w.params = k
        },
        delayTask: function(w, k) {
            w.time += k,
            t = !0
        },
        executeTask: function(w, k) {
            try {
                var B = k || w.params;
                w.context ? B ? w.fun.apply(w.context, B) : w.fun.apply(w.context) : B ? w.fun.apply(null, B) : w.fun()
            } catch {
                var N = null;
                try {
                    N = w.fun.name || w.fun.toString()
                } catch {}
            }
        }
    };
    return vt.isWebWorker() ? setTimeout(v, 1) : v(),
    S.getQueueLength = S.getQueueLength,
    S.packTask = S.packTask,
    S.addPackedTimedTask = S.addPackedTimedTask,
    S.addRepetitiveTask = S.addRepetitiveTask,
    S.stopRepetitiveTask = S.stopRepetitiveTask,
    S.addTimedTask = S.addTimedTask,
    S.modifyTaskParam = S.modifyTaskParam,
    S.modifyAllTaskParams = S.modifyAllTaskParams,
    S.delayTask = S.delayTask,
    S.executeTask = S.executeTask,
    S
}()
  , nS = function() {
    var e = function() {
        return !1
    }
      , t = {
        error: e,
        warn: e,
        info: e,
        debug: e,
        fatal: e,
        isDebugEnabled: e,
        isInfoEnabled: e,
        isWarnEnabled: e,
        isErrorEnabled: e,
        isFatalEnabled: e
    }
      , n = function(i) {
        this.setWrappedInstance(i)
    };
    return n.prototype = {
        setWrappedInstance: function(i) {
            this.wrappedLogger = i || t
        },
        logFatal: function(i) {
            this.isFatalLogEnabled() && (i += this.logArguments(arguments, 1),
            this.fatal(i))
        },
        fatal: function(i, r) {
            this.wrappedLogger.fatal(i, r)
        },
        isFatalLogEnabled: function() {
            return !this.wrappedLogger.isFatalEnabled || this.wrappedLogger.isFatalEnabled()
        },
        logError: function(i) {
            this.isErrorLogEnabled() && (i += this.logArguments(arguments, 1),
            this.error(i))
        },
        logErrorExc: function(i, r) {
            this.isErrorLogEnabled() && (r += this.logArguments(arguments, 2),
            this.error(r, i))
        },
        error: function(i, r) {
            this.wrappedLogger.error(i, r)
        },
        isErrorLogEnabled: function() {
            return !this.wrappedLogger.isErrorEnabled || this.wrappedLogger.isErrorEnabled()
        },
        logWarn: function(i) {
            this.isWarnLogEnabled() && (i += this.logArguments(arguments, 1),
            this.warn(i))
        },
        warn: function(i, r) {
            this.wrappedLogger.warn(i, r)
        },
        isWarnLogEnabled: function() {
            return !this.wrappedLogger.isWarnEnabled || this.wrappedLogger.isWarnEnabled()
        },
        logInfo: function(i) {
            this.isInfoLogEnabled() && (i += this.logArguments(arguments, 1),
            this.info(i))
        },
        info: function(i, r) {
            this.wrappedLogger.info(i, r)
        },
        isInfoLogEnabled: function() {
            return !this.wrappedLogger.isInfoEnabled || this.wrappedLogger.isInfoEnabled()
        },
        logDebug: function(i) {
            this.isDebugLogEnabled() && (i += this.logArguments(arguments, 1),
            this.debug(i))
        },
        debug: function(i, r) {
            this.wrappedLogger.debug(i, r)
        },
        isDebugLogEnabled: function() {
            return !this.wrappedLogger.isDebugEnabled || this.wrappedLogger.isDebugEnabled()
        },
        logArguments: function(i, r) {
            r = r || 0;
            for (var s = " {", o = r; o < i.length; o++)
                try {
                    var a = i[o];
                    a === null ? s += "NULL" : a.length < 0 ? s += "*" : a.charAt != null ? s += a : a.message ? (s += a.message,
                    a.stack && (s += `
` + a.stack + `
`)) : a[0] == a ? s += a : Et.isArray(a) ? (s += "(",
                    s += this.logArguments(a),
                    s += ")") : s += a,
                    s += " "
                } catch {
                    s += "??? "
                }
            return s + "}"
        }
    },
    n.prototype.debug = n.prototype.debug,
    n.prototype.isDebugLogEnabled = n.prototype.isDebugLogEnabled,
    n.prototype.logDebug = n.prototype.logDebug,
    n.prototype.info = n.prototype.info,
    n.prototype.isInfoLogEnabled = n.prototype.isInfoLogEnabled,
    n.prototype.logInfo = n.prototype.logInfo,
    n.prototype.warn = n.prototype.warn,
    n.prototype.isWarnEnabled = n.prototype.isWarnEnabled,
    n.prototype.logWarn = n.prototype.logWarn,
    n.prototype.error = n.prototype.error,
    n.prototype.isErrorEnabled = n.prototype.isErrorEnabled,
    n.prototype.logError = n.prototype.logError,
    n.prototype.logErrorExc = n.prototype.logErrorExc,
    n.prototype.fatal = n.prototype.fatal,
    n.prototype.isFatalEnabled = n.prototype.isFatalEnabled,
    n.prototype.logFatal = n.prototype.logFatal,
    n
}()
  , ct = function() {
    var e = function(t) {
        this.name = "IllegalArgumentException",
        this.message = t
    };
    return e.prototype = {
        toString: function() {
            return ["[", this.name, this.message, "]"].join("|")
        }
    },
    e
}()
  , m = function() {
    var e = {}
      , t = null
      , n = "The given object is not a LoggerProvider"
      , i = {
        setLoggerProvider: function(r) {
            if (r && !r.getLogger)
                throw new ct(n);
            t = r;
            for (var s in e)
                t ? e[s].setWrappedInstance(t.getLogger(s)) : e[s].setWrappedInstance(null)
        },
        getLoggerProxy: function(r) {
            return e[r] || (t ? e[r] = new nS(t.getLogger(r)) : e[r] = new nS),
            e[r]
        },
        resolve: function(r) {
            return r
        }
    };
    return i.setLoggerProvider = i.setLoggerProvider,
    i.getLoggerProxy = i.getLoggerProxy,
    i.resolve = i.resolve,
    i
}()
  , Ke = function() {
    var e = new RegExp("\\.","g")
      , t = new RegExp("-","g")
      , n = 1
      , i = 1
      , r = {
        isOffline: function() {
            return vt.isBrowser() ? navigator.onLine === !1 : !1
        },
        canUseLocalStorage: function() {
            try {
                if (typeof localStorage < "u" && localStorage !== null && localStorage.getItem && localStorage.setItem) {
                    var s = "__canUseLocalStorage_test__"
                      , o = "true";
                    return localStorage.setItem(s, o),
                    localStorage.removeItem(s),
                    !0
                } else
                    return !1
            } catch {
                return !1
            }
        },
        getDomain: function() {
            try {
                return document.domain
            } catch {
                return ""
            }
        },
        hasDefaultDomain: function() {
            if (!vt.isBrowserDocument())
                return !0;
            try {
                var s = document.location.host;
                return s.indexOf("[") > -1 ? !0 : r.getDomain() == document.location.hostname
            } catch {
                return !1
            }
        },
        copyByValue: function(s) {
            if (typeof s < "u") {
                if (s === !0 || s === !1)
                    return s === !0;
                if (s == null)
                    return null;
                if (typeof s == "number" || s instanceof Number)
                    return Number(s);
                if (Et.isArray(s)) {
                    for (var o = [], a = 0; a < s.length; a++)
                        o[a] = this.copyByValue(s[a]);
                    return o
                } else {
                    if (typeof s == "string" || s instanceof String)
                        return String(s);
                    if (s.length === -1)
                        return G.UNCHANGED;
                    if (isNaN(s) && typeof s == "number")
                        return NaN;
                    var c = {};
                    for (var a in s)
                        c[this.copyByValue(a)] = this.copyByValue(s[a]);
                    return c
                }
            }
            return null
        },
        extendObj: function(s, o) {
            if (s = s || {},
            o)
                for (var a in o)
                    s[a] = o[a];
            return s
        },
        sanitizeIFrameName: function(s) {
            return s.replace(e, "_").replace(t, "__")
        },
        getReverse: function(s) {
            var o = {};
            for (var a in s)
                o[s[a]] = a;
            return o
        },
        argumentsToArray: function(s) {
            if (s && !s.pop) {
                for (var o = [], a = 0; a < s.length; a++)
                    o.push(s[a]);
                return o
            }
            return s
        },
        parseSetCookieHeader: function(s) {
            if (!s)
                return [];
            for (var o = {
                i: 0,
                next: function() {
                    return s.charAt(this.i++)
                }
            }, a = /^\s*Expires/i, c = [], l = o.next(); l; ) {
                for (var u = "", h = ""; l && l != ";" && l != ","; )
                    h += l,
                    l = o.next();
                for (h = h.trim(),
                u += h,
                l == ";" && (u += "; ",
                l = o.next()); l && l != ","; ) {
                    for (var d = ""; l && l != ";" && l != ","; )
                        d += l,
                        l = o.next();
                    if (d.match(a))
                        for (console.assert(l == ","),
                        d += l,
                        l = o.next(); l && l != ";" && l != ","; )
                            d += l,
                            l = o.next();
                    d = d.trim(),
                    u += d,
                    l == ";" && (u += "; ",
                    l = o.next())
                }
                c.push(u),
                l = o.next()
            }
            return c
        },
        nextRequestId: function() {
            return n++
        },
        nextSubscriptionId: function() {
            return i++
        },
        defer: function() {
            var s, o, a = new Promise(function(c, l) {
                s = c,
                o = l
            }
            );
            return a.resolve = s,
            a.reject = o,
            a
        }
    };
    return r
}()
  , ot = function() {
    function e(i, r, s) {
        if (r)
            return s ? r.apply(i, s) : r.apply(i)
    }
    function t(i, r) {
        for (var s in i)
            if (i[r] == i[s] && r != s)
                return s;
        return null
    }
    var n = {
        Inheritance: function(i, r, s, o) {
            for (var a in r.prototype)
                if (!i.prototype[a])
                    i.prototype[a] = r.prototype[a];
                else if (o) {
                    var c = t(r.prototype, a);
                    if (c) {
                        if (i.prototype[c] && i.prototype[c] !== i.prototype[a] && r.prototype[c] !== r.prototype[c])
                            throw new St("Can't solve alias collision, try to minify the classes again (" + c + ", " + a + ")");
                        i.prototype[c] = i.prototype[a]
                    }
                }
            return s || (i.prototype._super_ = r,
            i.prototype._callSuperConstructor = n._callSuperConstructor,
            i.prototype._callSuperMethod = n._callSuperMethod),
            i
        },
        _callSuperMethod: function(i, r, s) {
            return e(this, i.prototype._super_.prototype[r], s)
        },
        _callSuperConstructor: function(i, r) {
            e(this, i.prototype._super_, r)
        }
    };
    return n.Inheritance
}()
  , O3 = function() {
    var e = "The given value is not valid. "
      , t = "Use a number"
      , n = "Use an integer"
      , i = "Use a positive number"
      , r = " or 0"
      , s = "Use true or false"
      , o = function() {};
    function a(l, u, h) {
        var d = new Number(l);
        if (isNaN(d))
            throw new ct(e + t);
        if (!h && d != Math.round(d))
            throw new ct(e + n);
        if (u) {
            if (l < 0)
                throw new ct(e + i + r)
        } else if (l <= 0)
            throw new ct(e + i);
        return d
    }
    function c(l, u) {
        if (l === !0 || l === !1 || u && !l)
            return l === !0;
        throw new ct(e + s)
    }
    return o.prototype.checkPositiveNumber = a,
    o.prototype.checkBool = c,
    o.prototype.checkPositiveNumber = a,
    o.prototype.checkBool = c,
    o
}()
  , Lle = m.getLoggerProxy(G.ACTIONS)
  , Ble = m.getLoggerProxy(G.SHARING)
  , s1 = function(e) {
    this.constr = "Bean",
    this.parent = null,
    this.broadcastSimples = !1,
    e && this.copySettings(e)
};
s1.prototype = {
    getPropName: function(e) {
        return this.varNames[e]
    },
    simpleSetter: function(e, t) {
        var n = this.getPropName(e)
          , i = this[n];
        this[n] = Ke.copyByValue(t),
        this.parent && this.broadcastSimples && this.broadcastSetting(e),
        i != this[n] && this.notifyChange(e)
    },
    getValueForLog: function(e) {
        return this.doNotLogValueList && this.doNotLogValueList[e] ? "[...]" : this[e]
    },
    heavySetter: function(e, t) {
        var n = this.getPropName(e);
        t != this[n] && (this[n] = t,
        this.broadcastSetting(e),
        this.notifyChange(e))
    },
    setBroadcaster: function(e, t) {
        this.parent = e,
        this.broadcastSimples = t
    },
    broadcastSetting: function(e) {
        var t = this.getPropName(e);
        return !(this.parent && this.parent.broadcastSetting && !this.parent.broadcastSetting(this.constr, e, Ke.copyByValue(this[t])))
    },
    notifyChange: function(e) {
        var t = this.getPropName(e);
        if (this.parent && this.parent.notifyOptionChange) {
            if (this.noNotificationList && this.noNotificationList[t])
                return;
            this.parent.notifyOptionChange(e, this)
        }
    },
    copySettings: function(e) {
        var t = this.varNames;
        for (var n in t)
            this.simpleSetter(n, e[t[n]])
    },
    forEachProperty: function(e) {
        for (var t in this.varNames)
            e(t, this[this.varNames[t]])
    }
};
ot(s1, O3, !1, !0);
var yN = {}
  , Hg = {
    connectionRequested: "connectionRequested",
    clientsCount: "clientsCount"
};
Hg = Ke.getReverse(Hg);
var o1 = function(e) {
    this.connectionRequested = !1,
    this.clientsCount = 0,
    this.noNotificationList = yN,
    this.varNames = Hg,
    this._callSuperConstructor(o1, arguments),
    this.constr = "Configuration"
};
o1.prototype = {
    getConnectionRequested: function() {
        return this.connectionRequested
    },
    getClientsCount: function() {
        return this.clientsCount
    }
};
ot(o1, s1);
var r3 = m.getLoggerProxy(G.SESSION)
  , US = function(e) {
    this.initRetryDelay(e)
};
US.prototype = {
    resetRetryDelay: function(e) {
        this.initRetryDelay(e),
        r3.isDebugLogEnabled() && r3.debug("Reset currentRetryDelay: " + this.currentRetryDelay)
    },
    increaseRetryDelay: function() {
        this.retryAttempt >= 9 && this.currentRetryDelay < this.maxRetryDelay && (this.currentRetryDelay *= 2,
        this.currentRetryDelay > this.maxRetryDelay && (this.currentRetryDelay = this.maxRetryDelay),
        r3.isDebugLogEnabled() && r3.debug("Increase currentRetryDelay: " + this.currentRetryDelay)),
        this.retryAttempt++
    },
    initRetryDelay: function(e) {
        this.currentRetryDelay = e,
        this.minRetryDelay = e,
        this.maxRetryDelay = Math.max(6e4, e),
        this.retryAttempt = 0
    }
};
var vu = m.getLoggerProxy(G.SESSION)
  , HS = function(e) {
    this.initConnectTimeout(e)
};
HS.prototype = {
    resetConnectTimeout: function(e) {
        this.initConnectTimeout(e),
        vu.isDebugLogEnabled() && vu.debug("Reset currentConnectTimeout: " + this.currentConnectTimeout)
    },
    increaseConnectTimeout: function() {
        this.connectAttempt >= 9 && this.currentConnectTimeout < this.maxConnectTimeout && (this.currentConnectTimeout *= 2,
        this.currentConnectTimeout > this.maxConnectTimeout && (this.currentConnectTimeout = this.maxConnectTimeout),
        vu.isDebugLogEnabled() && vu.debug("Increase currentConnectTimeout: " + this.currentConnectTimeout)),
        this.connectAttempt++
    },
    increaseConnectTimeoutToMax: function() {
        this.currentConnectTimeout = this.maxConnectTimeout,
        vu.isDebugLogEnabled() && vu.debug("Increase currentConnectTimeout to max: " + this.currentConnectTimeout)
    },
    initConnectTimeout: function(e) {
        this.currentConnectTimeout = e,
        this.minConnectTimeout = e,
        this.maxConnectTimeout = Math.max(6e4, e),
        this.connectAttempt = 0
    }
};
var ql = {};
ql[G.HTTP_STREAMING] = !0;
ql[G.WS_POLLING] = !0;
ql[G.HTTP_POLLING] = !0;
ql[G.WS_STREAMING] = !0;
ql[G.WS_ALL] = !0;
ql[G.HTTP_ALL] = !0;
var bN = "The given value is not valid. Use one of: HTTP-STREAMING, HTTP-POLLING, WS-STREAMING, WS-POLLING, WS, HTTP or null"
  , Gg = {
    contentLength: "contentLength",
    idleTimeout: "idleTimeout",
    keepaliveInterval: "keepaliveInterval",
    requestedMaxBandwidth: "requestedMaxBandwidth",
    realMaxBandwidth: "realMaxBandwidth",
    pollingInterval: "pollingInterval",
    reconnectTimeout: "reconnectTimeout",
    stalledTimeout: "stalledTimeout",
    retryDelay: "retryDelay",
    firstRetryMaxDelay: "firstRetryMaxDelay",
    slowingEnabled: "slowingEnabled",
    forcedTransport: "forcedTransport",
    serverInstanceAddressIgnored: "serverInstanceAddressIgnored",
    cookieHandlingRequired: "cookieHandlingRequired",
    reverseHeartbeatInterval: "reverseHeartbeatInterval",
    earlyWSOpenEnabled: "earlyWSOpenEnabled",
    sessionRecoveryTimeout: "sessionRecoveryTimeout",
    spinFixTimeout: "spinFixTimeout",
    spinFixEnabled: "spinFixEnabled",
    xDomainStreamingEnabled: "xDomainStreamingEnabled",
    corsXHREnabled: "corsXHREnabled",
    forceBindTimeout: "forceBindTimeout",
    switchCheckTimeout: "switchCheckTimeout",
    httpExtraHeaders: "httpExtraHeaders",
    httpExtraHeadersOnSessionCreationOnly: "httpExtraHeadersOnSessionCreationOnly",
    remoteAdapterStatusObserver: "remoteAdapterStatusObserver",
    currentRetryDelay: "currentRetryDelay",
    minRetryDelay: "minRetryDelay",
    maxRetryDelay: "maxRetryDelay",
    retryAttempt: "retryAttempt",
    currentConnectTimeout: "currentConnectTimeout",
    minConnectTimeout: "minConnectTimeout",
    maxConnectTimeout: "maxConnectTimeout",
    connectAttempt: "connectAttempt"
};
Gg = Ke.getReverse(Gg);
var ae = function() {
    this.contentLength = 4e6,
    this.idleTimeout = 19e3,
    this.keepaliveInterval = 0,
    this.requestedMaxBandwidth = -1,
    this.pollingInterval = 0,
    this.reconnectTimeout = 3e3,
    this.stalledTimeout = 2e3,
    this.retryDelay = 4e3,
    this.initRetryDelay(this.retryDelay),
    this.initConnectTimeout(this.retryDelay),
    this.firstRetryMaxDelay = 100,
    this.slowingEnabled = !1,
    this.forcedTransport = null,
    this.serverInstanceAddressIgnored = !1,
    this.cookieHandlingRequired = !1,
    this.reverseHeartbeatInterval = 0,
    this.earlyWSOpenEnabled = !1,
    this.spinFixTimeout = 5e3,
    this.spinFixEnabled = null,
    this.httpExtraHeaders = null,
    this.httpExtraHeadersOnSessionCreationOnly = !1,
    this.sessionRecoveryTimeout = 15e3,
    this.xDomainStreamingEnabled = !0,
    this.corsXHREnabled = !0,
    this.forceBindTimeout = 2e3,
    this.switchCheckTimeout = 4e3,
    this.remoteAdapterStatusObserver = {},
    this.varNames = Gg,
    this._callSuperConstructor(ae, arguments),
    this.constr = "ConnectionOptions"
};
ae.prototype = {
    setContentLength: function(e) {
        this.heavySetter("contentLength", this.checkPositiveNumber(e))
    },
    getContentLength: function() {
        return this.contentLength
    },
    setIdleTimeout: function(e) {
        this.heavySetter("idleTimeout", this.checkPositiveNumber(e, !0))
    },
    getIdleTimeout: function() {
        return this.idleTimeout
    },
    setKeepaliveInterval: function(e) {
        this.heavySetter("keepaliveInterval", this.checkPositiveNumber(e, !0))
    },
    getKeepaliveInterval: function() {
        return this.keepaliveInterval
    },
    setRequestedMaxBandwidth: function(e) {
        var t = new String(e);
        t.toLowerCase() == "unlimited" ? e = 0 : e = this.checkPositiveNumber(e, !1, !0),
        this.heavySetter("requestedMaxBandwidth", e)
    },
    getRequestedMaxBandwidth: function() {
        return this.requestedMaxBandwidth <= 0 ? "unlimited" : this.requestedMaxBandwidth
    },
    getRealMaxBandwidth: function() {
        return this.realMaxBandwidth
    },
    setPollingInterval: function(e) {
        this.heavySetter("pollingInterval", this.checkPositiveNumber(e, !0))
    },
    getPollingInterval: function() {
        return this.pollingInterval
    },
    setReconnectTimeout: function(e) {
        this.heavySetter("reconnectTimeout", this.checkPositiveNumber(e))
    },
    getReconnectTimeout: function() {
        return this.reconnectTimeout
    },
    setStalledTimeout: function(e) {
        this.heavySetter("stalledTimeout", this.checkPositiveNumber(e))
    },
    getStalledTimeout: function() {
        return this.stalledTimeout
    },
    setConnectTimeout: function(e) {},
    getConnectTimeout: function() {
        return String(this.getRetryDelay())
    },
    setCurrentConnectTimeout: function(e) {},
    getCurrentConnectTimeout: function() {
        return this.currentConnectTimeout
    },
    setRetryDelay: function(e) {
        var t = this.checkPositiveNumber(e);
        this.heavySetter("retryDelay", t),
        this.resetRetryDelay(t),
        this.resetConnectTimeout(t)
    },
    getRetryDelay: function() {
        return this.retryDelay
    },
    setFirstRetryMaxDelay: function(e) {
        this.heavySetter("firstRetryMaxDelay", this.checkPositiveNumber(e))
    },
    getFirstRetryMaxDelay: function() {
        return this.firstRetryMaxDelay
    },
    setSlowingEnabled: function(e) {
        this.heavySetter("slowingEnabled", this.checkBool(e))
    },
    isSlowingEnabled: function() {
        return this.slowingEnabled
    },
    setForcedTransport: function(e) {
        if (e !== null && !ql[e])
            throw new ct(bN);
        this.heavySetter("forcedTransport", e)
    },
    getForcedTransport: function() {
        return this.forcedTransport
    },
    setServerInstanceAddressIgnored: function(e) {
        this.heavySetter("serverInstanceAddressIgnored", this.checkBool(e))
    },
    isServerInstanceAddressIgnored: function() {
        return this.serverInstanceAddressIgnored
    },
    setCookieHandlingRequired: function(e) {
        this.heavySetter("cookieHandlingRequired", this.checkBool(e))
    },
    isCookieHandlingRequired: function() {
        return this.cookieHandlingRequired
    },
    setEarlyWSOpenEnabled: function(e) {
        this.heavySetter("earlyWSOpenEnabled", this.checkBool(e))
    },
    isEarlyWSOpenEnabled: function() {
        return this.earlyWSOpenEnabled
    },
    setReverseHeartbeatInterval: function(e) {
        this.heavySetter("reverseHeartbeatInterval", this.checkPositiveNumber(e, !0))
    },
    getReverseHeartbeatInterval: function() {
        return this.reverseHeartbeatInterval
    },
    setHttpExtraHeaders: function(e) {
        if (!e) {
            this.heavySetter("httpExtraHeaders", null);
            return
        }
        var t = "";
        for (var n in e)
            t += n + `
` + e[n] + `
`;
        this.heavySetter("httpExtraHeaders", t)
    },
    getHttpExtraHeaders: function() {
        if (!this.httpExtraHeaders)
            return this.httpExtraHeaders;
        for (var e = {}, t = this.httpExtraHeaders.split(`
`), n = 0; n < t.length - 1; n += 2)
            e[t[n]] = t[n + 1];
        return e
    },
    setHttpExtraHeadersOnSessionCreationOnly: function(e) {
        this.heavySetter("httpExtraHeadersOnSessionCreationOnly", this.checkBool(e))
    },
    isHttpExtraHeadersOnSessionCreationOnly: function() {
        return this.httpExtraHeadersOnSessionCreationOnly
    },
    setSessionRecoveryTimeout: function(e) {
        this.heavySetter("sessionRecoveryTimeout", this.checkPositiveNumber(e, !0))
    },
    getSessionRecoveryTimeout: function() {
        return this.sessionRecoveryTimeout
    },
    hasHttpExtraHeaders: function(e) {
        if (this.httpExtraHeaders) {
            if (e)
                return !0
        } else
            return !1;
        return !this.httpExtraHeadersOnSessionCreationOnly
    },
    extractHttpExtraHeaders: function(e) {
        return !e && this.httpExtraHeadersOnSessionCreationOnly ? null : this.getHttpExtraHeaders()
    },
    setXDomainStreamingEnabled: function(e) {
        this.heavySetter("xDomainStreamingEnabled", this.checkBool(e))
    },
    isXDomainStreamingEnabled: function() {
        return this.xDomainStreamingEnabled
    },
    setCorsXHREnabled: function(e) {
        this.heavySetter("corsXHREnabled", this.checkBool(e))
    },
    isCorsXHREnabled: function() {
        return this.corsXHREnabled
    },
    setForceBindTimeout: function(e) {
        this.heavySetter("forceBindTimeout", this.checkPositiveNumber(e))
    },
    getForceBindTimeout: function() {
        return this.forceBindTimeout
    },
    setSwitchCheckTimeout: function(e) {
        this.heavySetter("switchCheckTimeout", this.checkPositiveNumber(e))
    },
    getSwitchCheckTimeout: function() {
        return this.switchCheckTimeout
    },
    setSpinFixTimeout: function(e) {
        this.heavySetter("spinFixTimeout", this.checkPositiveNumber(e))
    },
    getSpinFixTimeout: function() {
        return this.spinFixTimeout
    },
    setSpinFixEnabled: function(e) {
        this.heavySetter("spinFixTimeout", this._enabled === null ? null : this.checkBool(e))
    },
    getSpinFixEnabled: function() {
        return this.spinFixEnabled
    },
    installRemoteAdapterStatusObserver: function(e, t, n, i) {
        this.remoteAdapterStatusObserver = {
            metadataErrorCode: e,
            dataAdapterName: t,
            statusItemName: n,
            reconnectMaxDelay: i
        }
    }
};
ae.prototype.setContentLength = ae.prototype.setContentLength;
ae.prototype.getContentLength = ae.prototype.getContentLength;
ae.prototype.setIdleTimeout = ae.prototype.setIdleTimeout;
ae.prototype.getIdleTimeout = ae.prototype.getIdleTimeout;
ae.prototype.setKeepaliveInterval = ae.prototype.setKeepaliveInterval;
ae.prototype.getKeepaliveInterval = ae.prototype.getKeepaliveInterval;
ae.prototype.setRequestedMaxBandwidth = ae.prototype.setRequestedMaxBandwidth;
ae.prototype.getRequestedMaxBandwidth = ae.prototype.getRequestedMaxBandwidth;
ae.prototype.getRealMaxBandwidth = ae.prototype.getRealMaxBandwidth;
ae.prototype.setPollingInterval = ae.prototype.setPollingInterval;
ae.prototype.getPollingInterval = ae.prototype.getPollingInterval;
ae.prototype.setReconnectTimeout = ae.prototype.setReconnectTimeout;
ae.prototype.getReconnectTimeout = ae.prototype.getReconnectTimeout;
ae.prototype.setStalledTimeout = ae.prototype.setStalledTimeout;
ae.prototype.getStalledTimeout = ae.prototype.getStalledTimeout;
ae.prototype.setConnectTimeout = ae.prototype.setConnectTimeout;
ae.prototype.getConnectTimeout = ae.prototype.getConnectTimeout;
ae.prototype.setCurrentConnectTimeout = ae.prototype.setCurrentConnectTimeout;
ae.prototype.getCurrentConnectTimeout = ae.prototype.getCurrentConnectTimeout;
ae.prototype.setRetryDelay = ae.prototype.setRetryDelay;
ae.prototype.getRetryDelay = ae.prototype.getRetryDelay;
ae.prototype.setFirstRetryMaxDelay = ae.prototype.setFirstRetryMaxDelay;
ae.prototype.getFirstRetryMaxDelay = ae.prototype.getFirstRetryMaxDelay;
ae.prototype.setSlowingEnabled = ae.prototype.setSlowingEnabled;
ae.prototype.isSlowingEnabled = ae.prototype.isSlowingEnabled;
ae.prototype.setForcedTransport = ae.prototype.setForcedTransport;
ae.prototype.getForcedTransport = ae.prototype.getForcedTransport;
ae.prototype.setServerInstanceAddressIgnored = ae.prototype.setServerInstanceAddressIgnored;
ae.prototype.isServerInstanceAddressIgnored = ae.prototype.isServerInstanceAddressIgnored;
ae.prototype.setCookieHandlingRequired = ae.prototype.setCookieHandlingRequired;
ae.prototype.isCookieHandlingRequired = ae.prototype.isCookieHandlingRequired;
ae.prototype.setEarlyWSOpenEnabled = ae.prototype.setEarlyWSOpenEnabled;
ae.prototype.isEarlyWSOpenEnabled = ae.prototype.isEarlyWSOpenEnabled;
ae.prototype.setReverseHeartbeatInterval = ae.prototype.setReverseHeartbeatInterval;
ae.prototype.getReverseHeartbeatInterval = ae.prototype.getReverseHeartbeatInterval;
ae.prototype.setHttpExtraHeaders = ae.prototype.setHttpExtraHeaders;
ae.prototype.getHttpExtraHeaders = ae.prototype.getHttpExtraHeaders;
ae.prototype.setHttpExtraHeadersOnSessionCreationOnly = ae.prototype.setHttpExtraHeadersOnSessionCreationOnly;
ae.prototype.isHttpExtraHeadersOnSessionCreationOnly = ae.prototype.isHttpExtraHeadersOnSessionCreationOnly;
ae.prototype.setSessionRecoveryTimeout = ae.prototype.setSessionRecoveryTimeout;
ae.prototype.getSessionRecoveryTimeout = ae.prototype.getSessionRecoveryTimeout;
ae.prototype.setXDomainStreamingEnabled = ae.prototype.setXDomainStreamingEnabled;
ae.prototype.isXDomainStreamingEnabled = ae.prototype.isXDomainStreamingEnabled;
ae.prototype.setCorsXHREnabled = ae.prototype.setCorsXHREnabled;
ae.prototype.isCorsXHREnabled = ae.prototype.isCorsXHREnabled;
ae.prototype.setForceBindTimeout = ae.prototype.setForceBindTimeout;
ae.prototype.getForceBindTimeout = ae.prototype.getForceBindTimeout;
ae.prototype.setSwitchCheckTimeout = ae.prototype.setSwitchCheckTimeout;
ae.prototype.getSwitchCheckTimeout = ae.prototype.getSwitchCheckTimeout;
ae.prototype.setSpinFixTimeout = ae.prototype.setSpinFixTimeout;
ae.prototype.getSpinFixTimeout = ae.prototype.getSpinFixTimeout;
ae.prototype.setSpinFixEnabled = ae.prototype.setSpinFixEnabled;
ae.prototype.getSpinFixEnabled = ae.prototype.getSpinFixEnabled;
ae.prototype.setRetryTimeout = ae.prototype.setRetryDelay;
ae.prototype.getRetryTimeout = ae.prototype.getRetryDelay;
ae.prototype.setIdleMillis = ae.prototype.setIdleTimeout;
ae.prototype.getIdleMillis = ae.prototype.getIdleTimeout;
ae.prototype.setKeepaliveMillis = ae.prototype.setKeepaliveInterval;
ae.prototype.getKeepaliveMillis = ae.prototype.getKeepaliveInterval;
ae.prototype.setPollingMillis = ae.prototype.setPollingInterval;
ae.prototype.getPollingMillis = ae.prototype.getPollingInterval;
ae.prototype.setReverseHeartbeatMillis = ae.prototype.setReverseHeartbeatInterval;
ae.prototype.getReverseHeartbeatMillis = ae.prototype.getReverseHeartbeatInterval;
ot(ae, s1);
ot(ae, US, !0);
ot(ae, HS, !0);
var ut = function() {
    var e = m.getLoggerProxy("weswit.test")
      , t = 0
      , n = {}
      , i = {
        VOID: n,
        getFailures: function() {
            return t
        },
        compareArrays: function(r, s, o) {
            if (r.length != s.length)
                return this.failInternal(),
                e.logError(m.resolve(497), r, s),
                !1;
            if (o) {
                for (var c = 0; c < r.length; c++)
                    if (r[c] != s[c])
                        return e.logError(m.resolve(500), r[c], s[c]),
                        this.failInternal(),
                        !1
            } else {
                for (var a = {}, c = 0; c < r.length; c++)
                    a[r[c]] = 1;
                for (var c = 0; c < s.length; c++)
                    if (a[s[c]])
                        a[s[c]]++;
                    else
                        return e.logError(m.resolve(498), s[c]),
                        this.failInternal(),
                        !1;
                for (var c in a)
                    if (a[c] == 1)
                        return e.logError(m.resolve(499), a[c]),
                        this.failInternal(),
                        !1
            }
            return !0
        },
        verifySuccess: function(r, s, o, a, c) {
            return this.verify(r, s, o, a, !1, c)
        },
        verifyException: function(r, s, o) {
            return this.verify(r, s, o, null, !0)
        },
        verifyNotNull: function(r) {
            return r === null ? (this.failInternal(),
            e.logError(m.resolve(501), r),
            !1) : !0
        },
        verifyValue: function(r, s, o) {
            var a = !1;
            if (o === !0)
                a = r === s;
            else if (o)
                a = o(r, s);
            else if (isNaN(r))
                a = r == s;
            else {
                var c = r && r.charAt ? r.charAt(0) : null
                  , l = s && s.charAt ? s.charAt(0) : null;
                c == "." || c == " " || c == "0" || l == "." || l == " " || l == "0" ? a = String(r) == String(s) : a = r == s
            }
            return a ? !0 : (this.failInternal(),
            e.logError(m.resolve(502), r, s),
            !1)
        },
        verifyDiffValue: function(r, s, o) {
            var a = !1;
            return o ? a = r !== s : a = r != s,
            a ? !0 : (this.failInternal(),
            e.logError(m.resolve(503), r, s),
            !1)
        },
        verifyOk: function(r) {
            return r ? !0 : (this.failInternal(),
            e.logError(m.resolve(504)),
            !1)
        },
        verifyNotOk: function(r) {
            return r ? (this.failInternal(),
            e.logError(m.resolve(505)),
            !1) : !0
        },
        fail: function() {
            return e.logError(m.resolve(506)),
            this.failInternal(),
            !1
        },
        failInternal: function() {
            t++
        },
        verify: function(r, s, o, a, c, l) {
            var u = !1
              , h = null
              , d = null;
            try {
                o !== n ? h = r[s].apply(r, o) : h = r[s]()
            } catch (p) {
                u = !0,
                d = p
            }
            var f = c ? "succes" : "failure"
              , g = c == u;
            return g ? !c && a !== n ? this.verifyValue(h, a, l) : !0 : (this.failInternal(),
            e.logError(m.resolve(507), f, "for", s, o, a, d),
            !1)
        }
    };
    return i.getFailures = i.getFailures,
    i.fail = i.fail,
    i.verifyNotOk = i.verifyNotOk,
    i.verifyOk = i.verifyOk,
    i.verifyDiffValue = i.verifyDiffValue,
    i.verifyNotNull = i.verifyNotNull,
    i.verifyValue = i.verifyValue,
    i.verifyException = i.verifyException,
    i.verifySuccess = i.verifySuccess,
    i.compareArrays = i.compareArrays,
    i
}()
  , _u = m.getLoggerProxy(G.PROTOCOL)
  , iS = "STREAMING_IN_PROGRESS"
  , rS = "bind_session"
  , SN = "create_session"
  , sS = "LS_cid=" + G.LS_CID + "&"
  , xN = new RegExp("^[a-z][a-z0-9-]+$")
  , wN = new RegExp("^((?:[a-z][a-z.0-9-]+).(?:[a-z][a-z-]+))(?![\\w.])")
  , CN = new RegExp("^((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))(?![d])")
  , EN = new RegExp("^[a-f0-9:]+$")
  , io = {
    verifyServerAddress: function(e) {
        e = e.toLowerCase();
        var t = e.indexOf("http://") == 0 ? 7 : e.indexOf("https://") == 0 ? 8 : -1;
        if (t == -1)
            return "The given server address has not a valid scheme";
        var n = e.lastIndexOf(":");
        n = n > t ? n : e.length;
        var i = this.extractPort(e, e.indexOf("://"));
        if (i != null && isNaN(i.substring(1)))
            return "The given server address has not a valid port";
        var r = e.indexOf("/", t);
        if (r = r < n ? r : n,
        e.charAt(t) == "[") {
            var s = e.lastIndexOf("]")
              , o = e.substring(t + 1, s);
            if (!EN.test(o))
                return "The given server address is not a valid IPv6"
        } else {
            var o = e.substring(t, r);
            if (o.indexOf(".") > -1) {
                if (!wN.test(o) && !CN.test(o))
                    return "The given server address is not a valid URL"
            } else if (!xN.test(o))
                return "The given server address is not a valid machine name"
        }
        return !0
    },
    readUrl: function(e) {
        var t = {}
          , n = e.indexOf("://");
        n != -1 ? (t.schema = e.substring(0, n),
        e = e.substring(n + 3)) : t.schema = null;
        var i = e.indexOf("/");
        i != -1 ? (t.path = e.substring(i),
        e = e.substring(0, i)) : t.path = null;
        var r = this.extractPortStart(e);
        return r != -1 ? (t.port = e.substring(r),
        t.host = e.substring(0, r - 1)) : (t.port = null,
        t.host = e),
        t
    },
    writeUrl: function(e) {
        var t = e.host;
        return e.schema != null && (t = e.schema + "://" + t),
        e.port != null && (t += ":" + e.port),
        e.path != null && (t += e.path),
        t.substring(t.length - 1) != "/" && (t += "/"),
        t
    },
    extractPortStart: function(e) {
        var t = e.indexOf(":");
        return t <= -1 ? -1 : e.indexOf("]") > -1 ? (t = e.indexOf("]:"),
        t <= -1 ? -1 : t + 2) : t != e.lastIndexOf(":") ? -1 : t + 1
    },
    completeControlLink: function(e, t) {
        var n = this.readUrl(e)
          , i = this.readUrl(t)
          , r = {
            schema: i.schema != null ? i.schema : n.schema,
            host: i.host,
            port: i.port != null ? i.port : n.port,
            path: i.path
        };
        return this.writeUrl(r)
    },
    getPushCommand: function(e, t, n, i, r, s, o, a, c, l, u, h) {
        var d = u && vt.isBrowserDocument() && !Ke.hasDefaultDomain() ? "LS_domain=" + Ke.getDomain() + "&" : ""
          , f = "LS_phase=" + e + "&" + d + (a ? "LS_cause=" + a + "&" : "");
        if (r || s) {
            f += "LS_polling=true&";
            var g = 0
              , p = 0;
            s && (g = Number(n.pollingInterval),
            c != null && !isNaN(c) && (g += c),
            p = n.idleTimeout),
            isNaN(g) || (f += "LS_polling_millis=" + g + "&"),
            isNaN(p) || (f += "LS_idle_millis=" + p + "&")
        } else
            n.keepaliveInterval > 0 && (f += "LS_keepalive_millis=" + n.keepaliveInterval + "&"),
            n.reverseHeartbeatInterval > 0 && (f += "LS_inactivity_millis=" + n.reverseHeartbeatInterval + "&"),
            l && (f += "LS_content_length=" + n.contentLength + "&");
        if (r) {
            var S = "";
            n.requestedMaxBandwidth > 0 && (S += "LS_requested_max_bandwidth=" + n.requestedMaxBandwidth + "&"),
            i.adapterSet != null && (S += "LS_adapter_set=" + encodeURIComponent(i.adapterSet) + "&"),
            i.user != null && (S += "LS_user=" + encodeURIComponent(i.user) + "&");
            var w = f + sS + S;
            return o && (w += "LS_old_session=" + o + "&"),
            h && (w += "LS_ttl=unlimited&"),
            _u.logDebug(m.resolve(510), w),
            i.password != null && (w += "LS_password=" + encodeURIComponent(i.password) + "&"),
            w
        } else {
            ut.verifyOk(t) || _u.logError(m.resolve(508));
            var v = "LS_session=" + t + "&"
              , b = v + f;
            return _u.logDebug(m.resolve(509), b),
            b
        }
    },
    getRecoveryCommand: function(e, t, n, i, r, s, o) {
        var a = s && vt.isBrowserDocument() && !Ke.hasDefaultDomain() ? "LS_domain=" + Ke.getDomain() + "&" : ""
          , c = "LS_phase=" + e + "&" + a + (i ? "LS_cause=" + i + "&" : "");
        c += "LS_polling=true&";
        var l = 0;
        return r != null && !isNaN(r) && (l += r),
        c += "LS_polling_millis=" + l + "&",
        c += "LS_idle_millis=0&",
        n.requestedMaxBandwidth > 0 && (c += "LS_requested_max_bandwidth=" + n.requestedMaxBandwidth + "&"),
        c += "LS_session=" + t + "&",
        c += "LS_recovery_from=" + o + "&",
        _u.logDebug(m.resolve(511), c),
        c
    },
    getDestroyParams: function(e, t) {
        var n = {
            LS_op: "destroy",
            LS_session: e,
            LS_reqId: Ke.nextRequestId()
        };
        return t && (n.LS_cause = t),
        _u.logDebug(m.resolve(512)),
        n
    },
    getForceRebindParams: function(e, t) {
        var n = {
            LS_op: "force_rebind",
            LS_reqId: Ke.nextRequestId()
        };
        return e && (n.LS_cause = e),
        t != null && !isNaN(t) && (n.LS_polling_millis = t),
        _u.logDebug(m.resolve(513)),
        n
    },
    getLogRequestParams: function(e, t, n) {
        return t.LS_build = n,
        t.LS_phase = e,
        t
    },
    getConstraintParams: function(e) {
        return {
            LS_op: "constrain",
            LS_requested_max_bandwidth: e.requestedMaxBandwidth > 0 ? e.requestedMaxBandwidth : "unlimited",
            LS_reqId: Ke.nextRequestId()
        }
    },
    getPushPath: function(e, t, n) {
        var i;
        return t || n != null && n.indexOf(".txt") == 0 || n == "" ? e ? i = this.getCreateSessionExtraPath() + SN + n : i = rS + n : e ? i = this.getCreateSessionExtraPath() + iS : i = iS,
        i
    },
    getRecoveryPath: function(e) {
        return rS + e
    },
    getCreateSessionExtraPath: function() {
        return ""
    },
    setCID: function(e) {
        sS = e
    },
    extractPort: function(e, t) {
        var n = e.indexOf(":", t + 1);
        if (n <= -1)
            return null;
        if (e.indexOf("]") > -1) {
            if (n = e.indexOf("]:"),
            n <= -1)
                return null;
            n += 1
        } else if (n != e.lastIndexOf(":"))
            return null;
        var i = e.indexOf("/", t + 3);
        return i > -1 ? e.substring(n, i) : e.substring(n)
    }
}
  , Vg = {
    serverAddress: "serverAddress",
    adapterSet: "adapterSet",
    user: "user",
    password: "password",
    serverInstanceAddress: "serverInstanceAddress",
    serverSocketName: "serverSocketName",
    sessionId: "sessionId",
    clientIp: "clientIp"
};
Vg = Ke.getReverse(Vg);
var TN = {
    password: !0
}
  , GS = !vt.isBrowser() || location.protocol != "http:" && location.protocol != "https:" ? null : location.protocol + "//" + location.hostname + (location.port ? ":" + location.port : "") + "/"
  , ln = function() {
    this.serverAddress = GS,
    this.adapterSet = null,
    this.user = null,
    this.password = null,
    this.serverInstanceAddress = null,
    this.serverSocketName = null,
    this.sessionId = null,
    this.doNotLogValueList = TN,
    this.varNames = Vg,
    this._callSuperConstructor(ln, arguments),
    this.constr = "ConnectionDetails"
};
ln.prototype = {
    setServerAddress: function(e) {
        if (e === null)
            e = GS;
        else {
            e.substr(e.length - 1) != "/" && (e += "/");
            var t = io.verifyServerAddress(e);
            if (t !== !0)
                throw new ct(t)
        }
        this.heavySetter("serverAddress", e)
    },
    getServerAddress: function() {
        return this.serverAddress
    },
    setAdapterSet: function(e) {
        this.heavySetter("adapterSet", e)
    },
    getAdapterSet: function() {
        return this.adapterSet
    },
    setUser: function(e) {
        this.heavySetter("user", e)
    },
    getUser: function() {
        return this.user
    },
    setPassword: function(e) {
        this.heavySetter("password", e)
    },
    getServerInstanceAddress: function() {
        return this.serverInstanceAddress
    },
    getServerSocketName: function() {
        return this.serverSocketName
    },
    getSessionId: function() {
        return this.sessionId
    },
    getClientIp: function() {
        return this.clientIp
    }
};
ln.prototype.setServerAddress = ln.prototype.setServerAddress;
ln.prototype.getServerAddress = ln.prototype.getServerAddress;
ln.prototype.setAdapterSet = ln.prototype.setAdapterSet;
ln.prototype.getAdapterSet = ln.prototype.getAdapterSet;
ln.prototype.setUser = ln.prototype.setUser;
ln.prototype.getUser = ln.prototype.getUser;
ln.prototype.setPassword = ln.prototype.setPassword;
ln.prototype.getServerInstanceAddress = ln.prototype.getServerInstanceAddress;
ln.prototype.getServerSocketName = ln.prototype.getServerSocketName;
ln.prototype.getSessionId = ln.prototype.getSessionId;
ln.prototype.getClientIp = ln.prototype.getClientIp;
ot(ln, s1);
var VS = {
    createCaller: function(e, t) {
        return t.wantsResponse ? t.addSessionPhase ? function() {
            try {
                var n = this.target[e].apply(this.target, [this.sessionPhase].concat(Ke.argumentsToArray(arguments)));
                return Promise.resolve(n)
            } catch (i) {
                return Promise.reject(i)
            }
        }
        : function() {
            try {
                var n = this.target[e].apply(this.target, arguments);
                return Promise.resolve(n)
            } catch (i) {
                return Promise.reject(i)
            }
        }
        : t.addSessionPhase ? function() {
            try {
                this.target[e].apply(this.target, [this.sessionPhase].concat(Ke.argumentsToArray(arguments)))
            } catch (n) {
                console.error(n)
            }
        }
        : function() {
            try {
                this.target[e].apply(this.target, arguments)
            } catch (n) {
                console.error(n)
            }
        }
    }
};
function Mi(e, t, n) {
    this.wantsResponse = e,
    this.addSessionPhase = t,
    this.responseTimeout = n || !1
}
var P3 = !0
  , WS = !1
  , Jg = !0
  , Zg = !1;
Mi.simple = new Mi(WS,Zg);
Mi.simpleWithResponse = new Mi(P3,Zg);
Mi.simpleWithResponseAndTimeout = new Mi(P3,Zg,2e3);
Mi.session = new Mi(WS,Jg);
Mi.sessionWithResponse = new Mi(P3,Jg);
Mi.sessionWithResponseAndTimeout = new Mi(P3,Jg,4e3);
var wg = Mi.simple
  , yu = Mi.session
  , ON = Mi.simpleWithResponseAndTimeout
  , PN = Mi.sessionWithResponse
  , Wg = {
    onClientConfigurationChange: wg,
    callConnect: yu,
    callDisconnect: yu,
    pong: ON,
    subscribeTable: PN,
    unsubscribeTable: yu,
    updateSubscriptionParams: yu,
    forwardMessage: yu,
    forwardLog: wg,
    clientDeath: wg,
    callDisconnectAndReconnect: yu
}
  , oS = m.getLoggerProxy(G.SHARING)
  , zl = function(e) {
    this.client = e,
    this.sessionAlive = !1,
    this.sessionPhase = -1,
    this.engineId = null,
    this.engineType = "local"
};
zl.methods = Wg;
zl.prototype = {
    setPushPageHandler: function(e) {
        this.target = e
    },
    setEngineId: function(e) {
        oS.logInfo(m.resolve(514), this.engineType, e),
        this.engineId = e
    },
    getEngineId: function() {
        return this.engineId
    },
    dispose: function() {
        this.client = null
    },
    setSessionPhase: function(e) {
        this.sessionPhase = e
    },
    isSessionAlive: function() {
        return this.sessionAlive
    },
    onEngineConfigurationChange: function(e, t, n) {
        var i = e == "ConnectionDetails" ? this.client._connection : e == "ConnectionOptions" ? this.client._policy : this.client._configuration;
        i.simpleSetter(t, n)
    },
    onSessionEnd: function(e) {
        this.sessionPhase = e,
        this.sessionAlive && this.sessionEnd(e)
    },
    sessionEnd: function(e) {
        this.sessionAlive = !1,
        this.client.sessionEnd()
    },
    onSessionStart: function(e) {
        this.sessionPhase = e,
        this.sessionAlive = !0,
        this.client.sessionStart()
    },
    onEngineDeath: function(e, t) {
        oS.logInfo(m.resolve(515), this.engineId + " is dead"),
        this.client && (this.sessionEnd(-1),
        this.client.engineMourningRoom(e, t))
    },
    checkDeath: function() {
        var e = this;
        this.pong().then(function() {}, function() {
            e.client && e.onEngineDeath()
        })
    },
    onEngineDying: function() {
        this.checkDeath(),
        Se.addTimedTask(this.checkDeath, 1e3, this)
    },
    onServerError: function(e, t) {
        this.client.serverError(e, t)
    },
    onStatusChange: function(e) {
        this.client.cacheEngineStatus(e)
    },
    onSubscription: function(e, t, n, i, r) {
        this.client.getTablesHandler().subscriptionEvent(e, t, n, i, r)
    },
    onSubscriptionError: function(e, t, n) {
        this.client.getTablesHandler().errorEvent(e, t, n)
    },
    onUnsubscription: function(e) {
        this.client.getTablesHandler().unsubscriptionEvent(e)
    },
    onEndOfSnapshot: function(e, t) {
        this.client.getTablesHandler().onEndOfSnapshotEvent(e, t)
    },
    onUpdate: function(e, t) {
        this.client.getTablesHandler().updatePage(e, t)
    },
    onLostUpdates: function(e, t, n) {
        this.client.getTablesHandler().onLostUpdatesEvent(e, t, n)
    },
    onClearSnapshot: function(e, t) {
        this.client.getTablesHandler().onClearSnapshotEvent(e, t)
    },
    onMessageDiscarded: function(e) {
        this.client.getMessageProxy().messageDiscarded(e)
    },
    onMessageDenied: function(e, t, n) {
        this.client.getMessageProxy().messageDenied(e, t, n)
    },
    onMessageError: function(e, t, n) {
        this.client.getMessageProxy().messageError(e, t, n)
    },
    onMessageComplete: function(e) {
        this.client.getMessageProxy().messageComplete(e)
    },
    onMessageOnNetwork: function(e) {
        this.client.getMessageProxy().messageOnNetwork(e)
    },
    ping: function() {
        if (this.client === null)
            throw "net";
        return !0
    },
    onServerKeepalive: function() {
        this.client.onServerKeepalive()
    },
    onSubscriptionReconf: function(e, t) {
        this.client.getTablesHandler().doSubscriptionReconf(e, t)
    }
};
for (s3 in Wg)
    zl.prototype[s3] = VS.createCaller(s3, Wg[s3]);
var s3, MN = "^https?://(?:[a-z][a-z0-9-]+.)*", kN = "(?:/|$|:)", ar = function(e, t, n, i, r, s) {
    this.setPath(e),
    this.setFile(t),
    this.setData(n),
    this.setMethod(i),
    this.setCookieFlag(r),
    this.setExtraHeaders(s)
};
ar._GET = "GET";
ar._POST = "POST";
ar.prototype = {
    toString: function() {
        return ["[", this._path, this._file, this._data, this._method, "]"].join("|")
    },
    setPath: function(e) {
        for (; e && e.substring(e.length - 1) == "/"; )
            e = e.substring(0, e.length - 1);
        this._path = e
    },
    setFile: function(e) {
        for (; e && e.substring(0, 1) == "/"; )
            e = e.substring(1);
        this._file = e
    },
    setMethod: function(e) {
        this._method = e || ar._POST
    },
    setCookieFlag: function(e) {
        this.cookieFlag = e || !1
    },
    setExtraHeaders: function(e) {
        this.extraHeaders = e || null
    },
    setData: function(e) {
        this._data = e
    },
    extendData: function(e) {
        this._data ? this.containsData(e) || (this._data += e) : this.setData(e)
    },
    containsData: function(e) {
        return this._data && this._data.indexOf(e) > -1
    },
    getPath: function() {
        return this._path
    },
    getFile: function() {
        return this._file
    },
    getUrl: function() {
        return this._file ? this._path + "/" + this._file : this._path
    },
    getCookieFlag: function() {
        return this.cookieFlag
    },
    getExtraHeaders: function(e) {
        return this.extraHeaders
    },
    getData: function() {
        return this._data
    },
    getUrlWithParams: function(e) {
        return this._data ? this.getUrl() + "?" + this._data : this.getUrl()
    },
    getMethod: function() {
        return this._method
    },
    clone: function() {
        return new ar(this._path,this._file,this._data,this._method,this.cookieFlag,this.extraHeaders)
    },
    isRelativeRequest: function() {
        return !(this._path.indexOf("http://") == 0 || this._path.indexOf("https://") == 0 || this._path.indexOf("file:///") == 0)
    },
    isSameDomain: function(e, t) {
        if (!vt.isBrowser())
            return !1;
        if (this.isRelativeRequest())
            return vt.isWebWorker() ? location.hostname == e : Ke.getDomain() == e;
        if (t) {
            if (!this.isSameProtocol(t))
                return !1;
            if (t == "file:")
                return e == ""
        }
        e = e.replace(".", ".");
        var n = new RegExp(MN + e + kN,"i");
        return n.test(this._path)
    },
    isSameProtocol: function(e) {
        return !vt.isBrowser() || e.indexOf(":") != e.length - 1 ? !1 : this.isRelativeRequest() ? location.protocol == e : this._path.indexOf(e) == 0
    },
    isCrossSite: function() {
        if (!vt.isBrowser())
            return !0;
        var e = vt.isWebWorker() ? location.hostname : Ke.getDomain();
        return !this.isSameDomain(e, location.protocol)
    },
    isCrossProtocol: function() {
        return vt.isBrowser() ? !this.isSameProtocol(location.protocol) : !0
    }
};
ar.aboutBlank = new ar("about:blank");
var AN = m.getLoggerProxy(G.REQUESTS);
function je(e, t, n, i, r) {
    this.request = e,
    this.related = t,
    this.relatedKey = i,
    this._type = n,
    this.retryingOrHost = r
}
je.ADD = 1;
je.REMOVE = 2;
je.CONSTRAINT = 3;
je.MESSAGE = 4;
je.LOG = 5;
je.DESTROY = 6;
je.FORCE_REBIND = 7;
je.HEARTBEAT = 8;
je.CHANGE_SUB = 9;
je.MPN = 10;
je.prototype = {
    toString: function() {
        var e = AN.isDebugLogEnabled() ? JSON.stringify(this.request) : this.request;
        return ["[", "ControlRequest", this.relatedKey, this._type, this.retryingOrHost, e, "]"].join("|")
    },
    getBridge: function() {
        return this.related
    },
    getKey: function() {
        return this.relatedKey
    },
    getType: function() {
        return this._type
    },
    getRequest: function() {
        return this.request
    }
};
var IN = "msg"
  , RN = "send_log"
  , DN = "control"
  , NN = "heartbeat"
  , FN = "LS_message"
  , LN = "LS_unq";
function BN(e) {
    return e == je.MESSAGE ? IN : e == je.LOG ? RN : e == je.HEARTBEAT ? NN : DN
}
var e7 = function() {};
e7.prototype = {
    toString: function() {
        return "[Encoder]"
    },
    initRequest: function(e, t, n) {
        var i = new ar
          , r = BN(e.getBatchType())
          , s = this.getExt();
        return i.setFile(r + s),
        i.setMethod(ar._POST),
        i.setCookieFlag(t),
        i.setExtraHeaders(n),
        i
    },
    encode: function(e, t, n) {
        for (var i = n ? "" : `\r
`; e.getLength() > 0; ) {
            var r = e.firstRequest()
              , s = r.getBridge()
              , o = r.getType();
            if (s && s.verifySuccess())
                s.notifyAborted(),
                e.shift();
            else {
                var a = r.getRequest();
                return o == je.MESSAGE ? i + this.encodeMessageRequest(a, s, t) : o == je.DESTROY ? i + this.encodeDestroyRequest(a, s, t) : o == je.HEARTBEAT ? i + this.encodeHeartbeatRequest(a, s, t) : o == je.LOG ? i + this.encodeLogRequest(a, s, t) : i + this.encodeControlRequest(a, s, t)
            }
        }
        return null
    },
    expand: function(e, t) {
        var n = "";
        if (e)
            for (var i in e)
                i !== t && (n += i + "=" + e[i] + "&");
        return n
    },
    encodeRequest: function(e, t, n) {
        var i = this.expand(e);
        return i += this.expand(t),
        i
    },
    encodeUnqRequest: function(e, t, n, i) {
        var r = this.expand(e, n);
        r += this.expand(t, n),
        e[n] ? r += n + "=" + e[n] : t && (r += n + "=" + t[n]);
        var s = r.length;
        return LN + "=" + s + "&" + r
    },
    wrapUp: function(e) {
        return e || `
`
    },
    getExt: function() {
        return ".txt?LS_protocol=" + G.TLCP_VERSION
    },
    getFixedOverhead: function(e) {
        return 0
    },
    getInvisibleOverhead: function(e) {
        return 2
    },
    encodeControlRequest: function(e, t, n, i) {
        return this.encodeRequest(e, i, n)
    },
    encodeDestroyRequest: function(e, t, n, i) {
        return this.encodeRequest(e, i, n)
    },
    encodeHeartbeatRequest: function(e, t, n, i) {
        return this.encodeRequest(e, i, n)
    },
    encodeLogRequest: function(e, t, n, i) {
        return this.encodeRequest(e, i, n)
    },
    encodeMessageRequest: function(e, t, n, i) {
        return this.encodeUnqRequest(e, i, FN, n)
    }
};
var aS = 1
  , Ul = {
    encodeMessageRequest: "encodeMessageRequest",
    encodeControlRequest: "encodeControlRequest",
    encodeDestroyRequest: "encodeDestroyRequest",
    encodeHeartbeatRequest: "encodeHeartbeatRequest",
    encodeLogRequest: "encodeLogRequest"
};
Ul = Ke.getReverse(Ul);
var Ma = function() {};
Ma.prototype = {
    encodeMessageRequest: function(e, t, n, i) {
        return i = Ke.extendObj(i, {
            LS_session: n
        }),
        this._callSuperMethod(Ma, Ul.encodeMessageRequest, [e, t, n, i])
    },
    encodeControlRequest: function(e, t, n, i) {
        return i = Ke.extendObj(i, {
            LS_session: n
        }),
        this._callSuperMethod(Ma, Ul.encodeControlRequest, [e, t, n, i])
    },
    encodeDestroyRequest: function(e, t, n, i) {
        return this._callSuperMethod(Ma, Ul.encodeDestroyRequest, [e, t, n, i])
    },
    encodeHeartbeatRequest: function(e, t, n, i) {
        return n && (i = Ke.extendObj(i, {
            LS_session: n
        })),
        i = Ke.extendObj(i, {
            LS_unique: aS++
        }),
        this._callSuperMethod(Ma, Ul.encodeHeartbeatRequest, [e, t, n, i])
    },
    encodeLogRequest: function(e, t, n, i) {
        return n && (i = Ke.extendObj(i, {
            LS_session: n
        })),
        i = Ke.extendObj(i, {
            LS_unique: aS++
        }),
        this._callSuperMethod(Ma, Ul.encodeLogRequest, [e, t, n, i])
    },
    expand: function(e, t) {
        var n = "";
        if (e)
            for (var i in e)
                i !== t ? n += i + "=" + e[i] + "&" : n += i + "=" + encodeURIComponent(e[i]) + "&";
        return n
    },
    encodeUnqRequest: function(e, t, n) {
        var i = this.expand(e, n);
        return i += this.expand(t, n),
        i
    }
};
ot(Ma, e7);
var M3 = {
    NodeWS: null,
    NodeXHR: null,
    getGlobalCookiesForNode: function() {},
    addGlobalCookiesForNode: function() {}
};
function UN() {
    return !1
}
function HN() {
    return !0
}
var GN = new Ma
  , En = function() {
    for (var e in {
        _load: !0
    })
        this._loadName = e;
    this.constr = En
};
En.attachPublicStaticMethods = function(e, t) {
    for (var n in t)
        t[n] === !0 ? e[n] = HN : t[n] === !1 ? e[n] = UN : e[n] = t[n]
}
;
En.attachPublicStaticMethods(En, {
    isAvailable: !1,
    isCrossSite: !1,
    isCrossProtocol: !1,
    areCookiesGuaranteed: !1,
    attachEngineId: !1,
    isStreamEnabled: !1,
    canUseCustomHeaders: !1
});
En.prototype = {
    _close: function() {},
    sessionLoad: function(e, t, n, i, r, s) {
        return this._load(e, t, n, i, r)
    },
    _load: function(e, t, n, i, r) {
        return !1
    },
    getEncoder: function() {
        return GN
    }
};
En.getGlobalCookiesForNode = M3.getGlobalCookiesForNode;
En.addGlobalCookiesForNode = M3.addGlobalCookiesForNode;
var Ld = m.getLoggerProxy("assertions")
  , jt = {
    assert: function(e, t) {
        e || this.fail(t)
    },
    assertNotNull: function(e, t) {
        e == null && this.fail(t)
    },
    assertNull: function(e, t) {
        e != null && this.fail(t)
    },
    assertEquals: function(e, t, n) {
        e !== t && this.fail(n + ": Expected " + e + " but found " + t)
    },
    implies: function(e, t, n) {
        this.assert(!e || t, n)
    },
    fail: function(e) {
        e != null && Ld.logError(e),
        ut.fail()
    },
    verifyOk: function(e, t) {
        ut.verifyOk(e) || t != null && Ld.logError(t)
    },
    verifyNotOk: function(e, t) {
        ut.verifyNotOk(e) || t != null && Ld.logError(t)
    },
    verifyValue: function(e, t, n) {
        ut.verifyValue(e, t, null) || n != null && Ld.logError(n)
    },
    verifyDiffValue: function(e, t, n) {
        ut.verifyDiffValue(e, t, null) || n != null && Ld.logError(n)
    }
}
  , $S = function(e) {
    this.lastMessageListener = -1,
    this.pendingMessageListeners = {},
    this.pendingMessages = {},
    this.pendingMessagesOnNetwork = {},
    this.pendingMLCount = 0,
    this.engineHandler = e,
    this.queuedMessages = new Zd
};
$S.prototype = {
    switchEngineHandler: function(e) {
        this.engineHandler = e
    },
    getMessageListenerProxy: function(e, t) {
        return this.lastMessageListener++,
        this.pendingMessageListeners[this.lastMessageListener] = t,
        this.pendingMessages[this.lastMessageListener] = e,
        this.pendingMessagesOnNetwork[this.lastMessageListener] = !1,
        this.pendingMLCount++,
        this.lastMessageListener
    },
    getListener: function(e) {
        return this.pendingMessageListeners[e]
    },
    getOriginalMessage: function(e) {
        return this.pendingMessages[e]
    },
    wasSentOnNetwork: function(e) {
        return this.pendingMessagesOnNetwork[e]
    },
    cleanMessageListeners: function() {
        this.clearQueuedMessages();
        var e = [];
        for (var t in this.pendingMessageListeners)
            e.push(t);
        e.sort(function(n, i) {
            return n - i
        });
        for (var t = 0; t < e.length; t++)
            this.messageAbort(e[t]);
        jt.verifyValue(this.pendingMLCount, 0, "Unexpected pending messages"),
        this.lastMessageListener = -1,
        this.pendingMessageListeners = {},
        this.pendingMessages = {},
        this.pendingMessagesOnNetwork = {},
        this.pendingMLCount = 0
    },
    clean: function(e) {
        delete this.pendingMessageListeners[e],
        delete this.pendingMessages[e],
        delete this.pendingMessagesOnNetwork[e],
        this.pendingMLCount--
    },
    messageOnNetwork: function(e) {
        var t = this.getListener(e);
        t && (this.pendingMessagesOnNetwork[e] = !0)
    },
    enqueueMessage: function(e, t, n, i) {
        this.queuedMessages.add({
            msg: e,
            sequence: t,
            listener: n,
            timeout: i
        })
    },
    clearQueuedMessages: function() {
        var e = this;
        this.queuedMessages.forEach(function(t) {
            e.fireEvent("onAbort", t.listener, [t.msg, !1])
        }),
        this.queuedMessages.clean()
    },
    handleAllWaitingMessages: function() {
        var e = this;
        this.queuedMessages.forEach(function(t) {
            e.forwardMessage(t.msg, t.sequence, t.listener, t.timeout)
        }),
        this.queuedMessages.clean()
    },
    forwardMessage: function(e, t, n, i) {
        var r = null;
        n && (r = this.getMessageListenerProxy(e, n)),
        this.engineHandler.forwardMessage(e, t, r, i)
    },
    fireEvent: function(e, t, n) {
        !t || !t[e] || Se.addTimedTask(t[e], 0, t, n)
    },
    messageComplete: function(e) {
        var t = this.getListener(e);
        this.fireEvent("onProcessed", t, [this.getOriginalMessage(e)]),
        this.clean(e)
    },
    messageError: function(e, t, n) {
        var i = this.getListener(e);
        t != 32 && t != 33 && this.fireEvent("onError", i, [this.getOriginalMessage(e)]),
        this.clean(e)
    },
    messageDenied: function(e, t, n) {
        var i = this.getListener(e);
        this.fireEvent("onDeny", i, [this.getOriginalMessage(e), t, n]),
        this.clean(e)
    },
    messageDiscarded: function(e) {
        var t = this.getListener(e);
        this.fireEvent("onDiscarded", t, [this.getOriginalMessage(e)]),
        this.clean(e)
    },
    messageAbort: function(e) {
        var t = this.getListener(e);
        this.fireEvent("onAbort", t, [this.getOriginalMessage(e), this.wasSentOnNetwork(e)]),
        this.clean(e)
    }
};
function VN(e, t) {
    var n = t ? e : [];
    n.changedFields = [],
    t || (n[0] = parseInt(e[0]),
    n[1] = parseInt(e[1]));
    for (var i = 2, r = e.length; i < r; i++)
        e[i] ? e[i].length == -1 ? n[i] = G.UNCHANGED : (t || (n[i] = e[i].toString()),
        n.changedFields.push(i - 1)) : (t || (e[i] === "" ? n[i] = "" : n[i] = null),
        n.changedFields.push(i - 1));
    return n
}
var gi = m.getLoggerProxy(G.SUBSCRIPTIONS)
  , jS = function(e) {
    this.nextId = 0,
    this.tableInfosFromId = {},
    this.tableIdsFromNum = {},
    this.generationNumber = 1,
    this.promisesFromId = {},
    this.promiseQueuesFromId = {},
    this.eh = null,
    this.policyBean = e,
    this.controlRequestTimeout = 4e3,
    this.phase = 0
};
jS.prototype = {
    toString: function() {
        return "[SubscriptionsHandler]"
    },
    setControlRequestTimeout: function(e) {
        this.controlRequestTimeout = e
    },
    switchEngineHandler: function(e) {
        this.eh = e
    },
    getAllTables: function() {
        return this.tableInfosFromId
    },
    addATable: function(e) {
        var t = ++this.nextId;
        gi.logInfo(m.resolve(516), e),
        e.onAdd(t, ++this.generationNumber, this),
        this.tableInfosFromId[t] = e,
        this.passTableToEngine(e)
    },
    removeATable: function(e) {
        if (this.eh && this.eh.isSessionAlive()) {
            var t = e.getTableNumber();
            (e.isSubscribing() || e.isPushing()) && t && (this.eh.unsubscribeTable(t),
            delete this.tableIdsFromNum[t])
        }
        gi.logInfo(m.resolve(517), e);
        var n = e.getSubscriptionId();
        return e.onRemove(),
        delete this.tableInfosFromId[n],
        e
    },
    updateSubscriptionParams: function(e, t) {
        if (!(!this.eh || !this.eh.isSessionAlive() || !e.isActive())) {
            jt.verifyOk(e.isActive(), "Inactive subscription");
            var n = e.getSubscriptionId();
            if (this.promisesFromId[n]) {
                gi.logDebug(m.resolve(518), e);
                var i = this;
                this.enqueueToPromise(n, function(s) {
                    gi.logDebug(m.resolve(519), e),
                    i.eh.updateSubscriptionParams(s, t)
                })
            } else {
                gi.logDebug(m.resolve(520), e);
                var r = e.getTableNumber();
                this.eh.updateSubscriptionParams(r, t)
            }
        }
    },
    passTableToEngine: function(e) {
        if (!(!this.eh || !this.eh.isSessionAlive()) && e.isPaused()) {
            var t = e.getSubscriptionId();
            gi.logDebug(m.resolve(521));
            var n = this.eh.subscribeTable(e.getRequestParams());
            this.promisesFromId[t] ? gi.logDebug(m.resolve(522), t) : (jt.verifyNotOk(this.promisesFromId[t], "Promise unexpected (1)"),
            jt.verifyNotOk(this.promiseQueuesFromId[t], "Promise unexpected (2)")),
            this.promisesFromId[t] = n,
            this.promiseQueuesFromId[t] = 0,
            e.onSubmission(),
            gi.logDebug(m.resolve(523), e);
            var i = this;
            this.enqueueToPromise(t, function(r) {
                gi.logDebug(m.resolve(524), e),
                i.tableInfosFromId[t] ? (e.onTableNumber(r),
                i.tableIdsFromNum[r] = t) : i.eh && i.eh.unsubscribeTable(r)
            })
        }
    },
    enqueueToPromise: function(e, t) {
        jt.verifyOk(this.promisesFromId[e], "Promise not found (1)"),
        this.promiseQueuesFromId[e] === 0 || jt.verifyOk(this.promiseQueuesFromId[e], "Promise not found (2)");
        var n = this.promisesFromId[e];
        this.promiseQueuesFromId[e]++;
        var i = this
          , r = this.phase;
        n.then(function(s) {
            if (i.promisesFromId[e] != n) {
                gi.logDebug(m.resolve(525), e);
                return
            }
            jt.verifyOk(i.promisesFromId[e], "Promise not found (3)"),
            jt.verifyOk(i.promiseQueuesFromId[e], "Promise not found (4)"),
            i.promiseQueuesFromId[e] > 1 ? i.promiseQueuesFromId[e]-- : (delete i.promisesFromId[e],
            delete i.promiseQueuesFromId[e]),
            s != null && r == i.phase && t(s)
        }, function() {
            if (i.promisesFromId[e] != n) {
                gi.logDebug(m.resolve(526), e);
                return
            }
            delete i.promisesFromId[e],
            delete i.promiseQueuesFromId[e]
        })
    },
    handleAllWaitingTables: function() {
        gi.logDebug(m.resolve(527));
        for (var e in this.tableInfosFromId)
            this.passTableToEngine(this.tableInfosFromId[e])
    },
    pauseTable: function(e) {
        jt.verifyNotOk(e.isOff(), "Table removed"),
        gi.logDebug(m.resolve(528), e),
        delete this.tableIdsFromNum[e.getTableNumber()],
        e.onPause(),
        e.isSubTable() && delete this.tableInfosFromId[e.getSubscriptionId()]
    },
    pauseAllTables: function() {
        gi.logDebug(m.resolve(529));
        for (var e in this.tableInfosFromId)
            this.pauseTable(this.tableInfosFromId[e]);
        this.tableIdsFromNum = {},
        this.phase++
    },
    callTableByNum: function(e, t) {
        var n = this.tableIdsFromNum[e];
        if (n) {
            var i = this.tableInfosFromId[n];
            if (this.promisesFromId[n]) {
                gi.logDebug(m.resolve(530), i);
                var r = this;
                this.enqueueToPromise(n, function(c) {
                    if (gi.logDebug(m.resolve(531), l),
                    jt.verifyValue(c, e, "Wrong table number"),
                    r.tableIdsFromNum[e] == n) {
                        var l = r.tableInfosFromId[n];
                        l && t.apply(l)
                    }
                })
            } else
                i && t.apply(i)
        } else {
            gi.logDebug(m.resolve(533), e);
            var r = this
              , s = 0;
            for (var o in this.promisesFromId) {
                var a = this.tableInfosFromId[o];
                a && (a.getTableNumber() ? jt.verifyDiffValue(a.getTableNumber(), e, "Unexpected table number") : (function(l) {
                    r.enqueueToPromise(l, function(u) {
                        if (u == e && (gi.logDebug(m.resolve(534), e),
                        r.tableIdsFromNum[e] == l)) {
                            var h = r.tableInfosFromId[l];
                            h && t.apply(h)
                        }
                    })
                }(o),
                s++))
            }
            gi.logDebug(m.resolve(535), s)
        }
    },
    updatePage: function(e, t) {
        var n = e[0];
        this.callTableByNum(n, function() {
            this.update(VN(e, !0), t, !1)
        })
    },
    onLostUpdatesEvent: function(e, t, n) {
        this.callTableByNum(e, function() {
            this.lostUpdates(t, n)
        })
    },
    onEndOfSnapshotEvent: function(e, t) {
        this.callTableByNum(e, function() {
            this.endOfSnapshot(t)
        })
    },
    onClearSnapshotEvent: function(e, t) {
        this.callTableByNum(e, function() {
            this.clearSnapshot(t)
        })
    },
    errorEvent: function(e, t, n) {
        this.callTableByNum(e, function() {
            this.serverDeny(t, n)
        })
    },
    subscriptionEvent: function(e, t, n, i, r) {
        this.callTableByNum(e, function() {
            this.onStartPush(t, n, i, r)
        })
    },
    unsubscriptionEvent: function(e) {
        this.callTableByNum(e, function() {
            this.onStopPush()
        })
    },
    doSubscriptionReconf: function(e, t) {
        this.callTableByNum(e, function() {
            this.configure(t)
        })
    }
};
var Ru = function() {
    var e = function() {
        this.initDispatcher()
    };
    e.prototype = {
        initDispatcher: function() {
            this.theListeners = new t,
            this.synchEvents = !1
        },
        addListener: function(n) {
            if (n && !this.theListeners.contains(n)) {
                var i = {
                    handler: n,
                    listening: !0
                };
                this.theListeners.add(i),
                this.dispatchToOneListener("onListenStart", [this], i, !0)
            }
        },
        removeListener: function(n) {
            if (n) {
                var i = this.theListeners.remove(n);
                i && this.dispatchToOneListener("onListenEnd", [this], i, !0)
            }
        },
        getListeners: function() {
            return this.theListeners.asArray()
        },
        useSynchEvents: function(n) {
            this.synchEvents = n === !0
        },
        dispatchToOneListener: function(n, i, r, s) {
            this.synchEvents ? this.dispatchToOneListenerExecution(n, i, r, !0) : Se.addTimedTask(this.dispatchToOneListenerExecution, 0, this, [n, i, r, s])
        },
        dispatchToOneListenerExecution: function(n, i, r, s) {
            if (r && r.handler[n] && (s || r.listening))
                try {
                    i ? r.handler[n].apply(r.handler, i) : r.handler[n].apply(r.handler)
                } catch {}
        },
        dispatchEvent: function(n, i) {
            var r = this;
            this.theListeners.forEach(function(s) {
                r.dispatchToOneListener(n, i, s, !1)
            })
        }
    },
    e.prototype.initDispatcher = e.prototype.initDispatcher,
    e.prototype.addListener = e.prototype.addListener,
    e.prototype.removeListener = e.prototype.removeListener,
    e.prototype.getListeners = e.prototype.getListeners,
    e.prototype.useSynchEvents = e.prototype.useSynchEvents,
    e.prototype.dispatchEvent = e.prototype.dispatchEvent;
    var t = function() {
        this._callSuperConstructor(t)
    };
    return t.prototype = {
        remove: function(n) {
            var i = this.find(n);
            if (i < 0)
                return !1;
            var r = this.data[i];
            return r.listening = !1,
            this.data.splice(i, 1),
            r
        },
        find: function(n) {
            for (var i = 0; i < this.data.length; i++)
                if (this.data[i].handler == n)
                    return i;
            return -1
        },
        asArray: function() {
            var n = [];
            return this.forEach(function(i) {
                n.push(i.handler)
            }),
            n
        }
    },
    ot(t, Zd),
    e
}()
  , Is = m.getLoggerProxy(G.PROTOCOL)
  , qS = !1
  , k3 = function(e, t) {
    this.tablePhaseChecker = t,
    this.exportMethods(e)
};
k3.simulateSilence = function(e) {
    qS = e
}
;
k3.prototype = {
    changeSession: function(e) {
        Is.logDebug(m.resolve(538), e),
        this.sessionHandler = e,
        this.sessionHandler.getSessionId() != this.currentIdForProg && (this.currentProg = null)
    },
    exportMethods: function(e) {
        var t = this;
        Ut.exportGlobal(e, "LS_e", function(n, i, r, s, o, a) {
            t.onPushEvent(n, i, r, s, o, a)
        }),
        Ut.exportGlobal(e, "LS_t", function(n) {
            t.onServerTitle(n)
        }),
        Ut.exportGlobal(e, "LS_u", function(n, i, r) {
            t.onUpdate(n, i, r)
        }),
        Ut.exportGlobal(e, "LS_v", function(n, i) {
            t.onUpdate(n, i, !0)
        }),
        Ut.exportGlobal(e, "LS_o", function(n, i) {
            t.onLostUpdatesEvent(n, i)
        }),
        Ut.exportGlobal(e, "LS_n", function(n, i) {
            t.onEndOfSnapshotEvent(n, i)
        }),
        Ut.exportGlobal(e, "LS_s", function(n, i) {
            if (i.length)
                t.onClearSnapshotEvent(n, i);
            else {
                var r = n
                  , s = i;
                t.onPushEvent(6, r, s)
            }
        }),
        Ut.exportGlobal(e, "LS_l", function(n, i, r, s, o) {
            t.onErrorEvent(n, i, r, s, o)
        }),
        Ut.exportGlobal(e, "LS_w", function(n, i, r, s, o, a, c) {
            t.onControlEvent(n, i, r, s, o, a, c)
        }),
        Ut.exportGlobal(e, "setTimeout", function(n, i) {
            setTimeout(n, i)
        }),
        Ut.exportGlobal(e, "alert", function(n) {
            typeof alert < "u" ? alert(n) : typeof console < "u" && console.log(n)
        }),
        Ut.exportGlobal(e, "LS_svrname", function(n) {
            t.onServerName(n)
        }),
        Ut.exportGlobal(e, "LS_MPNREG", function(n, i) {
            t.onMPNREG(n, i)
        }),
        Ut.exportGlobal(e, "LS_MPNOK", function(n, i) {
            t.onMPNOK(n, i)
        }),
        Ut.exportGlobal(e, "LS_MPNDEL", function(n) {
            t.onMPNDEL(n)
        })
    },
    preliminaryCheck: function(e, t, n, i) {
        var r = !qS && !Bt.isUnloaded() && this.sessionHandler != null;
        return Is.isDebugLogEnabled() && Is.logDebug(m.resolve(539), r),
        r
    },
    processCountableNotification: function() {
        this.sessionHandler.getSessionId() != this.currentIdForProg && (this.currentProg = null);
        var e = this.sessionHandler.getDataNotificationProg();
        return Is.logDebug(m.resolve(540), e),
        this.currentProg != null ? (ut.verifyOk(this.currentProg <= e) || Is.logError(m.resolve(541), this.currentProg),
        this.currentProg++,
        this.currentProg <= e ? (Is.logDebug(m.resolve(542), this.currentProg),
        !1) : (this.sessionHandler.onDataNotification(),
        e = this.sessionHandler.getDataNotificationProg(),
        ut.verifyValue(this.currentProg, e) || Is.logError(m.resolve(543), this.currentProg),
        !0)) : (this.sessionHandler.onDataNotification(),
        !0)
    },
    onServerTitle: function(e) {},
    onPushEvent: function(e, t, n, i, r, s) {
        if (this.preliminaryCheck(t, null, e == 1, e == 3 || e == 4))
            if (e == 1)
                this.sessionHandler.onOKReceived(n, i, s, r);
            else if (e == 2)
                this.sessionHandler.onLoopReceived(n);
            else if (e == 3)
                this.sessionHandler.onSyncError("syncerror");
            else if (e == 4) {
                var o = 30;
                if (n != null) {
                    if (o = n,
                    o == 41) {
                        this.sessionHandler.onError41();
                        return
                    } else if (o == 48) {
                        this.sessionHandler.onSyncError("expired");
                        return
                    }
                    (o > 0 && o < 30 || o > 39) && (o = 39)
                }
                var a = "The session has been forcibly closed by the Server";
                i != null && (a = i),
                this.onErrorEvent(o, t, null, a)
            } else
                e == 5 ? this.sessionHandler.onServerSentBandwidth(n) : e == 6 ? this.sessionHandler.onSyncReceived(n) : e == 7 ? this.onProg(n) : this.sessionHandler.onEnd("Unsupported Server version")
    },
    onProg: function(e) {
        this.sessionHandler.getSessionId() != this.currentIdForProg && (this.currentProg = null);
        var t = this.sessionHandler.getDataNotificationProg();
        this.currentProg == null ? (this.currentProg = e,
        this.currentIdForProg = this.sessionHandler.getSessionId(),
        this.currentProg > t && (ut.fail(),
        Is.logError(m.resolve(544), e, t),
        this.sessionHandler.onPROGCounterMismatch())) : this.currentProg != e ? (ut.fail(),
        Is.logError(m.resolve(545), e, this.currentProg),
        this.sessionHandler.onPROGCounterMismatch()) : e != t && (ut.fail(),
        Is.logError(m.resolve(546), e, t),
        this.sessionHandler.onPROGCounterMismatch())
    },
    onUpdate: function(e, t, n) {
        if (t.length < 2) {
            if (!this.preliminaryCheck(e))
                return;
            this.sessionHandler.onKeepalive()
        } else {
            if (!this.preliminaryCheck(null, e) || !this.processCountableNotification())
                return;
            this.sessionHandler.onUpdateReceived(t, n || !1)
        }
    },
    onSnapshot: function(e, t) {
        this.onUpdate(e, t, !0)
    },
    onEndOfSnapshotEvent: function(e, t) {
        this.preliminaryCheck(null, e) && this.processCountableNotification() && this.sessionHandler.onEndOfSnapshotEvent(t)
    },
    onClearSnapshotEvent: function(e, t) {
        this.preliminaryCheck(null, e) && this.processCountableNotification() && this.sessionHandler.onClearSnapshotEvent(t)
    },
    onLostUpdatesEvent: function(e, t) {
        this.preliminaryCheck(null, e) && this.processCountableNotification() && this.sessionHandler.onLostUpdatesEvent(t)
    },
    onMessageErrorEvent: function(e, t, n, i, r) {
        if (this.preliminaryCheck()) {
            ut.verifyValue(n.substring(0, 3), "MSG") || Is.logError(m.resolve(547), n);
            var s = n.substr(3);
            if (r) {
                this.sessionHandler.onMessageError(s, e, i, t);
                return
            }
            if (this.processCountableNotification())
                if (e == 39) {
                    var o = parseInt(i);
                    t = parseInt(t);
                    for (var a = t - o + 1; a <= t; a++)
                        this.sessionHandler.onMessageDiscarded(s, a)
                } else
                    e == 38 ? this.sessionHandler.onMessageDiscarded(s, t) : e <= 0 ? this.sessionHandler.onMessageDeny(s, e, i, t) : this.sessionHandler.onMessageError(s, e, i, t)
        }
    },
    onErrorEvent: function(e, t, n, i, r) {
        if (n != null && isNaN(n)) {
            this.onMessageErrorEvent(e, t, n, i, r);
            return
        }
        if (n != null) {
            if (!this.preliminaryCheck(null, t))
                return;
            this.sessionHandler.onTableError(n, e, i)
        } else {
            if (!this.preliminaryCheck(t, null, null, !0))
                return;
            this.sessionHandler.forwardError(e, i)
        }
    },
    onControlEvent: function(e, t, n, i, r, s, o) {
        if (this.preliminaryCheck(null, e == 4 || e == 5 || e == 9 ? null : t))
            if (e == 4)
                this.sessionHandler.onMessageAck(n, t);
            else if (e == 5) {
                if (!this.processCountableNotification())
                    return;
                this.sessionHandler.onMessageOk(n, t)
            } else if (e == 8) {
                if (!this.processCountableNotification())
                    return;
                this.sessionHandler.onUnsubscription(n)
            } else if (e == 6) {
                if (!this.processCountableNotification())
                    return;
                this.sessionHandler.onSubscription(n, i, r, s + 1, o + 1)
            } else if (e == 9) {
                if (!this.processCountableNotification())
                    return;
                this.sessionHandler.onSubscriptionReconf(n, t, i)
            } else
                Is.logDebug(m.resolve(548), e)
    },
    onServerName: function(e) {
        this.sessionHandler.onServerName(e)
    },
    onMPNREG: function(e, t) {
        this.processCountableNotification() && this.sessionHandler.onMpnRegisterOK(e, t)
    },
    onMPNOK: function(e, t) {
        this.processCountableNotification() && this.sessionHandler.onMpnSubscribeOK(e, t)
    },
    onMPNDEL: function(e) {
        this.processCountableNotification() && this.sessionHandler.onMpnUnsubscribeOK(e)
    }
};
var WN = 4e3
  , Xl = function(e, t) {
    this.discarded = !1,
    this.connOptions = e,
    this.timeoutMs = this.getFixedTimeout ? this.getFixedTimeout() : t ? t * 2 : WN
};
Xl.prototype = {
    notifySender: function(e) {
        if (e)
            this.doRecovery();
        else {
            var t = this.timeoutMs + Number(this.connOptions.pollingInterval);
            Se.addTimedTask(this.onTimeout, t, this)
        }
    },
    onTimeout: function() {
        this.discarded || this.verifySuccess() || this.doRecovery()
    },
    discard: function() {
        this.discarded = !0
    }
};
var A3 = function(e, t, n, i, r) {
    this._callSuperConstructor(A3, [e, r]),
    this.tableNum = t,
    this.owner = n,
    this.effort = i
};
A3.prototype = {
    verifySuccess: function() {
        return !this.owner.isWaitingUnsubscription(this.tableNum)
    },
    doRecovery: function() {
        this.owner.unsubscribeTable(this.tableNum, this.effort + 1, this.timeoutMs)
    },
    notifyAborted: function() {
        this.owner.onUnsubscription(this.tableNum)
    }
};
ot(A3, Xl);
var zS;
for (cS in {
    notifySender: !0
})
    zS = cS;
var cS, t1 = function(e, t, n, i, r) {
    this._callSuperConstructor(t1, [e, r]),
    this.tableNum = t,
    this.owner = n,
    this.effort = i
};
t1.prototype = {
    verifySuccess: function() {
        return !this.owner.isWaitingSubscription(this.tableNum)
    },
    doRecovery: function() {
        this.owner.subscribeTable(this.tableNum, this.effort + 1, this.timeoutMs)
    },
    notifySender: function(e) {
        e || this.owner.subscriptionSent(this.tableNum),
        this._callSuperMethod(t1, zS, arguments)
    },
    notifyAborted: function() {}
};
ot(t1, Xl);
var I3 = function(e, t, n, i, r, s, o) {
    this._callSuperConstructor(I3, [e, o]),
    this.tableNum = t,
    this.ph = n,
    this.owner = i,
    this.changingParams = r,
    this.effort = s
};
I3.prototype = {
    verifySuccess: function() {
        return !this.owner.isWaitingSubscriptionReconfNotification(this.tableNum, this.ph)
    },
    doRecovery: function() {
        this.owner.sendUpdateSubscriptionParams(this.tableNum, this.ph, this.changingParams, this.effort + 1, this.timeoutMs)
    },
    notifyAborted: function() {}
};
ot(I3, Xl);
var Rl = m.getLoggerProxy(G.SHARING)
  , qo = function(e, t, n, i) {
    this.reqPhase = 1,
    this.engine = e,
    this.configuration = t,
    this.details = n,
    this.options = i,
    this.sessionPhase = 0,
    this.sessionAlive = !1,
    this.pushPages = {},
    this.clientsCount = 0,
    this.subscriptions = {},
    this.page2Tables = {},
    this.cleanTask = Se.addRepetitiveTask(this.cleanThread, 5e3, this),
    Bt.addBeforeUnloadHandler(this),
    Bt.addUnloadHandler(this)
};
qo.prototype = {
    toString: function() {
        return ["[", "PushPageCollectionHandler", "]"].join("|")
    },
    getSessionPhase: function() {
        return this.sessionPhase
    },
    checkSessionPhase: function(e) {
        return e == this.sessionPhase
    },
    checkConnectionPool: function(e) {
        var t = this.engine.getSharedStatus();
        t && t.getNumberOfConnectionsToServer(this.engine.sessionHandler.getPushServerAddress()) > e && Rl.logWarn(m.resolve(549))
    },
    cleanAll: function() {
        this.subscriptions = {};
        for (var e in this.page2Tables)
            this.page2Tables[e] = {}
    },
    forEachPushPage: function(e) {
        for (var t in this.pushPages)
            e(this.pushPages[t], t)
    },
    onNewPushPage: function(e, t) {
        this.pushPages[e] = t,
        this.page2Tables[e] = {},
        this.clientsCount++,
        this.configuration.simpleSetter("clientsCount", this.clientsCount),
        Rl.logDebug(m.resolve(550), this),
        e !== G.MAIN_CLIENT && (this.details.forEachProperty(function(n, i) {
            t.onEngineConfigurationChange("ConnectionDetails", n, i)
        }),
        this.options.forEachProperty(function(n, i) {
            t.onEngineConfigurationChange("ConnectionOptions", n, i)
        }),
        this.configuration.forEachProperty(function(n, i) {
            t.onEngineConfigurationChange("Configuration", n, i)
        }),
        t.onStatusChange(this.engine.getStatus()),
        this.sessionAlive ? t.onSessionStart(this.sessionPhase) : t.onSessionEnd(this.sessionPhase))
    },
    onPushPageLost: function(e) {
        if (Rl.logDebug(m.resolve(551), this, e),
        this.pushPages[e]) {
            var t = this.page2Tables[e];
            for (var n in t)
                this.removeTable(n);
            this.pushPages[e].dispose(),
            delete this.pushPages[e],
            delete this.page2Tables[e],
            this.clientsCount--,
            this.configuration.simpleSetter("clientsCount", this.clientsCount)
        }
    },
    getPushPageHandlerFromTableNumber: function(e) {
        var t = this.subscriptions[e];
        return t ? this.getPushPageHandler(t.pageNum) : (Rl.logDebug(m.resolve(552)),
        null)
    },
    getPushPageHandler: function(e) {
        return this.pushPages[e] ? this.pushPages[e] : (Rl.logDebug(m.resolve(553)),
        null)
    },
    notifyNewStatus: function(e, t) {
        return this.forEachPushPage(function(n) {
            n.onStatusChange(e)
        }),
        !0
    },
    onSessionStart: function() {
        this.cleanAll(),
        this.sessionAlive = !0;
        var e = ++this.sessionPhase;
        this.forEachPushPage(function(t) {
            t.onSessionStart(e)
        })
    },
    onSessionEnd: function() {
        this.cleanAll(),
        this.sessionAlive = !1;
        var e = ++this.sessionPhase;
        this.forEachPushPage(function(t) {
            t.onSessionEnd(e)
        })
    },
    onSubscription: function(e) {
        this.subscriptions[e] && (this.subscriptions[e].pendingSubscription = !1)
    },
    onSubscriptionError: function(e) {
        this.onUnsubscription(e)
    },
    isWaitingSubscription: function(e) {
        return this.subscriptions[e] ? this.subscriptions[e].pendingSubscription && !this.subscriptions[e].pendingUnsubscription : !1
    },
    subscriptionSent: function(e) {
        this.subscriptions[e] && (this.subscriptions[e].sentSubscription = !0)
    },
    onSubscriptionEvent: function(e) {},
    onUnsubscription: function(e) {
        if (this.subscriptions[e]) {
            var t = this.subscriptions[e].pageNum;
            delete this.subscriptions[e],
            this.page2Tables[t] && delete this.page2Tables[t][e]
        }
    },
    isWaitingUnsubscription: function(e) {
        return this.subscriptions[e] ? this.subscriptions[e].sentSubscription && this.subscriptions[e].pendingUnsubscription : !1
    },
    isWaitingSubscriptionReconfNotification: function(e, t) {
        return this.subscriptions[e] ? this.subscriptions[e].pendingChange && this.subscriptions[e].pendingChangePhase == t : !1
    },
    onSubscriptionReconfEvent: function(e, t) {
        this.subscriptions[e] && t == this.subscriptions[e].pendingChangePhase && (this.subscriptions[e].pendingChange = !1)
    },
    handleTable: function(e, t) {
        var n = this.pushPages[e];
        if (!n || !this.engine.isSessionOpenOrRecovering()) {
            ut.fail(),
            Rl.logError(m.resolve(554), this, e);
            return
        }
        var i = Ke.nextSubscriptionId();
        this.page2Tables[e][i] = !0;
        var r = this.getControlParams(t, i);
        return this.subscriptions[i] = new $N(e,r.add,r.remove),
        Rl.logDebug(m.resolve(555)),
        this.subscribeTable(i, 1),
        i
    },
    subscribeTable: function(e, t, n) {
        if (this.subscriptions[e]) {
            t >= 3 && this.checkConnectionPool(1),
            this.subscriptions[e].pendingSubscription = !0;
            var i = new t1(this.options,e,this,t,n)
              , r = this.subscriptions[e].addBody;
            this.engine.sessionHandler.sendSubscription(e, r, this, t >= 2, i)
        }
    },
    removeTable: function(e) {
        !this.subscriptions[e] || this.subscriptions[e].pendingUnsubscription || this.unsubscribeTable(e, 1)
    },
    unsubscribeTable: function(e, t, n) {
        if (this.subscriptions[e]) {
            t >= 3 && this.checkConnectionPool(1),
            this.subscriptions[e].pendingUnsubscription = !0;
            var i = new A3(this.options,e,this,t,n)
              , r = this.subscriptions[e].deleteBody;
            r.LS_reqId = Ke.nextRequestId(),
            this.engine.sessionHandler.sendUnsubscription(e, r, this, t >= 2, i)
        }
    },
    updateSubscriptionParams: function(e, t) {
        if (this.subscriptions[e]) {
            var n = ++this.subscriptions[e].pendingChangePhase;
            this.sendUpdateSubscriptionParams(e, n, t, 1)
        }
    },
    sendUpdateSubscriptionParams: function(e, t, n, i, r) {
        if (!(!this.subscriptions[e] || this.subscriptions[e].pendingChangePhase != t)) {
            i >= 3 && this.checkConnectionPool(1),
            this.subscriptions[e].pendingChange = !0;
            var s = this.subscriptions[e].pendingChangePhase
              , o = Ke.extendObj({
                LS_subId: e,
                LS_op: "reconf",
                LS_reqId: Ke.nextRequestId()
            }, n)
              , a = new I3(this.options,e,s,this,n,i,r);
            this.engine.sessionHandler.sendSubscriptionChange(e, o, a)
        }
    },
    notifyEngineIsDying: function() {
        this.forEachPushPage(function(e) {
            e.onEngineDying()
        })
    },
    notifyEngineDeath: function(e) {
        var t = this.pushPages;
        this.pushPages = {};
        for (var n in t)
            t[n].onEngineDeath(e)
    },
    notifyServerError: function(e, t) {
        this.forEachPushPage(function(n) {
            n.onServerError(e, t)
        })
    },
    dispose: function() {
        Se.stopRepetitiveTask(this.cleanTask),
        Bt.removeBeforeUnloadHandler(this),
        Bt.removeUnloadHandler(this)
    },
    unloadEvent: function() {
        this.notifyEngineDeath(!1)
    },
    preUnloadEvent: function() {
        this.notifyEngineIsDying()
    },
    cleanThread: function() {
        var e = this;
        this.forEachPushPage(function(t, n) {
            t.ping().then(function(i) {}, function() {
                e.onPushPageLost(n)
            })
        })
    },
    getControlParams: function(e, t) {
        this.reqPhase++;
        var n = {
            LS_subId: t
        };
        return Ke.extendObj(e, n),
        {
            add: Ke.extendObj(e, {
                LS_op: "add",
                LS_reqId: Ke.nextRequestId()
            }),
            remove: Ke.extendObj(n, {
                LS_op: "delete",
                LS_reqId: Ke.nextRequestId()
            })
        }
    },
    onServerKeepalive: function() {
        this.forEachPushPage(function(e) {
            e.onServerKeepalive()
        })
    }
};
function $N(e, t, n) {
    this.pendingSubscription = !1,
    this.sentSubscription = !1,
    this.pendingChange = !1,
    this.pendingChangePhase = 0,
    this.pendingUnsubscription = !1,
    this.deleteBody = n,
    this.addBody = t,
    this.pageNum = e
}
qo.prototype.onPushPageLost = qo.prototype.onPushPageLost;
qo.prototype.onNewPushPage = qo.prototype.onNewPushPage;
qo.prototype.unloadEvent = qo.prototype.unloadEvent;
qo.prototype.preUnloadEvent = qo.prototype.preUnloadEvent;
var XS = vi.isProbablyFX(1.5, !0) ? 10 : 50
  , o3 = XS
  , bu = 0
  , Oc = 0
  , Dl = 0
  , Cg = null
  , a3 = null
  , Eg = null
  , jN = m.getLoggerProxy(G.SESSION)
  , Rs = {
    init: function() {
        o3 = XS,
        bu = 0,
        Oc = 0,
        Dl = 0,
        Cg = null,
        a3 = null,
        Eg = null
    },
    incMadTest: function() {
        Cg = bu,
        a3 = Oc,
        Eg = Dl;
        var e = Et.getTimeStamp();
        Dl || (Dl = e),
        e - Dl >= 6e4 && (bu = 0,
        Dl = e),
        Oc && e - Oc < 1e3 && bu++,
        Oc = e
    },
    rollbackLastMadTest: function() {
        a3 != Oc && (bu = Cg,
        Oc = a3,
        Dl = Eg)
    },
    canMakeRequest: function() {
        if (Oc == 0)
            return !0;
        if (o3) {
            if (bu >= o3)
                return jN.logError(m.resolve(556)),
                o3 = 0,
                !1
        } else
            return !1;
        return !0
    }
}
  , e1 = {
    encodeRequest: "encodeRequest",
    encodeUnqRequest: "encodeUnqRequest"
};
e1 = Ke.getReverse(e1);
var Cu = function(e) {
    this.wsConnection = e
};
Cu.prototype = {
    toString: function() {
        return "[WSEncoder]"
    },
    getFixedOverhead: function(e) {
        return e.length + 2
    },
    getExt: function() {
        return ""
    },
    encodeRequest: function(e, t, n) {
        return t = this.expandWithSessionId(t, n),
        this._callSuperMethod(Cu, e1.encodeRequest, [e, t, n])
    },
    encodeUnqRequest: function(e, t, n, i) {
        return t = this.expandWithSessionId(t, i),
        this._callSuperMethod(Cu, e1.encodeUnqRequest, [e, t, n, i])
    },
    encodeDestroyRequest: function(e, t, n, i) {
        return this._callSuperMethod(Cu, e1.encodeRequest, [e, i, n])
    },
    expandWithSessionId: function(e, t) {
        var n = this.wsConnection.getDefaultSessionId();
        return n == null ? e = Ke.extendObj(e, {
            LS_session: t
        }) : jt.verifyValue(n, t, "Unexpected session ID"),
        e
    }
};
ot(Cu, e7);
var Tg = m.getLoggerProxy(G.SESSION)
  , $n = m.getLoggerProxy(G.STREAM)
  , C3 = null;
vt.isNodeJS() && (C3 = M3.NodeWS);
var Og = G.TLCP_VERSION + ".lightstreamer.com"
  , qN = 1;
function qn(e) {
    this._callSuperConstructor(qn),
    this.objectId = qN++,
    $n.isDebugLogEnabled() && $n.logDebug(m.resolve(557), this.objectId),
    this.isOpen = !1,
    this.exePhase = null,
    this.openPhase = null,
    this.openRequest = null,
    this.webSocketInstance = null,
    this.openEvent = !1,
    this.openFailure = !1,
    this.serverInUse = null,
    this.openEventFired = !1,
    this.defaultSessionId = null,
    this.wsSession = e,
    this.constr = qn,
    this.wsEncoder = new Cu(this)
}
qn.name == null && (qn.name = "WebSocketConnection");
var Pu = !1
  , n1 = {};
qn.disableClass = function(e) {
    e ? n1[e] = !0 : Pu = !0
}
;
qn.restoreClass = function(e) {
    e ? delete n1[e] : (Pu = !1,
    n1 = {})
}
;
qn.isDisabledClass = function() {
    for (var e in n1)
        return !0;
    return Pu
}
;
function zN(e) {
    if (e.indexOf("http://") == 0 ? e = e.replace("http://", "ws://") : e = e.replace("https://", "wss://"),
    C3) {
        var t = ""
          , n = En.getGlobalCookiesForNode(e);
        n.forEach(function(r, s, o) {
            t !== "" && (t += "; "),
            t += r.name + "=" + r.value
        });
        var i = {};
        return t.length > 0 && (i.headers = {
            Cookie: t
        }),
        new C3(e,Og,i)
    } else {
        if (typeof WebSocket < "u")
            return new WebSocket(e,Og);
        if (typeof MozWebSocket < "u")
            return new MozWebSocket(e,Og)
    }
    return qn.disableClass(),
    null
}
En.attachPublicStaticMethods(qn, {
    isAvailable: function(e) {
        if (Pu)
            return !1;
        if (e && n1[e])
            return !1;
        var t = null;
        return typeof WebSocket < "u" ? t = WebSocket : typeof MozWebSocket < "u" && (t = MozWebSocket),
        t && t.prototype.CLOSED == 2 ? !1 : C3 || t
    },
    isCrossSite: !0,
    isCrossProtocol: function() {
        return !vt.isBrowser() || location.protocol != "https:"
    },
    areCookiesGuaranteed: function() {
        return !0
    },
    attachEngineId: !1,
    isStreamEnabled: !0,
    canUseCustomHeaders: !1
});
qn.prototype = {
    toString: function() {
        return ["[", "WebSocketConnection", this.isOpen, this.openPhase, this.exePhase, this.isReadyToSend(), "]"].join("|")
    },
    _close: function() {
        if (this.webSocketInstance) {
            if ($n.logDebug(m.resolve(558)),
            this.openPhase = null,
            this.webSocketInstance)
                try {
                    this.webSocketInstance.close(1e3)
                } catch (e) {
                    $n.logDebug(m.resolve(559), e)
                }
            this.off()
        }
    },
    openSocket: function(e, t, n, i, r) {
        if (this.isOpen)
            $n.logError(m.resolve(560));
        else if (Pu)
            return !1;
        this.openFailure = !1,
        this.serverInUse = e.getPath(),
        this.openPhase = t;
        try {
            this.webSocketInstance = zN(this.serverInUse)
        } catch (o) {
            return $n.logDebug(m.resolve(561), o),
            !1
        }
        Tg.isDebugLogEnabled() && Tg.debug("Status timeout in " + this.wsSession.getCurrentConnectTimeout() + " [currentConnectTimeoutWS]"),
        Se.addTimedTask(this.openWSTimeout, this.wsSession.getCurrentConnectTimeout(), this, [this.openPhase]);
        var s = this;
        return this.webSocketInstance.onmessage = function(o) {
            s.onPartialResponse(o, t, n)
        }
        ,
        this.webSocketInstance.onerror = function() {
            s.onErrorResponse(t, i)
        }
        ,
        this.webSocketInstance.onclose = function(o) {
            s.onCloseResponse(o, t, r, i)
        }
        ,
        this.webSocketInstance.onopen = function() {
            if (vt.isNodeJS()) {
                var o = s.webSocketInstance.headers;
                if (o["set-cookie"]) {
                    var a = Ke.parseSetCookieHeader(o["set-cookie"]);
                    En.addGlobalCookiesForNode(e.getUrl(), a)
                }
            }
            s.onOpenEvent(t)
        }
        ,
        !0
    },
    openWSTimeout: function(e) {
        if (e == this.openPhase && this.webSocketInstance && !this.openEventFired)
            try {
                Tg.logDebug(m.resolve(562)),
                this.wsSession.policyBean.increaseConnectTimeout(),
                this.webSocketInstance.close(1e3)
            } catch {
                $n.logDebug(m.resolve(563))
            }
    },
    _load: function(e, t) {
        return this.isOpen ? ($n.logError(m.resolve(564)),
        null) : Pu ? !1 : (this.openRequest = e,
        this.exePhase = t,
        $n.logDebug(m.resolve(565), e.getUrl()),
        this.isReadyToSend() && this.sendFirstRequest(t),
        !0)
    },
    isConnectedToServer: function(e) {
        return ut.verifyOk(this.serverInUse) ? this.serverInUse.indexOf(e) == 0 : ($n.logError(m.resolve(566)),
        !1)
    },
    isReadyToSend: function() {
        return this.webSocketInstance != null && this.webSocketInstance.readyState == 1
    },
    _send: function(e, t) {
        if (!this.isReadyToSend())
            return null;
        t && this.updatePhase(t),
        $n.isDebugLogEnabled() && $n.logDebug(m.resolve(567), this.objectId, e.getFile(), e.getData());
        try {
            this.webSocketInstance.send(e.getFile() + `\r
` + e.getData())
        } catch (n) {
            return $n.logError(m.resolve(568), n),
            !1
        }
        return !0
    },
    sendFirstRequest: function(e) {
        var t = this._send(this.openRequest, e);
        ut.verifyOk(t !== null) || $n.logError(m.resolve(569), e),
        t && (this.isOpen = !0,
        this.wsSession.firstSentNotification(this.openPhase))
    },
    updatePhase: function(e) {
        this.exePhase = e
    },
    onPartialResponse: function(e, t, n) {
        this.openPhase != t || Bt.isUnloaded() || ($n.isDebugLogEnabled() && $n.logDebug(m.resolve(570), this.objectId, e.data),
        this.openEvent = !0,
        Se.executeTask(n, [e.data, this.exePhase]))
    },
    onErrorResponse: function(e, t) {
        this.openPhase != e || Bt.isUnloaded() || ($n.logError(m.resolve(571), this.objectId),
        this.openFailure |= !this.openEvent,
        Se.executeTask(t, ["wsc.unknown", this.openPhase, !0, this.openFailure, !1]))
    },
    onOpenEvent: function(e, t) {
        this.openPhase != e || Bt.isUnloaded() || (this.openEventFired = !0,
        $n.logDebug(m.resolve(572)),
        this.openRequest && this.sendFirstRequest())
    },
    onCloseResponse: function(e, t, n, i) {
        if (!(this.openPhase != t || Bt.isUnloaded())) {
            var r = e ? e.code : -1;
            if ($n.logDebug(m.resolve(573), r, this.openEvent),
            r == 1e3 || r == 1001)
                Se.modifyAllTaskParams(n, [this.openPhase, !0]),
                Se.addPackedTimedTask(n, 300),
                this.off();
            else if (r == 1011) {
                this.openFailure |= !this.openEvent;
                var s = this.openPhase;
                this.off(),
                Se.executeTask(i, ["wsc.server", s, !0, this.openFailure, !0])
            } else {
                this.openFailure |= !this.openEvent;
                var s = this.openPhase;
                this.off(),
                Se.executeTask(i, ["wsc." + r, s, !0, this.openFailure, !1])
            }
        }
    },
    off: function() {
        this.isOpen = !1,
        this.openEventFired = !1,
        this.openPhase = null,
        this.openRequest = null,
        this.openEvent = !1,
        this.webSocketInstance = null,
        this.serverInUse = null
    },
    getEncoder: function() {
        return this.wsEncoder
    },
    setDefaultSessionId: function(e) {
        $n.isDebugLogEnabled() && $n.logDebug(m.resolve(574), e + " on WS connection oid=" + this.objectId),
        this.defaultSessionId = e
    },
    getDefaultSessionId: function() {
        return this.defaultSessionId
    }
};
ot(qn, En);
var R3 = function(e, t, n, i) {
    this._callSuperConstructor(R3, [i]),
    this._cause = e,
    this._phase = n,
    this.session = t
};
R3.prototype = {
    verifySuccess: function() {
        return !this.session.checkSessionPhase(this._phase)
    },
    doRecovery: function() {
        this.session.forceRebind(this._cause)
    },
    getFixedTimeout: function() {
        return this.connOptions.forceBindTimeout
    },
    notifyAborted: function() {}
};
ot(R3, Xl);
var $g = function() {
    arguments.length == 0 ? this.ctor0() : (jt.assert(arguments.length == 2, "Recovery error (1)"),
    this.ctor2(arguments[0], arguments[1])),
    jt.assert(this.invariant(), "Recovery error (2)")
};
$g.prototype = {
    invariant: function() {
        return this.recovery ? this.recoveryTimestampMs != -1 : this.recoveryTimestampMs == -1
    },
    ctor0: function() {
        this.recovery = !1,
        this.recoveryTimestampMs = -1
    },
    ctor2: function(e, t) {
        t.recovery ? e ? (this.recovery = !0,
        this.recoveryTimestampMs = t.recoveryTimestampMs) : (this.recovery = !1,
        this.recoveryTimestampMs = -1) : e ? (this.recovery = !0,
        this.recoveryTimestampMs = Date.now()) : (jt.assert(t.recoveryTimestampMs == -1, "Recovery error (4)"),
        this.recovery = !1,
        this.recoveryTimestampMs = -1)
    },
    restoreTimeLeft: function() {
        this.recovery = !1,
        this.recoveryTimestampMs = -1
    },
    isRecovery: function() {
        return this.recovery
    },
    timeLeftMs: function(e) {
        return this.recovery ? (jt.assert(this.recoveryTimestampMs != -1, "Recovery error (5)"),
        e - (Date.now() - this.recoveryTimestampMs)) : e
    }
};
var Gi = 1
  , jr = 2
  , gs = 3
  , Ds = 4
  , Oa = 5
  , Ho = 6
  , Ac = 7
  , Go = 8
  , Pa = 9
  , Vo = 10
  , Pi = 11
  , Tr = [];
Tr[Gi] = "OFF";
Tr[jr] = "CREATING";
Tr[gs] = "CREATED";
Tr[Ds] = "FIRST_PAUSE";
Tr[Oa] = "FIRST_BINDING";
Tr[Ho] = "PAUSE";
Tr[Ac] = "BINDING";
Tr[Go] = "RECEIVING";
Tr[Pa] = "STALLING";
Tr[Vo] = "STALLED";
Tr[Pi] = "SLEEP";
var Yd = !0
  , Bd = !1
  , c3 = !0
  , Qd = !1
  , st = m.getLoggerProxy(G.SESSION)
  , Oi = m.getLoggerProxy(G.PROTOCOL)
  , XN = 1
  , KN = 1
  , Nt = function(e, t, n, i, r, s, o, a) {
    if (this.objectId = KN++,
    st.isDebugLogEnabled() && st.logDebug(m.resolve(575), "oid=" + this.objectId),
    this.cbOk = Se.packTask(this.onStreamResponse, this),
    this.cbErr = Se.packTask(this.onStreamError, this),
    this.cbEnd = Se.packTask(this.onStreamEnd, this),
    this.isPolling = e,
    this.forced = t,
    this.dataNotificationCount = 0,
    this.phase = Gi,
    this.phaseCount = 0,
    this.push_phase = Et.randomG(100) * 100,
    this.handler = n,
    this.handlerPhase = i,
    this.slowing = n.getSlowing(),
    this.policyBean = n.getPolicyBean(),
    this.connectionBean = n.getConnectionBean(),
    this.evalQueue = null,
    this.controlHandler = n.getControlConnectionHandler(),
    this.engineId = n.getEngineId(),
    this.serverSentBW = 0,
    this.workedBefore = 0,
    this.lastKATO = 0,
    this.lastKATask = null,
    this.reconnectTimeout = null,
    this.sentTime = null,
    this.reset(),
    this.preparingRecovery = !1,
    this.isRecoveryDisabled = !1,
    this.serverBusy = !1,
    r ? (this.bindCount = r.bindCount,
    this.dataNotificationCount = r.dataNotificationCount,
    st.logDebug(m.resolve(576), this.dataNotificationCount),
    this.sessionId = r.sessionId,
    this.sessionServerAddress = r.sessionServerAddress,
    this.push_phase = r.push_phase,
    this.serverSentBW = r.serverSentBW,
    this.serverAddressCache = r.serverAddressCache,
    this.ignoreServerAddressCache = r.ignoreServerAddressCache,
    this.recoveryBean = new $g(o,r.recoveryBean)) : (jt.assert(!o, "Recovery unexpected"),
    this.recoveryBean = new $g),
    this.mpnManager = a,
    vt.isBrowser()) {
        var c = this;
        this.onlineHandler = function(l) {
            var u = c.recoveryBean.timeLeftMs(c.policyBean.sessionRecoveryTimeout);
            u <= 0 && c.closeSession("recovery.timeout.elapsed", Yd, Qd),
            c.launchTimeout("online.again", 0)
        }
        ;
        try {
            window.addEventListener("online", this.onlineHandler, !1)
        } catch {}
    }
};
Nt._OFF = Gi;
Nt.CREATING = jr;
Nt.CREATED = gs;
Nt.FIRST_PAUSE = Ds;
Nt.FIRST_BINDING = Oa;
Nt.BINDING = Ac;
Nt.RECEIVING = Go;
Nt.STALLING = Pa;
Nt._STALLED = Vo;
Nt.PAUSE = Ho;
Nt.SLEEP = Pi;
Nt.prototype = {
    reset: function() {
        st.isDebugLogEnabled() && st.logDebug(m.resolve(577), this.objectId),
        this.bindCount = 0,
        this.sessionServerAddress = null,
        this.sessionId = null,
        this.dataNotificationCount = 0,
        this.serverSentBW = 0,
        this.cachedRequiredBW = !1,
        this.switchRequired = !1,
        this.switchForced = !1,
        this.switchCause = "",
        this.slowRequired = !1,
        this.preparingRecovery = !1
    },
    resetConnectionList: function(e) {},
    changePhaseType: function(e) {
        st.isDebugLogEnabled() && st.logDebug(m.resolve(578), this.objectId, Tr[this.phase], "->", Tr[e]),
        this.phase = e,
        this.phaseCount++;
        var t = this.phaseCount;
        return this.handler.statusChanged(this.handlerPhase),
        t == this.phaseCount
    },
    incPushPhase: function() {
        this.push_phase++
    },
    checkSessionPhase: function(e) {
        return this.push_phase == e
    },
    getHighLevelStatus: function() {
        var e = this.phase;
        return e == Gi ? G.DISCONNECTED : e == Pi ? this.preparingRecovery ? G.TRYING_RECOVERY : G.WILL_RETRY : e == jr ? this.recoveryBean.isRecovery() ? G.TRYING_RECOVERY : G.CONNECTING : e == gs || e == Ds || e == Oa ? G.CONNECTED + this.getFirstConnectedStatus() : e == Vo ? G.STALLED : G.CONNECTED + this.getConnectedHighLevelStatus()
    },
    isOpen: function() {
        return this.phase != Gi && this.phase != jr && this.phase != Pi
    },
    isWaitingOKFromNet: function() {
        return this.phase == jr || this.phase == Ac || this.phase == Oa
    },
    isReceivingAnswer: function() {
        return this.phase == gs || this.phase == Go || this.phase == Pa || this.phase == Vo
    },
    isRecovering: function() {
        return this.recoveryBean.isRecovery()
    },
    isStreamingSession: function() {
        return !this.isPolling
    },
    getPushServerAddress: function() {
        return this.sessionServerAddress == null ? this.serverAddressCache : this.sessionServerAddress
    },
    getSessionId: function() {
        return this.sessionId
    },
    getSessionHost: function() {
        return this.sessionServerAddress
    },
    createSession: function(e, t, n) {
        this.serverBusy = n;
        var i = this.phase != Gi && this.phase != Pi ? Bd : Yd;
        return Rs.canMakeRequest() ? (i == Bd && (st.logDebug(m.resolve(580), this),
        this.closeSession("new." + (t || ""), Bd, Qd)),
        st.logInfo(m.resolve(581), this),
        this.reset(),
        this.prepareSlowing(),
        this.connectionBean.simpleSetter("sessionId", null),
        this.connectionBean.simpleSetter("serverSocketName", null),
        this.connectionBean.simpleSetter("serverInstanceAddress", null),
        this.serverAddressCache = this.connectionBean.serverAddress,
        this.ignoreServerAddressCache = this.policyBean.serverInstanceAddressIgnored,
        this.incPushPhase(),
        !0) : (st.logDebug(m.resolve(579), this),
        this.closeSession("mad", i, c3),
        !1)
    },
    bindSession: function(e) {
        if (!Rs.canMakeRequest())
            return this.closeSession("madb", Bd, c3),
            !1;
        if (this.bindCount++,
        ut.verifyOk(this.phase == Ho || this.phase == Ds || this.phase == Gi) || st.logError(m.resolve(582)),
        this.phase == Gi) {
            if (!this.changePhaseType(Ds))
                return !1;
            this.prepareSlowing()
        }
        return this.handleReverseHeartbeat(!0),
        this.incPushPhase(),
        this.isPolling ? st.logDebug(m.resolve(583), this) : st.logInfo(m.resolve(584), this),
        !0
    },
    isActive: function() {
        return this.phase == gs || this.phase == Oa || this.phase == Ac || this.phase == Go || this.phase == Pa || this.phase == Vo
    },
    requestSwitch: function(e, t, n) {
        this.handlerPhase = e,
        !this.switchRequired && (st.logDebug(m.resolve(585), this),
        this.slowRequired = !1,
        this.phase == jr || this.phase == Pi || this.phase == Gi ? (st.logError(m.resolve(586)),
        this.handler.createMachine(this.handlerPhase, t, n)) : this.phase == Ho || this.phase == Ds ? this.handler.switchMachine(this.handlerPhase, t, n) : (this.switchRequired = !0,
        this.switchForced = n,
        this.switchCause = t,
        this.forceRebind(t)))
    },
    requestSlow: function(e) {
        this.handlerPhase = e,
        !this.slowRequired && (st.logDebug(m.resolve(587), this),
        ut.verifyOk(this.phase != jr && this.phase != Pi && this.phase != Gi) || st.logError(m.resolve(588)),
        this.phase == Ho || this.phase == Ds ? this.handler.slowMachine(this.handlerPhase) : (this.slowRequired = !0,
        this.forceRebind("slow")))
    },
    prepareSlowing: function() {
        (this.phase == Gi || this.phase == Pi) && this.slowing.prepareForSync(),
        this.isPolling && this.forced && this.slowing.resetSync()
    },
    handleReverseHeartbeat: function(e) {
        this.phase == Nt._OFF || this.phase == Nt.CREATING || this.phase == Nt.SLEEP || (this.policyBean.reverseHeartbeatInterval > 0 ? this.controlHandler.startReverseHeartbeats(this.policyBean.reverseHeartbeatInterval, e) : this.controlHandler.stopReverseHeartbeats(e))
    },
    closeSession: function(e, t, n) {
        st.logInfo(m.resolve(589), this, e),
        this.phase != Gi && this.phase != jr && this.phase != Pi ? (this.handler.onObsoleteControlLink(this.getPushServerAddress()),
        t || this.sendDestroySession(e),
        this.handlerPhase = this.handler.onSessionClose(this.handlerPhase, n),
        this.connectionBean.simpleSetter("sessionId", null),
        this.connectionBean.simpleSetter("serverSocketName", null),
        this.connectionBean.simpleSetter("serverInstanceAddress", null)) : this.handlerPhase = this.handler.onSessionClose(this.handlerPhase, n),
        this.shutdown(!n)
    },
    resetTimers: function() {
        this.policyBean.resetRetryDelay(this.policyBean.retryDelay),
        this.policyBean.resetConnectTimeout(this.policyBean.retryDelay)
    },
    shutdown: function(e) {
        if (this.incPushPhase(),
        this.reset(),
        this.changePhaseType(e ? Pi : Gi),
        this.phase == Gi && this.onlineHandler)
            try {
                window.removeEventListener("online", this.onlineHandler)
            } catch {}
        st.logDebug(m.resolve(590), this)
    },
    doPause: function(e) {
        if (this.changePhaseType(this.phase == gs ? Ds : Ho)) {
            this.incPushPhase();
            var t = e;
            this.isPolling && (e >= this.policyBean.pollingInterval || this.policyBean.simpleSetter("pollingInterval", e),
            t = this.getRealPollingInterval()),
            this.phase != Ds && t && t > 0 ? (st.logDebug(m.resolve(591)),
            this.launchTimeout("pause", t)) : this.onTimeout("noPause", this.phaseCount)
        }
    },
    onTimeout: function(e, t, n, i) {
        if (t == this.phaseCount) {
            st.isDebugLogEnabled() && st.logDebug(m.resolve(592), e, Tr[this.phase], "sid", this.sessionId, "cause=", i, "preparingRecovery=", this.preparingRecovery);
            var r = "timeout." + this.phase + "." + this.bindCount;
            if (this.phase == Pi && i && (r = i),
            this.phase == jr) {
                var s = this.recoveryBean.timeLeftMs(this.policyBean.sessionRecoveryTimeout);
                if (this.recoveryBean.isRecovery() && s > 0)
                    st.isDebugLogEnabled() && st.logDebug(m.resolve(593), s),
                    this.policyBean.increaseConnectTimeout(),
                    this.handler.recoverSession(this.handlerPhase, r, this.forced);
                else {
                    st.logDebug(m.resolve(594));
                    var o = "create.timeout";
                    this.closeSession(o, Yd, Qd),
                    this.policyBean.increaseConnectTimeout(),
                    this.launchTimeout("zeroDelay", 0, o)
                }
            } else
                this.phase == gs || this.phase == Ac || this.phase == Vo || this.phase == Pi ? this.slowRequired || this.switchRequired ? (st.logDebug(m.resolve(595)),
                this.handler.createMachine(this.handlerPhase, r + ".switch", this.switchForced)) : !this.isPolling || this.forced ? this.preparingRecovery ? (st.logDebug(m.resolve(596)),
                this.handler.recoverSession(this.handlerPhase, r, this.forced)) : (st.logDebug(m.resolve(597)),
                this.handler.retry(this.handlerPhase, r, this.forced, this.serverBusy)) : (st.logDebug(this.preparingRecovery ? "Timeout: switch transport from polling (ignore recovery)" : "Timeout: switch transport from polling"),
                this.handler.createMachine(this.handlerPhase, r, !1)) : this.phase == Oa ? (this.workedBefore--,
                this.slowRequired || this.switchRequired ? this.handler.createMachine(this.handlerPhase, r + ".switch", this.switchForced) : this.workedBefore > 0 || this.forced ? this.handler.retry(this.handlerPhase, r, this.forced, this.serverBusy) : this.createNewOnFirstBindTimeout() ? this.handler.createMachine(this.handlerPhase, r + ".switch", this.switchForced) : this.onSessionGivesUp(this.handlerPhase, r)) : this.phase == Ho ? (this.isPolling && this.slowing.testPollSync(n),
                this.bindSession("loop")) : this.phase == Ds ? this.bindSession("loop1") : this.phase == Go ? this.timeoutForStalled() : this.phase == Pa ? this.timeoutForReconnect() : st.logWarn(m.resolve(598), this)
        }
    },
    createNewOnFirstBindTimeout: function() {
        return this.isPolling
    },
    shouldGiveUpTrying: function() {
        return this.forced || this.handler.shouldGiveUpTrying()
    },
    onSessionGivesUp: function(e, t) {
        var n = this.shouldGiveUpTrying();
        if (n) {
            var i = this.phase != Gi && this.phase != Pi ? Bd : Yd;
            this.closeSession("giveup", i, c3)
        }
        this.handler.onSessionGivesUp(e, t, n)
    },
    formatArgs: function(e) {
        var t = "";
        for (var n in e)
            t += n + "=" + e[n] + " ";
        return t
    },
    onErrorEvent: function(e, t) {
        t = t || {};
        var n = t.closedOnServer
          , i = t.fromWS
          , r = t.unableToOpen
          , s = t.noImplAvailable
          , o = t.possibleLoop
          , a = t.tryRecovery
          , c = t.serverBusyError
          , l = t.reconnectMaxDelay
          , u = this.recoveryBean.timeLeftMs(this.policyBean.sessionRecoveryTimeout);
        st.isDebugLogEnabled() && st.logDebug(m.resolve(599), Tr[this.phase], "reason=" + e, "sid=" + this.sessionId, "timeLeft=" + u, "isRecoveryDisabled=" + this.isRecoveryDisabled, this.formatArgs(t));
        var h = a && u > 0;
        if (this.phase == Go || this.phase == Vo || this.phase == Pa || this.phase == Ac || this.phase == Ho)
            h && !this.isRecoveryDisabled ? (st.logDebug(m.resolve(600)),
            this.preparingRecovery = !0,
            this.changePhaseType(Pi),
            this.launchTimeout("firstRetryMaxDelay", Et.randomG(this.policyBean.firstRetryMaxDelay), e)) : (st.logDebug(m.resolve(601)),
            this.closeSession(e, n, Qd),
            o ? this.launchTimeout("currentRetryDelay", this.calculateRetryDelay(), e) : l ? this.launchTimeout("reconnectMaxDelay", Math.ceil(Math.random() * l), e) : this.launchTimeout("firstRetryMaxDelay", Et.randomG(this.policyBean.firstRetryMaxDelay), e));
        else if (this.phase == jr || this.phase == gs || this.phase == Oa)
            if (this.recoveryBean.isRecovery() && u > 0 && !n)
                st.logDebug(m.resolve(602)),
                this.preparingRecovery = !0,
                this.changePhaseType(Pi),
                this.launchTimeout("currentRetryDelay", this.calculateRetryDelay(), e),
                this.policyBean.increaseRetryDelay();
            else if (this.switchRequired && !this.forced || vi.isProbablyAndroidBrowser())
                st.logDebug(m.resolve(603)),
                this.handler.createMachine(this.handlerPhase, this.switchCause + ".error", this.switchForced);
            else {
                var d = n ? "closed on server" : "socket error";
                st.logDebug(m.resolve(604), d),
                this.closeSession(e, n, Qd),
                c ? (this.launchTimeout("zeroDelay", 0, e),
                this.policyBean.increaseConnectTimeoutToMax()) : n ? l ? this.launchTimeout("reconnectMaxDelay", Math.ceil(Math.random() * l), e) : this.launchTimeout("zeroDelay", 0, e) : this.recoveryBean.isRecovery() && u <= 0 ? this.launchTimeout("zeroDelay", 0, e) : (this.launchTimeout("currentRetryDelay", this.calculateRetryDelay(), e),
                this.policyBean.increaseRetryDelay())
            }
    },
    onLoop: function(e) {
        this.evalQueue && this.evalQueue.garbageCollection && this.evalQueue.garbageCollection(),
        this.phase == Go || this.phase == Pa || this.phase == Vo || this.phase == gs ? this.switchRequired ? this.handler.switchMachine(this.handlerPhase, this.switchCause, this.switchForced) : this.slowRequired ? this.handler.slowMachine(this.handlerPhase) : this.doPause(e) : (ut.fail(),
        st.logError(m.resolve(605), this))
    },
    onEvent: function() {
        if (this.phase == jr) {
            if (!this.changePhaseType(gs))
                return;
            this.timeoutForExecution()
        } else if (this.phase != gs)
            if (this.phase == Ac || this.phase == Oa || this.phase == Pa || this.phase == Vo || this.phase == Go) {
                if (!this.changePhaseType(Go))
                    return;
                this.timeoutForStalling()
            } else
                ut.fail(),
                st.logError(m.resolve(606), this)
    },
    createSent: function() {
        if (Rs.incMadTest(),
        this.sentTime = Et.getTimeStamp(),
        ut.verifyOk(this.phase == Gi || this.phase == Pi) || st.logError(m.resolve(607)),
        !this.changePhaseType(jr))
            return !1;
        this.launchTimeout("currentConnectTimeout", this.getCurrentConnectTimeout()),
        this.evalQueue = this.handler.getEvalQueue()
    },
    bindSent: function() {
        if (this.sentTime = Et.getTimeStamp(),
        ut.verifyOk(this.phase == Ho || this.phase == Ds) || st.logError(m.resolve(608), this),
        !this.changePhaseType(this.phase == Ho ? Ac : Oa))
            return !1;
        this.serverBusy = !1,
        this.launchTimeout("bindTimeout", this.getBindTimeout()),
        this.evalQueue = this.handler.getEvalQueue()
    },
    launchTimeout: function(e, t, n) {
        return st.isDebugLogEnabled() && st.logDebug(m.resolve(609), t, e),
        Se.addTimedTask(this.onTimeout, t, this, [e, this.phaseCount, t, n])
    },
    timeoutForStalling: function() {
        if (this.policyBean.keepaliveInterval > 0) {
            var e = Et.getTimeStamp();
            e - this.lastKATO < 50 && this.lastKATask ? Se.modifyTaskParam(this.lastKATask, 1, this.phaseCount) : (this.lastKATO = e,
            this.lastKATask = this.launchTimeout("keepaliveInterval", this.policyBean.keepaliveInterval))
        }
    },
    timeoutForStalled: function() {
        this.changePhaseType(Pa) && this.launchTimeout("stalledTimeout", this.policyBean.stalledTimeout)
    },
    timeoutForReconnect: function() {
        if (this.changePhaseType(Vo)) {
            var e = this.recoveryBean.timeLeftMs(this.policyBean.sessionRecoveryTimeout);
            this.preparingRecovery = e > 0 && !this.isRecoveryDisabled,
            this.launchTimeout("reconnectTimeout", this.policyBean.reconnectTimeout)
        }
    },
    timeoutForExecution: function() {
        ut.verifyValue(this.phase, gs) || st.logError(m.resolve(610)),
        this.launchTimeout("stalledTimeout", this.policyBean.stalledTimeout)
    },
    getBindTimeout: function() {
        return this.isPolling ? this.getCurrentConnectTimeout() + this.policyBean.idleTimeout : this.workedBefore > 0 && this.reconnectTimeout != null ? this.reconnectTimeout : this.getCurrentConnectTimeout()
    },
    getRealPollingInterval: function() {
        if (this.phase == Ds)
            return this.policyBean.pollingInterval;
        var e = this.policyBean.pollingInterval;
        if (this.sentTime) {
            var t = Et.getTimeStamp()
              , n = t - this.sentTime;
            e > n ? e -= n : e = 0
        }
        return e
    },
    calculateRetryDelay: function() {
        var e = Et.getTimeStamp() - this.sentTime
          , t = this.getCurrentRetryDelay();
        return e > t ? 0 : t - e
    },
    calculateReconnectTimeout: function() {
        this.sentTime || (ut.fail(),
        st.logError(m.resolve(611), this),
        this.reconnectTimeout = null);
        var e = Et.getTimeStamp() - this.sentTime
          , t = this.getCurrentConnectTimeout();
        this.reconnectTimeout = (e > t ? t : e) + t
    },
    onStreamResponse: function(e, t) {
        if (!(Bt.isUnloaded() || !this.checkSessionPhase(t)) && e !== "") {
            if (e == null) {
                Rs.rollbackLastMadTest(),
                this.onErrorEvent("nullresp");
                return
            }
            this.evalQueue._enqueue(t, e)
        }
    },
    onStreamError: function(e, t, n, i, r) {
        Bt.isUnloaded() || !this.checkSessionPhase(t) || (Rs.rollbackLastMadTest(),
        this.onErrorEvent("failure." + e, {
            fromWS: n,
            unableToOpen: i,
            possibleLoop: r,
            tryRecovery: !0
        }))
    },
    onStreamEnd: function(e, t) {
        this.sessionRecovery && this.phase == Pi || this.checkSessionPhase(e) && (Rs.rollbackLastMadTest(),
        this.onErrorEvent("wrongend", {
            fromWS: t,
            tryRecovery: !0
        }))
    },
    evaluationError: function() {
        this.onErrorEvent("eval")
    },
    onSlowRequested: function() {
        this.switchRequired || this.slowRequired || this.handler.onSlowRequired(this.handlerPhase)
    },
    onSynchOk: function() {
        Oi.isDebugLogEnabled() && Oi.logDebug(m.resolve(612)),
        this.onEvent(),
        this.phase == Go && (this.workedBefore = XN)
    },
    onServerSentBandwidth: function(e) {
        Oi.isDebugLogEnabled() && Oi.logDebug(m.resolve(613), e),
        this.serverSentBW = e,
        this.policyBean.simpleSetter("realMaxBandwidth", e == "unmanaged" ? "unlimited" : e)
    },
    onError41: function() {
        Oi.isDebugLogEnabled() && Oi.logDebug(m.resolve(614)),
        this.onErrorEvent("error41", {
            closedOnServer: !0
        })
    },
    onKeepalive: function() {
        Oi.isDebugLogEnabled() && Oi.logDebug(m.resolve(615)),
        this.onEvent(),
        this.handler.onServerKeepalive()
    },
    onOKReceived: function(e, t, n, i) {
        Oi.isDebugLogEnabled() && Oi.logDebug(m.resolve(616));
        var r = this.getPushServerAddress()
          , s = r;
        t != null && !this.ignoreServerAddressCache && (t = io.completeControlLink(s, t),
        s = t),
        this.sessionServerAddress = s,
        r != this.sessionServerAddress && (this.handler.onObsoleteControlLink(r),
        this.handler.onNewControlLink(this.sessionServerAddress)),
        i && (this.isPolling ? this.policyBean.simpleSetter("idleTimeout", i) : this.policyBean.simpleSetter("keepaliveInterval", i)),
        this.phase == jr ? (this.sessionId != null && this.sessionId != e && (st.logInfo(m.resolve(617), e, this.sessionId),
        this.reset()),
        this.sessionId = e) : (ut.verifyValue(this.sessionId, e) || st.logError(m.resolve(618)),
        this.calculateReconnectTimeout()),
        this.slowing.startSync(this.isPolling),
        this.connectionBean.simpleSetter("sessionId", e),
        this.connectionBean.simpleSetter("serverInstanceAddress", this.sessionServerAddress),
        this.onEvent(),
        this.phase == gs ? this.recoveryBean.isRecovery() ? this.recoveryBean.restoreTimeLeft() : (this.handler.onSessionStart(n),
        this.cachedRequiredBW && (this.changeBandwidth(),
        this.cachedRequiredBW = !1)) : (this.handler.onChangeRequestLimitLength(n),
        this.handler.onSessionBound(),
        this.onSessionBound())
    },
    onIPReceived: function(e) {
        e && (this.handler.onIPReceived(e),
        this.connectionBean.simpleSetter("clientIp", e))
    },
    onSyncReceived: function(e) {
        Oi.isDebugLogEnabled() && Oi.logDebug(m.resolve(619)),
        this.slowing.syncCheck(e),
        this.onEvent()
    },
    onLoopReceived: function(e) {
        Oi.isDebugLogEnabled() && Oi.logDebug(m.resolve(620)),
        this.onLoop(e)
    },
    onSyncError: function(e) {
        this.onSessionError(e)
    },
    forwardError: function(e, t) {
        if (e === this.policyBean.remoteAdapterStatusObserver.metadataErrorCode) {
            this.onMetadataAdapterError();
            return
        }
        switch (e) {
        case 20:
            this.onSyncError("syncerror");
            break;
        case 4:
            this.onSyncError("recovery.error");
            break;
        case 5:
            this.onFatalError(e, t);
            break;
        case 40:
        case 41:
        case 48:
            this.onSessionError("error" + e);
            break;
        default:
            this.onFatalError(e, t)
        }
    },
    forwardREQERR: function(e, t, n) {
        if (e == 20)
            this.onSyncError("syncerror");
        else if (e == 11 || e == 65 || e == 67)
            e == 11 ? this.onFatalError(21, t) : this.onFatalError(e, t);
        else if (n != null)
            try {
                n()
            } catch (i) {
                this.handler.onFatalError(i)
            }
        else
            Oi.isWarnLogEnabled() && Oi.logWarn(m.resolve(621), e, t)
    },
    forwardERROR: function(e, t) {
        this.onFatalError(e, t)
    },
    onMetadataAdapterError: function() {
        Rs.rollbackLastMadTest(),
        this.onErrorEvent("metadata.adapter.disconnected", {
            closedOnServer: !0,
            reconnectMaxDelay: this.policyBean.remoteAdapterStatusObserver.reconnectMaxDelay
        })
    },
    onSessionError: function(e) {
        Rs.rollbackLastMadTest(),
        this.onErrorEvent(e, {
            closedOnServer: !0
        })
    },
    disconnectAndReconnect: function() {
        Rs.rollbackLastMadTest(),
        this.onErrorEvent("remote.adapter.disconnected", {
            reconnectMaxDelay: this.policyBean.remoteAdapterStatusObserver.reconnectMaxDelay
        })
    },
    onServerBusy: function() {
        Rs.rollbackLastMadTest(),
        this.serverBusy = !0,
        this.onErrorEvent("server.busy", {
            closedOnServer: !0,
            serverBusyError: !0
        })
    },
    onFatalError: function(e, t) {
        this.onServerError(e, t)
    },
    onEnd: function(e) {
        Oi.isDebugLogEnabled() && Oi.logDebug(m.resolve(622), e),
        this.closeSession("end", Yd, c3)
    },
    onPROGCounterMismatch: function() {
        this.isRecoveryDisabled = !0
    },
    onUpdateReceived: function(e, t) {
        this.onEvent(),
        this.handler.onUpdateReceived(e, t)
    },
    onEndOfSnapshotEvent: function(e) {
        this.onEvent(),
        this.handler.onEndOfSnapshotEvent(e)
    },
    onClearSnapshotEvent: function(e) {
        this.onEvent(),
        this.handler.onClearSnapshotEvent(e)
    },
    onLostUpdatesEvent: function(e) {
        this.onEvent(),
        this.handler.onLostUpdatesEvent(e)
    },
    onMessageAck: function(e, t) {
        this.onEvent(),
        this.handler.onMessageAck(e, t)
    },
    onMessageOk: function(e, t) {
        this.onEvent(),
        this.handler.onMessageOk(e, t)
    },
    onMessageDeny: function(e, t, n, i) {
        this.onEvent(),
        this.handler.onMessageDeny(e, t, i, n)
    },
    onMessageDiscarded: function(e, t) {
        this.onEvent(),
        this.handler.onMessageDiscarded(e, t)
    },
    onMessageError: function(e, t, n, i) {
        this.onEvent(),
        this.handler.onMessageError(e, t, i, n)
    },
    onTableError: function(e, t, n) {
        this.onEvent(),
        this.handler.onTableError(e, t, n)
    },
    onServerError: function(e, t) {
        this.onEnd(t),
        this.handler.onServerError(e, t)
    },
    onUnsubscription: function(e) {
        this.onEvent(),
        this.handler.onUnsubscription(e)
    },
    onSubscription: function(e, t, n, i, r) {
        this.onEvent(),
        this.handler.onSubscription(e, t, n, i, r)
    },
    onSubscriptionReconf: function(e, t, n) {
        this.onEvent(),
        this.handler.onSubscriptionReconf(e, t, n)
    },
    getDataNotificationProg: function() {
        return this.dataNotificationCount
    },
    onDataNotification: function() {
        this.dataNotificationCount++
    },
    forceRebind: function(e) {
        st.logInfo(m.resolve(623), this);
        var t = io.getForceRebindParams(e, this.slowing.getDelay())
          , n = new R3(e,this,this.push_phase,this.policyBean)
          , i = {
            onREQOK: function(r) {},
            onREQERR: function(r, s, o, a) {
                n.discard(),
                st.logError(m.resolve(624) + o + " " + a + " - The error will be silently ignored.")
            }
        };
        this.controlHandler.addRequest(this.sessionId, t, je.FORCE_REBIND, n, null, i)
    },
    sendDestroySession: function(e) {
        st.logInfo(m.resolve(625), this);
        var t = io.getDestroyParams(this.sessionId, e)
          , n = {
            onREQOK: function(i) {},
            onREQERR: function(i, r, s, o) {
                st.logError(m.resolve(626) + s + " " + o + " - The error will be silently ignored.")
            }
        };
        this.forwardDestroyRequestToTransport(this.sessionId, t, je.DESTROY, null, this.getPushServerAddress(), n)
    },
    changeBandwidth: function() {
        if (!(this.phase == Gi || this.phase == Pi)) {
            if (this.phase == jr) {
                this.cachedRequiredBW = !0;
                return
            } else if (this.serverSentBW == "unmanaged")
                return;
            var e = io.getConstraintParams(this.policyBean)
              , t = {
                onREQOK: function(n) {},
                onREQERR: function(n, i, r, s) {
                    st.logError(m.resolve(627) + YN(e) + " caused the error: ", r, s)
                }
            };
            this.controlHandler.addRequest(null, e, je.CONSTRAINT, null, null, t)
        }
    },
    onServerName: function(e) {
        this.connectionBean.simpleSetter("serverSocketName", e)
    },
    onSessionBound: function() {
        this.resetTimers()
    },
    forwardDestroyRequestToTransport: function(e, t, n, i, r, s) {
        throw new Error("abstract method")
    },
    onMpnRegisterOK: function(e, t) {
        this.mpnManager.eventManager.onRegisterOK(e, t)
    },
    onMpnRegisterError: function(e, t) {
        this.mpnManager.eventManager.onRegisterError(e, t)
    },
    onMpnSubscribeOK: function(e, t) {
        this.mpnManager.eventManager.onSubscribeOK(e, t)
    },
    onMpnSubscribeError: function(e, t, n) {
        this.mpnManager.eventManager.onSubscribeError(e, t, n)
    },
    onMpnUnsubscribeOK: function(e) {
        this.mpnManager.eventManager.onUnsubscribeOK(e)
    },
    onMpnUnsubscribeError: function(e, t, n) {
        this.mpnManager.eventManager.onUnsubscribeError(e, t, n)
    },
    getCurrentConnectTimeout: function() {
        return this.policyBean.currentConnectTimeout
    },
    getCurrentRetryDelay: function() {
        return this.policyBean.currentRetryDelay
    }
};
function YN(e) {
    var t = "{";
    for (var n in e)
        t += n + "=" + e[n] + " ";
    return t += "}",
    t
}
var D3 = function() {
    this.progress = 0
};
D3.prototype = {
    extractNewData: function(e, t) {
        var n = -1;
        if (t)
            n = e.length;
        else {
            if (n = e.lastIndexOf(`\r
`),
            n < 0)
                return null;
            n += 2
        }
        var i = e.substring(this.progress, n);
        return this.progress = n,
        i
    },
    streamProgress: function(e) {
        return this.extractNewData(e, !1)
    },
    streamComplete: function(e) {
        return this.extractNewData(e, !0)
    }
};
var Er = m.getLoggerProxy(G.STREAM), QN = vt.isBrowser() ? 2 : 3, Pg = !0, E3;
vt.isNodeJS() && (E3 = M3.NodeXHR);
var JN = 1;
function _s() {
    this._callSuperConstructor(_s),
    this.objectId = JN++,
    Er.isDebugLogEnabled() && Er.logDebug(m.resolve(628), this.objectId),
    this.isOpen = !1,
    this.sendPhase = null,
    this.cachedSenderStatus = null,
    this.xhrInstance = null,
    this.parser = null,
    this.status0Disabled = !1,
    this.constr = _s
}
_s.name == null && (_s.name = "XSXHRConnection");
var Ca = null;
En.attachPublicStaticMethods(_s, {
    isAvailable: function() {
        if (Ca !== null)
            return Ca;
        if (vi.isProbablyIE(9, !0))
            Ca = !1;
        else if (typeof XMLHttpRequest < "u") {
            var e = new XMLHttpRequest;
            (typeof e.withCredentials < "u" || vt.isOther()) && (Ca = !0)
        } else
            !vt.isBrowser() && E3 && (Ca = !0);
        return Ca === null && (Ca = !1),
        Ca
    },
    isStreamEnabled: function() {
        return !vi.isProbablyOldOpera() && !vi.isProbablyPlaystation()
    },
    isCrossSite: !0,
    isCrossProtocol: !0,
    areCookiesGuaranteed: function() {
        return vt.isNodeJS() || G.PAGE_PROTOCOL != "file:" ? !0 : !vt.isBrowserDocument()
    },
    attachEngineId: !1,
    canUseCustomHeaders: !0
});
function ZN(e) {
    return function() {
        Se.executeTask(e)
    }
}
_s.prototype = {
    toString: function() {
        return ["[", "XSXHRConnection", this.isOpen, this.sendPhase, this.cachedSenderStatus, "]"].join("|")
    },
    _close: function() {
        if (this.isOpen) {
            if (Er.isDebugLogEnabled() && Er.logDebug(m.resolve(629), this.objectId),
            this.sendPhase = null,
            this.xhrInstance)
                try {
                    this.xhrInstance.abort()
                } catch {
                    Er.logDebug(m.resolve(630))
                }
            this.off()
        }
    },
    _load: function(e, t, n, i, r) {
        if (this.isOpen)
            return null;
        E3 ? this.xhrInstance = new E3 : this.xhrInstance = new XMLHttpRequest,
        this.parser = new D3;
        var s = Se.packTask(this.onPartialResponse, this, [t, n, r, i]);
        this.xhrInstance.onreadystatechange = ZN(s),
        this.sendPhase = t,
        this.cachedSenderStatus = null,
        Er.isDebugLogEnabled() && Er.logDebug(m.resolve(631), this.objectId, e.getFile(), e.getData());
        try {
            this.xhrInstance.open(e.getMethod(), e.getUrl(), !0),
            this.xhrInstance.withCredentials = e.getCookieFlag();
            var o = e.getExtraHeaders();
            if (o)
                for (var a in o)
                    this.xhrInstance.setRequestHeader(a, o[a]);
            this.xhrInstance.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"),
            this.xhrInstance.send(e.getData()),
            this.isOpen = !0
        } catch (c) {
            return Er.logError(m.resolve(632), this.objectId, c),
            !1
        }
        return !0
    },
    onPartialResponse: function(e, t, n, i) {
        if (!(this.sendPhase != e || Bt.isUnloaded())) {
            var r = null;
            this.isHttpStatusOk() && t && (this.xhrInstance.readyState == 3 ? r = this.parser.streamProgress(this.xhrInstance.responseText) : this.xhrInstance.readyState == 4 && (r = this.parser.streamComplete(this.xhrInstance.responseText)),
            Er.isDebugLogEnabled() && r && Er.logDebug(m.resolve(633), this.objectId, r),
            r != null && Se.executeTask(t, [r, this.sendPhase])),
            this.xhrInstance.readyState == 4 && (this.isHttpStatusOk() || (this.status0Disabled ? (i && (Er.isDebugLogEnabled && Er.logDebug(m.resolve(634), this.objectId),
            Se.executeTask(i, ["status0", this.sendPhase, !1, Pg, !1])),
            Pg = !Pg,
            this.status0Disabled = !1) : t && Se.executeTask(t, [null, this.sendPhase])),
            Er.isDebugLogEnabled && Er.logDebug(m.resolve(635), this.objectId),
            (this.xhrInstance.readyState == 4 || r == "") && n && Se.addTimedTask(this.notifyEnd, 100, this, [this.sendPhase, n]),
            this.off())
        }
    },
    notifyEnd: function(e, t) {
        Se.executeTask(t, [e])
    },
    off: function() {
        this.isOpen = !1,
        this.sendPhase = null,
        this.xhrInstance && (delete this.xhrInstance.onreadystatechange,
        delete this.xhrInstance)
    },
    isHttpStatusOk: function() {
        try {
            if (this.cachedSenderStatus === null) {
                if (this.xhrInstance.readyState < QN)
                    return !1;
                this.cachedSenderStatus = this.xhrInstance.status >= 200 && this.xhrInstance.status <= 299,
                this.xhrInstance.status == 0 && (this.status0Disabled = !0)
            }
            return this.cachedSenderStatus
        } catch (e) {
            return Er.logDebug(m.resolve(636), this.objectId, e),
            !1
        }
    }
};
ot(_s, En);
var Ea = m.getLoggerProxy(G.STREAM)
  , Kr = function() {
    this._callSuperConstructor(Kr),
    this.isOpen = !1,
    this.sendPhase = null,
    this.parser = null,
    this.xDomainReqInstance = null,
    this.progresses = 0,
    this.constr = Kr
};
Kr.name == null && (Kr.name = "IEXSXHRConnection");
var Ud = null;
En.attachPublicStaticMethods(Kr, {
    isAvailable: function() {
        return Ud !== null || (typeof XDomainRequest < "u" ? Ud = !0 : Ud = !1),
        Ud
    },
    isStreamEnabled: !0,
    isCrossSite: !0,
    isCrossProtocol: !1,
    areCookiesGuaranteed: !1,
    attachEngineId: !1,
    canUseCustomHeaders: !1
});
function l3(e) {
    return function() {
        Se.executeTask(e)
    }
}
Kr.prototype = {
    toString: function() {
        return ["[", "IEXSXHRConnection", this.isOpen, this.sendPhase, "]"].join("|")
    },
    _close: function() {
        if (this.isOpen) {
            if (Ea.logDebug(m.resolve(637)),
            this.sendPhase = null,
            this.xDomainReqInstance)
                try {
                    this.xDomainReqInstance.abort()
                } catch {
                    Ea.logDebug(m.resolve(638))
                }
            this.off()
        }
    },
    _load: function(e, t, n, i, r) {
        if (this.isOpen)
            return null;
        this.progresses = 0,
        this.xDomainReqInstance = new XDomainRequest,
        this.parser = new D3;
        var s = Se.packTask(this.respCompleteEvent, this, [t, n, r])
          , o = Se.packTask(this.asyncError, this, [t, i, "xdr.err"])
          , a = Se.packTask(this.asyncError, this, [t, i, "xdr.timeout"])
          , c = Se.packTask(this.progressEvent, this, [t, n, !1]);
        this.xDomainReqInstance.onload = l3(s),
        this.xDomainReqInstance.onerror = l3(o),
        this.xDomainReqInstance.ontimeout = l3(a),
        this.xDomainReqInstance.onprogress = l3(c),
        this.sendPhase = t,
        Ea.isDebugLogEnabled() && Ea.logDebug(m.resolve(639), e.getFile(), e.getData());
        try {
            this.xDomainReqInstance.open(e.getMethod(), e.getUrl()),
            this.xDomainReqInstance.send(e.getData()),
            this.isOpen = !0
        } catch (l) {
            return Ea.logError(m.resolve(640), l),
            !1
        }
        return !0
    },
    asyncError: function(e, t, n) {
        this.sendPhase != e || Bt.isUnloaded() || (Ea.logDebug(m.resolve(641)),
        Se.executeTask(t, [n, e, !1, this.progresses == 0, !1]))
    },
    progressEvent: function(e, t, n) {
        if (!(this.sendPhase != e || Bt.isUnloaded()) && (this.progresses++,
        t)) {
            var i;
            n ? i = this.parser.streamComplete(String(this.xDomainReqInstance.responseText)) : i = this.parser.streamProgress(String(this.xDomainReqInstance.responseText)),
            Ea.isDebugLogEnabled() && Ea.logDebug(m.resolve(642), i),
            i != null && Se.executeTask(t, [i, this.sendPhase])
        }
    },
    respCompleteEvent: function(e, t, n) {
        this.sendPhase != e || Bt.isUnloaded() || (this.progressEvent(e, t, !0),
        this.off(),
        Ea.logDebug(m.resolve(643)),
        n && Se.addTimedTask(this.notifyEnd, 100, this, [n, e]))
    },
    notifyEnd: function(e, t) {
        Se.executeTask(e, [t])
    },
    off: function() {
        this.isOpen = !1,
        this.sendPhase = null,
        this.parser = null,
        this.progresses = 0,
        this.xDomainReqInstance && (this.xDomainReqInstance.onload = null,
        this.xDomainReqInstance.onerror = null,
        this.xDomainReqInstance.ontimeout = null,
        this.xDomainReqInstance.onprogress = null,
        this.xDomainReqInstance = null)
    }
};
ot(Kr, En);
var Kl = function() {
    this._callSuperConstructor(Kl)
};
En.attachPublicStaticMethods(Kl, {
    isAvailable: !1,
    isCrossSite: !1,
    isCrossProtocol: !1,
    areCookiesGuaranteed: !1,
    attachEngineId: !1,
    canUseCustomHeaders: !1
});
Kl.prototype = {
    _load: function(e, t, n, i, r) {
        return n && Se.addTimedTask(this.notifySender, 1e3, this, [n, t]),
        !0
    },
    notifySender: function(e, t) {
        Se.executeTask(e, ["", t])
    }
};
ot(Kl, En);
var Dc = function() {
    var e = vi.isProbablyAWebkit() && vi.isProbablyChrome(32, !0) ? null : "about:blank"
      , t = {}
      , n = {
        createFrame: function(i, r) {
            if (!vt.isBrowserDocument())
                return null;
            var s = document.getElementsByTagName("BODY")[0];
            if (!s)
                return null;
            r = r || e;
            var o = document.createElement("iframe");
            o.style.visibility = "hidden",
            o.style.height = "0px",
            o.style.width = "0px",
            o.style.display = "none",
            o.name = i,
            o.id = i,
            vi.isProbablyIE() || vi.isProbablyOldOpera() ? (o.src = r,
            s.appendChild(o)) : (s.appendChild(o),
            o.src = r);
            try {
                if (o.contentWindow) {
                    try {
                        o.contentWindow.name = i
                    } catch {}
                    return t[i] = o.contentWindow,
                    t[i]
                } else
                    return document.frames && document.frames[i] ? (t[i] = document.frames[i],
                    t[i]) : null
            } catch {
                return null
            }
        },
        getFrameWindow: function(i, r, s) {
            return r && !t[i] && this.createFrame(i, s),
            t[i] || null
        },
        disposeFrame: function(i) {
            if (t[i]) {
                try {
                    document.getElementsByTagName("BODY")[0].removeChild(document.getElementById(i))
                } catch {}
                delete t[i]
            }
        },
        removeFrames: function() {
            for (var i in t)
                try {
                    document.getElementsByTagName("BODY")[0].removeChild(document.getElementById(i))
                } catch {}
            t = {}
        }
    };
    return n.createFrame = n.createFrame,
    n.getFrameWindow = n.getFrameWindow,
    n.disposeFrame = n.disposeFrame,
    n.removeFrames = n.removeFrames,
    Bt.addUnloadHandler(n.removeFrames),
    n
}()
  , lS = "LS_querystring="
  , t7 = function() {};
t7.prototype = {
    getFixedOverhead: function(e) {
        return lS.length
    },
    getInvisibleOverhead: function(e) {
        return e ? encodeURIComponent(e).length - e.length : 0
    },
    wrapUp: function(e) {
        return lS + encodeURIComponent(e)
    }
};
ot(t7, Ma);
var N3 = function() {};
N3.prototype = {
    toString: function() {
        return "[LegacyEncoder]"
    },
    getExt: function() {
        return ".html"
    },
    wrapUp: function(e) {
        return e
    }
};
ot(N3, t7);
var eF = new N3
  , u3 = m.getLoggerProxy(G.STREAM)
  , tF = 1e3
  , Vl = function(e) {
    this._callSuperConstructor(Vl),
    e && (this.target = Ke.sanitizeIFrameName(e),
    Dc.getFrameWindow(e, !0)),
    this.isOpen = !1,
    this.constr = Vl,
    this.loadPhase = 0
};
En.attachPublicStaticMethods(Vl, {
    isAvailable: function() {
        return vt.isBrowserDocument()
    },
    isCrossSite: !0,
    isCrossProtocol: !0,
    areCookiesGuaranteed: !0,
    attachEngineId: !0,
    canUseCustomHeaders: !1
});
Vl.prototype = {
    toString: function() {
        return ["[", "FormConnection", this.target, "]"].join("|")
    },
    _close: function() {
        u3.logDebug(m.resolve(644)),
        this.isOpen = !1,
        this.loadPhase++
    },
    _load: function(e, t, n, i, r) {
        if (this.isOpen)
            return null;
        this._callSuperMethod(Vl, this._loadName, [e, t, n, i]);
        try {
            this.loadPhase++;
            var s = this.generateForm();
            if (!s)
                return !1;
            u3.isDebugLogEnabled() && u3.logDebug(m.resolve(645), e.getFile(), e.getData()),
            s.formEl.method = e.getMethod(),
            s.formEl.target = this.target,
            s.formEl.action = e.getUrl(),
            s.queryString.value = e.getData(),
            s.formEl.submit();
            var o = this.loadPhase;
            Se.addTimedTask(this.deleteForm, tF, this, [s.formEl, o]),
            this.isOpen = !0
        } catch (a) {
            return u3.logError(m.resolve(646), a),
            !1
        }
        return !0
    },
    generateForm: function() {
        var e = document.getElementsByTagName("BODY")[0];
        if (!e)
            return null;
        var t = {};
        t.formEl = document.createElement("FORM");
        try {
            t.formEl.acceptCharset = "utf-8"
        } catch {}
        return t.formEl.style.display = "none",
        t.queryString = document.createElement("INPUT"),
        t.queryString.type = "hidden",
        t.queryString.name = "LS_querystring",
        t.formEl.appendChild(t.queryString),
        e.appendChild(t.formEl),
        t
    },
    deleteForm: function(e, t) {
        e.parentNode.removeChild(e),
        t == this.loadPhase && (this.isOpen = !1)
    },
    getEncoder: function() {
        return eF
    }
};
ot(Vl, Kl);
var nF = new N3
  , Hd = m.getLoggerProxy(G.STREAM)
  , Nc = function(e) {
    this._callSuperConstructor(Nc),
    this.target = Ke.sanitizeIFrameName(e),
    this.callPhase = 0,
    this.isOpen = !1,
    this.formConnection = null,
    this._frame = Dc.getFrameWindow(this.target, !0),
    this.constr = Nc
};
En.attachPublicStaticMethods(Nc, {
    isAvailable: function() {
        return vt.isBrowserDocument()
    },
    isCrossSite: !1,
    isCrossProtocol: !1,
    areCookiesGuaranteed: !0,
    attachEngineId: !0,
    isStreamEnabled: !0,
    canUseCustomHeaders: !1
});
Nc.prototype = {
    toString: function() {
        return ["[", "FrameConnection", this.isOpen, this.target, this.callPhase, this.formConnection, "]"].join("|")
    },
    _closeImpl: function(e) {
        e == this.callPhase && (this.callPhase++,
        this.isOpen && (this._loadImpl(this.callPhase, ar.aboutBlank),
        this.isOpen = !1))
    },
    _close: function() {
        Hd.logDebug(m.resolve(647));
        var e = ++this.callPhase;
        Se.addTimedTask(this._closeImpl, 0, this, [e])
    },
    _loadImpl: function(e, t, n, i, r) {
        if (!(e != this.callPhase || Bt.isUnloading())) {
            this._callSuperMethod(Nc, this._loadName, [t, n, i, r]),
            this.callPhase++,
            Hd.isDebugLogEnabled() && Hd.logDebug(m.resolve(648), t.getFile(), t.getData());
            try {
                var s = Dc.getFrameWindow(this.target);
                if (s == null)
                    return Hd.logError(m.resolve(649)),
                    !1;
                var o = t.getUrlWithParams();
                s.location.replace(o),
                this.isOpen = !0
            } catch (a) {
                return Hd.logError(m.resolve(650), a),
                !1
            }
            return !0
        }
    },
    loadByForm: function(e, t, n, i) {
        this.formConnection || (this.formConnection = new Vl(this.target)),
        this.callPhase++;
        var r = this.formConnection._load(e, t, n, i);
        return r && (this.isOpen = !0),
        r
    },
    _load: function(e, t, n, i, r) {
        if (e.method == ar._POST)
            return this.loadByForm(e, t, n, i);
        var s = ++this.callPhase;
        return Se.addTimedTask(this._loadImpl, 0, this, [s, e, t, n, i]),
        !0
    },
    getEncoder: function() {
        return nF
    }
};
ot(Nc, Kl);
var KS = function() {
    var e = 5e3
      , t = function() {
        this.initTouches()
    };
    return t.prototype = {
        clean: function() {},
        initTouches: function(n) {
            this.inUse = 0,
            this.touchPhase = 0,
            this.timeout = n || e
        },
        verifyTouches: function(n) {
            n == this.touchPhase && this.inUse <= 0 && this.clean()
        },
        dismiss: function() {
            this.inUse--,
            this.inUse <= 0 && Se.addTimedTask(this.verifyTouches, this.timeout, this, [this.touchPhase])
        },
        touch: function() {
            this.touchPhase++,
            this.inUse < 0 && (this.inUse = 0),
            this.inUse++
        }
    },
    t.prototype.touch = t.prototype.touch,
    t.prototype.dismiss = t.prototype.dismiss,
    t.prototype.clean = t.prototype.clean,
    t.prototype.initTouches = t.prototype.initTouches,
    t
}()
  , Bl = -1
  , iF = 0
  , h3 = 1
  , rF = 2
  , uS = 3
  , hS = 4
  , Nl = m.getLoggerProxy(G.STREAM)
  , sF = 2e3
  , oF = 1e4
  , aF = 0
  , Eu = {}
  , i1 = function(e) {
    this.path = e,
    this.ajaxTimeoutPhase = Et.randomG(),
    this.status = vt.isBrowserDocument() && (window.ActiveXObject || typeof XMLHttpRequest < "u") ? rF : Bl,
    this.aframeId = ++aF,
    this.frameName = "LS_AJAXFRAME_" + this.aframeId,
    this.initTouches(),
    this.attachToGlobal()
};
i1.getAjaxFrame = function(e) {
    return Eu[e] || (Eu[e] = new i1(e),
    Eu[e]._load(!1)),
    Eu[e]
}
;
function cF(e) {
    Eu[e] && delete Eu[e]
}
i1.prototype = {
    toString: function() {
        return ["[", "AjaxFrameHandler", this.status, "]"].join("|")
    },
    attachToGlobal: function() {
        var e = this;
        Ut.exportGlobal(this.aframeId, "LS_a", function(t) {
            e.onAjaxFrameReady(t)
        }, "A")
    },
    clean: function(e) {
        this.status = Bl,
        Ut.cleanGlobal(this.aframeId, "LS_a", "A"),
        cF(this.path),
        Dc.disposeFrame(this.frameName)
    },
    init: function(e) {
        this.ajaxTimeoutPhase++,
        this.status = e ? uS : iF
    },
    _load: function(e) {
        if (this.status != Bl && (Nl.logDebug(m.resolve(651)),
        !this.isReady())) {
            this.init(e);
            var t = this.ajaxTimeoutPhase;
            Ke.isOffline() && Nl.logDebug(m.resolve(652));
            var n = "id=" + this.aframeId + "&";
            Ke.hasDefaultDomain() || (n += "domain=" + Ke.getDomain() + "&");
            var i = new ar(this.path,"xhr.html",n)
              , r = new Nc(this.frameName);
            r._load(i),
            Se.addTimedTask(this.frameTimeout, oF, this, [t]),
            Se.addTimedTask(this.giveUp, sF, this, [t])
        }
    },
    onAjaxFrameReady: function() {
        Bt.isUnloaded() || this.status != h3 && (Nl.logDebug(m.resolve(653)),
        this.status = h3)
    },
    frameTimeout: function(e) {
        this.status != Bl && this.ajaxTimeoutPhase == e && !this.isReady() && (Nl.logDebug(m.resolve(654)),
        this._load(!0))
    },
    giveUp: function(e) {
        this.status != Bl && this.ajaxTimeoutPhase == e && !this.isReady() && (Nl.logDebug(m.resolve(655)),
        this.status = hS)
    },
    disable: function() {
        this.status = Bl,
        this.ajaxTimeoutPhase++
    },
    isReady: function() {
        return this.status === h3
    },
    isDisabled: function() {
        return this.status === Bl || this.status === uS || this.status === hS
    },
    sendXHR: function(e, t, n, i) {
        if (this.isDisabled())
            return !1;
        if (this.status !== h3)
            return null;
        Nl.logDebug(m.resolve(656), e);
        var r;
        try {
            r = Dc.getFrameWindow(this.frameName).sendRequest(e, t, n, i) !== !1
        } catch (s) {
            r = !1,
            Nl.logDebug(m.resolve(657), s)
        }
        return r === !1 && this.disable(),
        r
    }
};
ot(i1, KS, !0, !0);
var Bo = m.getLoggerProxy(G.STREAM)
  , lF = "/*"
  , so = function() {
    this._callSuperConstructor(so),
    this.sendPhase = null,
    this.sender = null,
    this.cachedSenderStatus = null,
    this.response = null,
    this.error = null,
    this.isOpen = !1,
    this.phase = 0,
    this.LS_x = this.onErrorImpl,
    this.myFrameHandler = null,
    this.constr = so
};
so.name == null && (so.name = "XHRConnection");
En.attachPublicStaticMethods(so, {
    isAvailable: function() {
        return vt.isBrowserDocument() && (window.ActiveXObject || typeof XMLHttpRequest < "u")
    },
    isCrossSite: !1,
    isCrossProtocol: !1,
    areCookiesGuaranteed: !0,
    attachEngineId: !1,
    canUseCustomHeaders: !0
});
so.prototype = {
    toString: function() {
        return ["[", "XHRConnection", this.isOpen, this.phase, this.sendPhase, "]"].join("|")
    },
    _load: function(e, t, n, i, r) {
        if (this.myFrameHandler = i1.getAjaxFrame(e.getPath()),
        this.myFrameHandler.isDisabled())
            return this.myFrameHandler.dismiss(),
            !1;
        if (this.myFrameHandler.isReady()) {
            if (this.isOpen)
                return null
        } else
            return null;
        this.myFrameHandler.touch(),
        this.sendPhase = t,
        this.cachedSenderStatus = null,
        this.response = n,
        this.error = i,
        this.connectionEndCallback = r,
        this.phase++;
        var s = this
          , o = this.phase;
        return this.LS_h = function() {
            s.onReadyStateChangeImpl(o)
        }
        ,
        this.isOpen = !0,
        Bo.isDebugLogEnabled() && Bo.logDebug(m.resolve(658), e.getFile(), e.getData()),
        this.myFrameHandler.sendXHR(e.getUrl(), e.getData(), this, e.getExtraHeaders())
    },
    _close: function() {
        if (this.isOpen) {
            this.off(),
            Bo.logDebug(m.resolve(659));
            try {
                this.sender && this.sender.abort && this.sender.abort()
            } catch (e) {
                Bo.logError(m.resolve(660), e)
            }
            this.cleanRef()
        }
    },
    isHttpStatusOk: function() {
        try {
            if (this.cachedSenderStatus === null) {
                if (this.sender.readyState < 2)
                    return !1;
                this.cachedSenderStatus = this.sender.status >= 200 && this.sender.status <= 299
            }
            return this.cachedSenderStatus
        } catch (e) {
            return Bo.logDebug(m.resolve(661), e),
            !1
        }
    },
    onReadyStateChangeImpl: function(e) {
        if (!(Bt.isUnloaded() || e != this.phase || !this.sender) && (this.sender.readyState == 4 || this.sender.readyState == "complete")) {
            var t = null;
            this.isHttpStatusOk() && (t = this.sender.responseText,
            t = t.toString(),
            t.substring(0, 2) == lF && (t = t.substring(2, t.length - 2))),
            Bo.isDebugLogEnabled() && Bo.logDebug(m.resolve(662), t),
            this.response && Se.executeTask(this.response, [t, this.sendPhase]),
            Se.addTimedTask(this.notifyEnd, 100, this, [this.sendPhase]),
            this.off(),
            this.cleanRef()
        }
    },
    notifyEnd: function(e) {
        Se.executeTask(this.connectionEndCallback, [e])
    },
    onErrorImpl: function(e) {
        Bt.isUnloaded() || (this.myFrameHandler.disable(),
        Bo.logDebug(m.resolve(663)),
        this.off(),
        this.error && Se.executeTask(this.error, ["xhr.unknown", this.sendPhase, !1, !1, !1]),
        this.cleanRef())
    },
    cleanRef: function() {
        try {
            delete this.sender.onreadystatechange
        } catch (e) {
            Bo.logDebug(m.resolve(664), e)
        }
        try {
            delete this.sender
        } catch (e) {
            Bo.logDebug(m.resolve(665), e)
        }
        this.error = null,
        this.response = null,
        this.myFrameHandler && this.myFrameHandler.dismiss()
    },
    off: function() {
        this.isOpen = !1,
        this.phase++
    }
};
ot(so, En);
var Gd = m.getLoggerProxy(G.STREAM)
  , zo = function() {
    this._callSuperConstructor(zo),
    this.parser = null,
    this.constr = zo
};
zo.name == null && (zo.name = "XHRStreamingConnection");
var Fl = null;
En.attachPublicStaticMethods(zo, {
    isAvailable: function() {
        return Fl !== null || (vt.isBrowserDocument() ? vi.isProbablyIE() ? Fl = !1 : typeof XMLHttpRequest < "u" ? Fl = typeof new XMLHttpRequest().addEventListener < "u" : Fl = !1 : Fl = !1),
        Fl
    },
    isStreamEnabled: function() {
        return !vi.isProbablyOldOpera()
    },
    isCrossSite: !1,
    isCrossProtocol: !1,
    areCookiesGuaranteed: !0,
    attachEngineId: !1,
    canUseCustomHeaders: !0
});
zo.prototype = {
    toString: function() {
        return ["[", "XHRStreamingConnection", this.isOpen, this.phase, this.sendPhase, "]"].join("|")
    },
    _load: function(e, t, n, i, r) {
        var s = this._callSuperMethod(zo, this._loadName, [e, t, n, i, r]);
        return Gd.logDebug(m.resolve(666)),
        s && (this.parser = new D3),
        s
    },
    onReadyStateChangeImpl: function(e) {
        if (!(Bt.isUnloaded() || e != this.phase || !this.sender)) {
            var t = null;
            this.isHttpStatusOk() && this.response && (this.sender.readyState == 3 ? t = this.parser.streamProgress(this.sender.responseText) : this.sender.readyState == 4 && (t = this.parser.streamComplete(this.sender.responseText)),
            Gd.isDebugLogEnabled() && Gd.logDebug(m.resolve(667), t),
            t != null && Se.executeTask(this.response, [t, this.sendPhase])),
            this.sender.readyState == 4 && (!this.isHttpStatusOk() && this.response && Se.executeTask(this.response, [null, this.sendPhase]),
            Gd.isDebugLogEnabled() && Gd.logDebug(m.resolve(668)),
            (this.sender.readyState == 4 || t == "") && this.connectionEndCallback && Se.addTimedTask(this.notifyEnd, 100, this, [this.sendPhase]),
            this.off(),
            this.cleanRef())
        }
    }
};
ot(zo, so);
function Jd() {
    return !1
}
var vs = m.getLoggerProxy(G.STREAM)
  , mi = function(e, t, n) {
    this.localList = e,
    this.blockXDomainRequest = t,
    this.blockCORS = n,
    this.point = -1
};
mi.disableWS = function() {
    qn.isAvailable = Jd
}
;
mi.disableXHRs = function() {
    _s.isAvailable = Jd,
    Kr.isAvailable = Jd,
    zo.isAvailable = Jd,
    so.isAvailable = Jd
}
;
mi.STREAMING_LIST = [];
var Mg = [_s, Kr, zo];
for (Vd = 0; Vd < Mg.length; Vd++)
    Mg[Vd].isStreamEnabled() && mi.STREAMING_LIST.push(Mg[Vd]);
var Vd;
mi.CONTROL_LIST = [_s, Kr, so];
mi.POLL_LIST = [_s, Kr, so];
mi.useRealCallbacks = function(e) {
    return e.constr.prototype.notifySender != Kl.prototype.notifySender
}
;
mi.isGood = function(e, t, n, i, r, s, o) {
    return vs.isDebugLogEnabled() && vs.logDebug(m.resolve(669), dS(t)),
    t.isAvailable(e) ? n && !t.isCrossSite() ? (vs.logDebug(m.resolve(671)),
    !1) : i && !t.areCookiesGuaranteed() ? (vs.logDebug(m.resolve(672)),
    !1) : r && !t.isCrossProtocol() ? (vs.logDebug(m.resolve(673)),
    !1) : s && !t.canUseCustomHeaders() ? (vs.logDebug(m.resolve(674)),
    !1) : o && !uF(t, o) ? (vs.logDebug(m.resolve(675)),
    !1) : (vs.isDebugLogEnabled() && vs.logDebug(m.resolve(676), dS(t)),
    !0) : (vs.logDebug(m.resolve(670)),
    !1)
}
;
function uF(e, t) {
    for (var n = 0; n < t.length; n++)
        if (t[n] == e)
            return !0;
    return !1
}
mi.prototype = {
    hasNext: function() {
        return this.point < this.localList.length - 1
    },
    getNext: function(e, t, n, i, r) {
        for (vs.isDebugLogEnabled() && vs.logDebug(m.resolve(677), "serverToUse", e, "isCrossSite", t, "areCookiesRequired", n, "isCrossProtocol", i, "hasExtraHeaders", r); this.hasNext(); ) {
            this.point++;
            var s = this.localList[this.point];
            if (!((this.blockCORS || this.blockXDomainRequest) && s === Kr) && !(this.blockCORS && s === _s) && this.isGood(e, s, t, n, i, r))
                return s
        }
        return null
    },
    isGood: function(e, t, n, i, r, s) {
        return mi.isGood(e, t, n, i, r, s, this.localList)
    },
    _reset: function() {
        vs.logDebug(m.resolve(678)),
        this.point = -1
    }
};
function dS(e) {
    return e.name
}
var fS = "LS6__HOURGLASS"
  , hF = 900
  , YS = function() {
    this.needStopHourGlass = !1,
    this.hgFrame = null
};
YS.prototype = {
    prepare: function(e) {
        this.needStopHourGlass = e === Nc,
        this.needStopHourGlass && (this.hgFrame = Dc.getFrameWindow(fS, !0))
    },
    stopHourGlass: function() {
        Se.addTimedTask(this.stopHourGlassExe, hF, this)
    },
    stopHourGlassExe: function() {
        if (this.needStopHourGlass && (this.needStopHourGlass = !1,
        !vi.isProbablyAKhtml() && !(vi.isProbablyIE(6, !0) || vi.isProbablyIE(9, !1))))
            try {
                window.open("about:blank", fS, null, !0)
            } catch {}
    }
};
var Ic = {
    createSession: "createSession",
    bindSession: "bindSession",
    shutdown: "shutdown",
    bindSent: "bindSent",
    onEvent: "onEvent",
    onErrorEvent: "onErrorEvent"
};
Ic = Ke.getReverse(Ic);
var dF = 2e4
  , fF = 1
  , S3 = 1
  , jg = 1;
function pS(e) {
    e && e != jg || (jg++,
    S3 = fF)
}
var Wd = m.getLoggerProxy(G.SESSION)
  , Ule = m.getLoggerProxy(G.PROTOCOL)
  , no = function(e, t, n, i, r, s, o) {
    this._callSuperConstructor(no, arguments),
    this.createList = null,
    this.chosenConnection = null,
    this.connectionList = null,
    this.myGlass = null,
    this.activeConnection = null,
    this.resetConnectionList(s)
};
no.prototype = {
    resetConnectionList: function(e) {
        e = e || !this.policyBean.corsXHREnabled,
        this.createList = new mi(mi.POLL_LIST,!1,e),
        this.isPolling ? this.connectionList = new mi(mi.POLL_LIST,!1,e) : this.connectionList = new mi(mi.STREAMING_LIST,!this.policyBean.xDomainStreamingEnabled,e),
        this.chosenConnection = null
    },
    getConnectedHighLevelStatus: function() {
        return this.isPolling ? G.HTTP_POLLING : G.HTTP_STREAMING
    },
    getFirstConnectedStatus: function() {
        return this.isPolling ? G.HTTP_POLLING : G.SENSE
    },
    toString: function() {
        return ["[", "SessionHTTP", "oid=" + this.objectId, this.isPolling, this.forced, this.phase, this.phaseCount, this.push_phase, this.workedBefore, this.sessionId, this.dataNotificationCount, this.switchRequired, this.slowRequired, "]"].join("|")
    },
    createSession: function(e, t, n) {
        return this._callSuperMethod(no, Ic.createSession, [e, t, n]) ? (this.createSessionExecution(this.phaseCount, t, e),
        !0) : !1
    },
    createSessionExecution: function(e, t, n) {
        if (e == this.phaseCount) {
            if (this.handler.disableCorsCheck(),
            Ke.isOffline())
                if (S3 <= 0) {
                    Wd.logDebug(m.resolve(679)),
                    Se.addTimedTask(this.createSessionExecution, 3e3, this, [e, n, "offline"]);
                    return
                } else
                    S3--,
                    S3 == 0 && Se.addTimedTask(pS, dF, null, [jg]);
            var i = this.executeConnection(n, this.createSessionExecution, t, !1);
            i !== null && (i ? this.createSent() : i === !1 && (Wd.logWarn(m.resolve(680)),
            this.onErrorEvent("no_impl_available", {
                closedOnServer: !0,
                noImplAvailable: !0
            })))
        }
    },
    bindSession: function(e) {
        return this._callSuperMethod(no, Ic.bindSession, [e]) ? (this.activeConnection && this.activeConnection._close(),
        this.fixSpin(),
        this.bindSessionExecution(this.phaseCount, e),
        !0) : !1
    },
    fixSpin: function() {
        if (!Bt.isLoaded() && (this.policyBean.spinFixEnabled === null && (vi.isProbablyAndroidBrowser() || vi.isProbablyApple()) || this.policyBean.spinFixEnabled === !0)) {
            var e = this.bindCount
              , t = this;
            Bt.addOnloadHandler(function() {
                Se.addTimedTask(function() {
                    e == t.bindCount && t.phase == Nt.RECEIVING && t.forceRebind("spinfix")
                }, t.policyBean.spinFixTimeout)
            })
        }
    },
    bindSessionExecution: function(e, t) {
        if (e == this.phaseCount) {
            !this.myGlass && !this.isPolling && (this.myGlass = new YS);
            var n = this.executeConnection(null, this.bindSessionExecution, t, !1);
            if (n !== null) {
                if (n)
                    this.bindSent();
                else if (n === !1 && !this.isPolling) {
                    this.onSessionGivesUp(this.handlerPhase, "streaming.unavailable");
                    return
                }
            }
        }
    },
    recoverSession: function() {
        this.incPushPhase();
        var e = this.executeConnection(null, this.recoverSession, "network.error", !0);
        e !== null && (e ? this.createSent() : e === !1 && (Wd.logError(m.resolve(681)),
        this.onErrorEvent("no_impl_available", {
            closedOnServer: !0,
            noImplAvailable: !0
        })))
    },
    shutdown: function(e) {
        this._callSuperMethod(no, Ic.shutdown, [e]),
        this.activeConnection && this.activeConnection._close()
    },
    generateRequest: function(e, t, n, i) {
        var r = this.phase == Nt._OFF || this.phase == Nt.SLEEP
          , s = this.getPushServerAddress()
          , o = new ar(s + G.LIGHTSTREAMER_PATH);
        o.setCookieFlag(this.policyBean.isCookieHandlingRequired()),
        o.setExtraHeaders(this.policyBean.extractHttpExtraHeaders(r));
        var a = !o.isCrossProtocol() && !o.isCrossSite(), c;
        return i ? c = io.getRecoveryCommand(this.push_phase, this.sessionId, this.policyBean, t, this.slowing.getDelay(), a, this.dataNotificationCount) : c = io.getPushCommand(this.push_phase, this.sessionId, this.policyBean, this.connectionBean, r, this.isPolling, e, t, this.slowing.getDelay(), n, a, this.serverBusy),
        o.setData(c),
        o
    },
    executeConnection: function(e, t, n, i) {
        var r = this.phase == Nt._OFF || this.phase == Nt.SLEEP
          , s = this.generateRequest(e, n, !0, i)
          , o = this.getPushServerAddress();
        this.controlHandler.assignWS(null),
        this.chosenConnection && this.chosenConnection.constr == Kr && (this.chosenConnection = null);
        var a = r ? this.createList : this.connectionList;
        this.chosenConnection && (a.isGood(o, this.chosenConnection.constr, s.isCrossSite(), this.policyBean.isCookieHandlingRequired(), s.isCrossProtocol(), this.policyBean.hasHttpExtraHeaders(r)) || (a._reset(),
        this.chosenConnection = null));
        for (var c = !1, l = (this.isPolling ? "LS6__POLLFRAME" : "LS6__PUSHFRAME") + "_" + this.engineId; (this.chosenConnection || a.hasNext()) && c === !1; ) {
            if (!this.chosenConnection) {
                var u = a.getNext(o, s.isCrossSite(), this.policyBean.isCookieHandlingRequired(), s.isCrossProtocol(), this.policyBean.hasHttpExtraHeaders(r));
                if (!u)
                    return a._reset(),
                    !1;
                this.chosenConnection = new u(l)
            }
            s.setMethod(ar._POST),
            i ? s.setFile(io.getRecoveryPath(this.chosenConnection.getEncoder().getExt())) : s.setFile(io.getPushPath(r, this.isPolling, this.chosenConnection.getEncoder().getExt()));
            var h = this.push_phase;
            if (c = this.chosenConnection.sessionLoad(s, h, this.cbOk, this.cbErr, this.cbEnd, this.engineId),
            c === null)
                return Wd.logDebug(m.resolve(683)),
                Se.addTimedTask(t, 50, this, [this.phaseCount, n, e]),
                null;
            c === !1 ? this.chosenConnection = null : (Wd.logDebug(m.resolve(684)),
            a._reset(),
            this.activeConnection = this.chosenConnection)
        }
        return c
    },
    bindSent: function() {
        this._callSuperMethod(no, Ic.bindSent),
        this.needsHourglassTrick() && this.myGlass.prepare(this.activeConnection.constr)
    },
    needsHourglassTrick: function() {
        return !this.isPolling
    },
    onErrorEvent: function(e, t) {
        t = t || {};
        var n = t.closedOnServer
          , i = t.fromWS
          , r = t.unableToOpen
          , s = t.noImplAvailable
          , o = t.possibleLoop
          , a = t.tryRecovery
          , c = t.serverBusyError;
        r && (this.chosenConnection.constr == _s || this.chosenConnection.constr == Kr) && (a || this.handler.onCorsError(this.handlerPhase)),
        this._callSuperMethod(no, Ic.onErrorEvent, arguments)
    },
    onEvent: function() {
        this.phase == Nt.FIRST_BINDING && pS(),
        this.needsHourglassTrick() && (this.phase == Nt.BINDING || this.phase == Nt.FIRST_BINDING) && this.myGlass.stopHourGlass(),
        this._callSuperMethod(no, Ic.onEvent)
    },
    forwardDestroyRequestToTransport: function(e, t, n, i, r, s) {
        this.controlHandler.addRequest(e, t, n, i, r, s)
    }
};
ot(no, Nt);
var wu = 1
  , kg = 2
  , gS = 3
  , mS = 4
  , vS = 5
  , _S = 6
  , qr = {
    createSent: "createSent",
    onTimeout: "onTimeout",
    onLoop: "onLoop",
    onStreamError: "onStreamError",
    onStreamEnd: "onStreamEnd",
    onErrorEvent: "onErrorEvent",
    shutdown: "shutdown",
    onSessionGivesUp: "onSessionGivesUp",
    onSessionBound: "onSessionBound"
};
qr = Ke.getReverse(qr);
var $r = m.getLoggerProxy(G.SESSION)
  , pF = !1
  , or = function(e, t, n, i, r, s, o) {
    this._callSuperConstructor(or, arguments),
    this.wsConn = null,
    this.wsPhase = wu,
    this.openWSPhase = null,
    this.forceEarlyWSOff = !1
};
or.prototype = {
    toString: function() {
        return ["[", "SessionWS", "oid=" + this.objectId, this.isPolling, this.forced, this.phase, this.phaseCount, this.push_phase, this.wsPhase, this.workedBefore, this.sessionId, this.dataNotificationCount, this.wsConn, this.switchRequired, this.slowRequired, "]"].join("|")
    },
    changeWSPhase: function(e) {
        this.wsPhase = e
    },
    getConnectedHighLevelStatus: function() {
        return this.isPolling ? G.WS_POLLING : G.WS_STREAMING
    },
    getFirstConnectedStatus: function() {
        return G.SENSE
    },
    openWS: function() {
        ut.verifyValue(this.wsPhase, wu) || $r.logError(m.resolve(685)),
        this.openWSPhase = this.push_phase,
        this.wsConn = new qn(this);
        var e = this.getPushServerAddress()
          , t = new ar(e + G.LIGHTSTREAMER_PATH);
        return t.setCookieFlag(this.policyBean.isCookieHandlingRequired()),
        t.setExtraHeaders(this.policyBean.extractHttpExtraHeaders(!1)),
        mi.isGood(e, qn, t.isCrossSite(), this.policyBean.isCookieHandlingRequired(), t.isCrossProtocol(), this.policyBean.hasHttpExtraHeaders(!1)) && ($r.logDebug(m.resolve(686)),
        this.wsConn.openSocket(t, this.openWSPhase, this.cbOk, this.cbErr, this.cbEnd)) ? (this.controlHandler.assignWS(this.wsConn),
        this.changeWSPhase(kg),
        !0) : (this.changeWSPhase(vS),
        !1)
    },
    createSent: function() {
        this._callSuperMethod(or, qr.createSent),
        this.policyBean.earlyWSOpenEnabled && !this.forceEarlyWSOff && this.openWS()
    },
    bindSessionExecution: function(e, t) {
        if (e == this.phaseCount) {
            if (this.forceEarlyWSOff = !1,
            this.wsPhase == wu ? this.openWS() : this.wsPhase == kg && (this.wsConn.isConnectedToServer(this.getPushServerAddress()) || ($r.logWarn(m.resolve(687)),
            this.wsConn._close(),
            this.changeWSPhase(wu),
            this.openWS())),
            this.wsPhase == _S) {
                this.onSessionGivesUp(this.handlerPhase, "ws.early.closed");
                return
            } else if (this.wsPhase == vS) {
                this.onSessionGivesUp(this.handlerPhase, "ws.notgood");
                return
            } else if (this.wsPhase == gS) {
                qn.disableClass(this.getPushServerAddress()),
                this.onSessionGivesUp(this.handlerPhase, "ws.early.openfail");
                return
            }
            var n = this.generateRequest(null, t, !1, !1)
              , i = !1;
            n.setFile(io.getPushPath(!1, this.isPolling, this.wsConn.getEncoder().getExt()));
            var r = !1;
            this.wsPhase == kg ? (i = this.wsConn.sessionLoad(n, this.push_phase, this.cbOk, this.cbErr, this.cbEnd, this.engineId),
            r = !0) : this.wsPhase == mS ? i = this.wsConn._send(n, this.push_phase) : (ut.fail(),
            $r.logError(m.resolve(688), this)),
            i === null ? ($r.logDebug(m.resolve(689)),
            Se.addTimedTask(this.bindSessionExecution, 50, this, [e, t])) : i === !1 ? ($r.logWarn(m.resolve(690)),
            this.onSessionGivesUp(this.handlerPhase, "ws.false")) : r || ($r.logDebug(m.resolve(691)),
            this.bindSent())
        }
    },
    firstSentNotification: function(e) {
        this.openWSPhase == e && ($r.logDebug(m.resolve(692)),
        this.bindSent(),
        this.changeWSPhase(mS))
    },
    onTimeout: function(e, t, n, i, r) {
        t == this.phaseCount && (this.phase == Nt.CREATING && (this.forceEarlyWSOff = !0),
        this._callSuperMethod(or, qr.onTimeout, [e, t, n, i, r]))
    },
    onLoop: function(e) {
        this._callSuperMethod(or, qr.onLoop, [e]),
        this.wsConn && this.wsConn.updatePhase(this.push_phase)
    },
    onStreamError: function(e, t, n, i, r) {
        n ? t == this.openWSPhase && this._callSuperMethod(or, qr.onStreamError, [e, this.push_phase, n, i, r]) : (this.phase == Nt.CREATING && (this.forceEarlyWSOff = !0),
        this._callSuperMethod(or, qr.onStreamError, arguments))
    },
    onStreamEnd: function(e, t) {
        t ? e == this.openWSPhase && (this.phase == Nt.OFF || this.phase == Nt.CREATING || this.phase == Nt.CREATED ? this.onErrorEvent("ws.early.end", {
            fromWS: !0
        }) : (ut.verifyDiffValue(this.phase, Nt.FIRST_PAUSE) || $r.logError(m.resolve(693), this),
        this._callSuperMethod(or, qr.onStreamEnd, [this.push_phase, t]))) : (this.phase == Nt.CREATING && (this.forceEarlyWSOff = !0),
        this._callSuperMethod(or, qr.onStreamEnd, arguments))
    },
    onErrorEvent: function(e, t) {
        t = t || {};
        var n = t.closedOnServer
          , i = t.fromWS
          , r = t.unableToOpen
          , s = t.noImplAvailable
          , o = t.possibleLoop
          , a = t.tryRecovery
          , c = t.serverBusyError;
        i ? (ut.verifyDiffValue(this.wsPhase, wu) || $r.logError(m.resolve(694), this),
        r ? this.changeWSPhase(gS) : this.changeWSPhase(_S),
        this.phase == Nt.OFF || this.phase == Nt.CREATING || this.phase == Nt.CREATED ? $r.logDebug(m.resolve(695), this) : this.phase == Nt.FIRST_PAUSE ? ($r.logDebug(m.resolve(696), this),
        r && qn.disableClass(this.getPushServerAddress()),
        this.onSessionGivesUp(this.handlerPhase, "ws.error." + e)) : this.isPolling && this.phase == Nt.PAUSE ? (ut.verifyNotOk(r) || $r.logError(m.resolve(697), this),
        $r.logDebug(m.resolve(698), this),
        this.closeSession(e, n, pF),
        this.onTimeout("zeroDelay", this.phaseCount, 0, "ws.broken.wait")) : this._callSuperMethod(or, qr.onErrorEvent, arguments)) : (this.phase == Nt.CREATING && (this.forceEarlyWSOff = !0),
        this._callSuperMethod(or, qr.onErrorEvent, arguments))
    },
    shutdown: function(e) {
        this._callSuperMethod(or, qr.shutdown, [e]),
        this.wsConn && (this.openWSPhase = null,
        this.wsConn._close(),
        this.wsConn = null,
        this.controlHandler.assignWS(null)),
        this.changeWSPhase(wu)
    },
    needsHourglassTrick: function() {
        return !1
    },
    onSessionGivesUp: function(e, t) {
        qn.disableClass(this.getPushServerAddress()),
        this._callSuperMethod(or, qr.onSessionGivesUp, [e, t])
    },
    onSessionBound: function() {
        this._callSuperMethod(or, qr.onSessionBound),
        this.wsConn.setDefaultSessionId(this.sessionId)
    },
    forwardDestroyRequestToTransport: function(e, t, n, i, r, s) {
        this.controlHandler.addSyncRequest(e, t, n, i, r, s)
    }
};
ot(or, no);
var Ag = 5 / 10
  , Ig = 7e3
  , gF = 2e4
  , mF = m.getLoggerProxy(G.PROTOCOL)
  , $d = m.getLoggerProxy(G.SESSION)
  , QS = function(e, t) {
    this.refTime = 0,
    this.meanElaborationDelay = null,
    this.hugeFlag = !1,
    this.policyBean = e,
    this.session = null
};
QS.prototype = {
    toString: function() {
        return ["[", "SlowingHandler", this.meanElaborationDelay, this.refTime, Ag, Ig, "]"].join("|")
    },
    isLate: function(e) {
        return this.meanElaborationDelay != null && this.meanElaborationDelay > e
    },
    changeSession: function(e) {
        this.session = e
    },
    getDelay: function() {
        return this.meanElaborationDelay != null && this.meanElaborationDelay > 0 ? Math.round(this.meanElaborationDelay) : null
    },
    resetSync: function() {
        this.meanElaborationDelay = null,
        this.hugeFlag = !1
    },
    prepareForSync: function() {
        this.hugeFlag = !1
    },
    testPollSync: function(e) {
        this.testSync(e)
    },
    syncCheck: function(e) {
        if (ut.verifyOk(this.session.isReceivingAnswer()) || mF.logError(m.resolve(699)),
        this.session.isStreamingSession()) {
            var t = this.testSync(e * 1e3);
            t ? this.policyBean.slowingEnabled && this.session.onSlowRequested() : this.session.onSynchOk()
        }
    },
    startSync: function(e) {
        e || this.resetSync(),
        this.refTime = Et.getTimeStamp()
    },
    testSync: function(e) {
        var t = Et.getTimeStamp();
        if (!this.refTime)
            return !0;
        var n = t - this.refTime - e;
        return this.meanElaborationDelay == null ? (this.meanElaborationDelay = n,
        $d.logDebug(m.resolve(700)),
        !1) : n > gF && n > this.meanElaborationDelay * 2 && (this.hugeFlag = !this.hugeFlag,
        this.hugeFlag) ? ($d.logInfo(m.resolve(701)),
        this.meanElaborationDelay > Ig) : (this.meanElaborationDelay = this.meanElaborationDelay * Ag + n * (1 - Ag),
        this.meanElaborationDelay < 60 ? (this.meanElaborationDelay = 0,
        $d.logDebug(m.resolve(702)),
        !1) : this.isLate(Ig) ? ($d.logInfo(m.resolve(703)),
        !0) : ($d.logDebug(m.resolve(704)),
        !1))
    }
};
var Hi = m.getLoggerProxy(G.REQUESTS);
function Rc(e) {
    this.queue = [],
    this.keys = {},
    this.batchType = e,
    this.messageNextKey = 0
}
var vF = "C"
  , _F = "F"
  , yF = "X"
  , bF = "H"
  , SF = "M";
Rc.prototype = {
    toString: function() {
        return ["[", "ControlRequestBatch", this.batchType, this.queue.length, "]"].join("|")
    },
    addRequestInternal: function(e, t) {
        this.keys[e] = t,
        this.queue.push(e),
        function(n) {
            if (n.batchType == je.MESSAGE) {
                var i = t.LS_sequence
                  , r = t.LS_msg_prog;
                if (i != null && r != null)
                    for (var s = 0, o = n.queue.length - 1; s < o; s++) {
                        var a = n.queue[s]
                          , c = a.LS_sequence
                          , l = a.LS_msg_prog;
                        i == c && r == l && (Hi.isDebugLogEnabled() && Hi.logErrorExc(new Error("backtrace"), "Duplicated message", "seq=", i, "prog=", r, "ptr=", t === a),
                        Hi.logError(m.resolve(705), "seq=", i, "prog=", r))
                    }
            }
        }(this)
    },
    addUniqueRequestInternal: function(e, t) {
        this.keys[e] ? this.keys[e] = t : this.addRequestInternal(e, t)
    },
    addRequestToBatch: function(e, t) {
        var n = e.getType();
        if (n == je.MESSAGE || n == je.LOG || n == je.HEARTBEAT)
            return this.batchType != n ? (ut.fail(),
            Hi.logError(m.resolve(706), this),
            !1) : (n == je.HEARTBEAT ? this.addUniqueRequestInternal(bF, e) : this.addRequestInternal(this.messageNextKey++, e),
            !0);
        if (!(this.batchType == je.ADD || this.batchType == je.MPN))
            return ut.fail(),
            Hi.logError(m.resolve(707), this),
            !1;
        var i;
        switch (n) {
        case je.CONSTRAINT:
            i = vF;
            break;
        case je.FORCE_REBIND:
            i = _F;
            break;
        case je.CHANGE_SUB:
            i = yF + e.getKey();
            break;
        case je.MPN:
            i = SF + e.getKey();
            break;
        default:
            i = e.getKey();
            break
        }
        var r = this.keys[i];
        if (Hi.logDebug(m.resolve(708), this, i, e),
        r)
            if (n == je.CONSTRAINT || n == je.FORCE_REBIND || n == je.MPN) {
                t || (Hi.logDebug(m.resolve(709)),
                this.substituteRequest(i, e));
                return
            } else if (n == je.REMOVE) {
                r.retryingOrHost ? (Hi.logDebug(m.resolve(710)),
                t || this.substituteRequest(i, e)) : r.getType() == je.REMOVE ? Hi.logDebug(m.resolve(711)) : (Hi.logDebug(m.resolve(712)),
                ut.verifyNotOk(t) || Hi.logError(m.resolve(713), this),
                t || this.removeRequestByKey(i));
                return
            } else if (n == je.DESTROY) {
                for (; r && e.retryingOrHost != r.retryingOrHost; )
                    Hi.logDebug(m.resolve(714)),
                    i += "_",
                    r = this.keys[i];
                if (r) {
                    Hi.logDebug(m.resolve(715));
                    return
                }
            } else {
                t || (Hi.logDebug(m.resolve(716)),
                this.substituteRequest(i, e));
                return
            }
        Hi.logDebug(m.resolve(717)),
        this.addRequestInternal(i, e)
    },
    getLength: function() {
        return this.queue.length
    },
    substituteRequest: function(e, t) {
        this.keys[e] = t
    },
    removeRequestByIndex: function(e) {
        if (this.queue.length <= e)
            return Hi.logError(m.resolve(718)),
            null;
        var t = this.queue[e];
        this.queue.splice(e, 1);
        var n = this.keys[t];
        return delete this.keys[t],
        n
    },
    removeRequestByKey: function(e) {
        if (!this.keys[e])
            return Hi.logError(m.resolve(719)),
            null;
        for (var t = 0; t < this.queue.length; t++)
            if (this.queue[t] == e)
                return this.removeRequestByIndex(t)
    },
    shift: function() {
        return this.removeRequestByIndex(0)
    },
    pop: function() {
        return this.removeRequestByIndex(this.queue.length - 1)
    },
    last: function() {
        return this.getRequestObject(this.queue.length - 1)
    },
    firstRequest: function() {
        return this.getRequestObject(0)
    },
    getRequestObject: function(e) {
        if (this.queue.length <= 0)
            return null;
        var t = this.queue[e];
        return this.keys[t]
    },
    getBatchType: function() {
        return this.batchType
    }
};
var dt = m.getLoggerProxy(G.REQUESTS)
  , yS = m.getLoggerProxy(G.STREAM)
  , ms = 1
  , JS = 2
  , qg = 3
  , Mu = {};
Mu[ms] = "IDLE";
Mu[JS] = "STAND BY";
Mu[qg] = "WAITING RESP";
var xF = !0
  , Su = !1
  , wF = 200
  , CF = 4e3
  , d3 = 1
  , Rg = 2
  , f3 = 3
  , bS = 4
  , SS = 5
  , EF = 1;
function TF(e) {
    return Mu[e]
}
function OF(e, t, n, i) {
    var r = e.firstRequest();
    if (!r)
        return null;
    var s = new ar((r.retryingOrHost && r.retryingOrHost !== !0 ? r.retryingOrHost : t) + G.LIGHTSTREAMER_PATH);
    return s.setCookieFlag(n),
    s.setExtraHeaders(i),
    s
}
var ZS = function(e, t, n, i) {
    this.corsDisabled = !1,
    this.connectionList = null,
    this.conn = null,
    this.messageQueue = null,
    this.controlQueue = null,
    this.logQueue = null,
    this.destroyQueue = null,
    this.hbQueue = null,
    this.mpnQueue = null,
    this.currentReverseHeartbeatInterval = 0,
    this.grantedReverseHeartbeatInterval = 0,
    this.requestLimit = 0,
    this.statusPhase = 1,
    this.status = ms,
    this.phase = 1,
    this.typeFlag = 0,
    this.lastBatch = null,
    this.fakeSyncError = !1,
    this._owner = e,
    this.policyBean = t,
    this.engId = n,
    this.wsConn = null,
    this.requestListenerMap = {},
    this.resetConnectionList(i),
    this._reset()
};
ZS.prototype = {
    toString: function() {
        return ["[", "ControlConnectionHandler", TF(this.status), this.lastBatch, this.requestLimit, this.currentReverseHeartbeatInterval, "]"].join("|")
    },
    setRequestLimit: function(e) {
        this.requestLimit = e,
        dt.logDebug(m.resolve(720), this)
    },
    startReverseHeartbeats: function(e, t) {
        t ? (this.currentReverseHeartbeatInterval = e,
        this.grantedReverseHeartbeatInterval = e,
        dt.logInfo(m.resolve(721), this)) : this.grantedReverseHeartbeatInterval == 0 || e < this.grantedReverseHeartbeatInterval ? (this.currentReverseHeartbeatInterval = e,
        dt.logInfo(m.resolve(722), this)) : (this.currentReverseHeartbeatInterval = this.grantedReverseHeartbeatInterval,
        dt.logInfo(m.resolve(723), this)),
        this.status == ms && this.sendReverseHeartbeat(this.statusPhase)
    },
    sendReverseHeartbeat: function(e) {
        this.status != ms || this.statusPhase != e || this.currentReverseHeartbeatInterval == 0 || (dt.logDebug(m.resolve(724), this),
        this.addRequest(null, "", je.HEARTBEAT))
    },
    stopReverseHeartbeats: function(e) {
        e ? (dt.logInfo(m.resolve(725), this),
        this.currentReverseHeartbeatInterval = 0,
        this.grantedReverseHeartbeatInterval = 0) : this.grantedReverseHeartbeatInterval == 0 ? (dt.logInfo(m.resolve(726), this),
        this.currentReverseHeartbeatInterval = 0) : (dt.logInfo(m.resolve(727), this),
        this.currentReverseHeartbeatInterval = this.grantedReverseHeartbeatInterval)
    },
    resetConnectionList: function(e) {
        this.connectionList = new mi(mi.CONTROL_LIST,!1,!this.policyBean.corsXHREnabled || e),
        this.conn = null
    },
    _close: function() {
        dt.logDebug(m.resolve(728)),
        this.conn && this.conn._close()
    },
    changeStatus: function(e, t) {
        this.statusPhase++,
        e == ms && this.currentReverseHeartbeatInterval > 0 && Se.addTimedTask(this.sendReverseHeartbeat, this.currentReverseHeartbeatInterval, this, [this.statusPhase]),
        dt.isDebugLogEnabled() && dt.logDebug(m.resolve(729), t + Mu[this.status] + " -> " + Mu[e]),
        this.status = e
    },
    _reset: function() {
        dt.logDebug(m.resolve(730), this),
        this.requestLimit = 0,
        this.messageQueue = new Rc(je.MESSAGE),
        this.controlQueue = new Rc(je.ADD),
        this.hbQueue = new Rc(je.HEARTBEAT),
        this.mpnQueue = new Rc(je.MPN),
        this.wsConn = null,
        this.currentReverseHeartbeatInterval = 0,
        this.grantedReverseHeartbeatInterval = 0,
        this.logQueue || (this.logQueue = new Rc(je.LOG)),
        this.destroyQueue || (this.destroyQueue = new Rc(je.ADD)),
        this.reqQueues = [this.messageQueue, this.controlQueue, this.logQueue, this.destroyQueue, this.hbQueue, this.mpnQueue],
        this.phase++;
        var e = this.lastBatch ? this.lastBatch.getBatchType() : null;
        e !== null && e !== je.DESTROY && e !== je.LOG ? (ut.verifyDiffValue(this.status, ms) || dt.logError(m.resolve(731)),
        this._close(),
        this.lastBatch = null,
        this.changeStatus(ms, "_reset"),
        this.dequeue(Su, "reset1")) : e === null && (ut.verifyValue(this.status, ms) || dt.logError(m.resolve(732)),
        ut.verifyValue(this.lastBatch, null) || dt.logError(m.resolve(733)),
        this.dequeue(Su, "reset2"))
    },
    assignWS: function(e) {
        e ? dt.logDebug(m.resolve(734), this) : this.wsConn && dt.logDebug(m.resolve(735), this),
        this.wsConn = e
    },
    addRequest: function(e, t, n, i, r, s) {
        this.addRequestListener(t, s),
        Se.addTimedTask(this.addRequestExe, 0, this, [this.phase, e, t, n, i, r])
    },
    addSyncRequest: function(e, t, n, i, r) {
        this.addRequestExe(this.phase, e, t, n, i, r)
    },
    checkPhase: function(e, t) {
        return t == je.DESTROY || t == je.LOG ? !0 : this.phase === e
    },
    addToProperBatch: function(e, t) {
        e == je.MESSAGE ? this.messageQueue.addRequestToBatch(t) : e == je.LOG ? this.logQueue.addRequestToBatch(t) : e == je.DESTROY ? this.destroyQueue.addRequestToBatch(t) : e == je.HEARTBEAT ? this.hbQueue.addRequestToBatch(t) : e == je.MPN ? this.mpnQueue.addRequestToBatch(t) : this.controlQueue.addRequestToBatch(t)
    },
    addRequestExe: function(e, t, n, i, r, s) {
        if (this.checkPhase(e, i)) {
            dt.logInfo(m.resolve(736), this, n);
            var o = new je(n,r,i,t,s);
            this.addToProperBatch(i, o),
            this.status == ms ? this.dequeue(xF, "add") : dt.logDebug(m.resolve(737), this)
        }
    },
    dequeue: function(e, t) {
        if (e === !0)
            dt.logDebug(m.resolve(738), e, this),
            this.dequeueControlRequests(this.statusPhase, t);
        else {
            dt.logDebug(m.resolve(739), e, this);
            var n = e === !1 ? 0 : e;
            Se.addTimedTask(this.dequeueControlRequests, n, this, [this.statusPhase, "async." + t])
        }
    },
    dequeueControlRequests: function(e, t) {
        if (e == this.statusPhase) {
            for (var n = 0; n < EF; ) {
                n++,
                this.changeStatus(JS, "dequeueControlRequests"),
                dt.logDebug(m.resolve(740), t, this);
                var i = null;
                if (this.lastBatch != null ? (dt.logDebug(m.resolve(741)),
                i = this.sendBatch(this.lastBatch)) : (dt.logDebug(m.resolve(742)),
                i = this.selectAndSendBatch()),
                i == d3)
                    dt.logInfo(m.resolve(743)),
                    this.lastBatch = null;
                else if (i == Rg) {
                    dt.logInfo(m.resolve(744)),
                    this.dequeue(wF, "later");
                    return
                } else if (i == f3) {
                    dt.logWarn(m.resolve(745)),
                    this.lastBatch && this.lastBatch.notifySenders(!0),
                    this.lastBatch = null,
                    this.dequeue(Su, "no");
                    return
                } else if (i == bS) {
                    dt.logInfo(m.resolve(746)),
                    this.changeStatus(qg, "dequeueControlRequests"),
                    this.lastBatch && this.lastBatch.notifySenders(),
                    this.dequeue(CF, "http");
                    return
                } else if (i == SS)
                    dt.logInfo(m.resolve(747)),
                    this.changeStatus(qg, "dequeueControlRequests"),
                    this.lastBatch && this.lastBatch.notifySenders(),
                    this.lastBatch = null,
                    this.changeStatus(ms, "dequeueControlRequests");
                else {
                    dt.logInfo(m.resolve(748)),
                    this._close(),
                    this.changeStatus(ms, "dequeueControlRequests");
                    return
                }
            }
            this.dequeue(Su, "limit")
        }
    },
    selectAndSendBatch: function() {
        for (var e = 0; e < this.reqQueues.length; ) {
            if (this.typeFlag = this.typeFlag < this.reqQueues.length - 1 ? this.typeFlag + 1 : 0,
            this.reqQueues[this.typeFlag].getLength() > 0)
                return this.sendBatch(this.reqQueues[this.typeFlag]);
            e++
        }
        return null
    },
    sendBatch: function(e) {
        (function() {
            if (e.batchType == je.MESSAGE)
                for (var a = 0, c = e.queue.length; a < c; a++) {
                    var l = e.queue[a]
                      , u = l.LS_sequence
                      , h = l.LS_msg_prog;
                    if (u != null && h != null)
                        for (var d = a + 1, f = e.queue.length; d < f; d++) {
                            var g = e.queue[d]
                              , p = g.LS_sequence
                              , v = g.LS_msg_prog;
                            u == p && h == v && (dt.isDebugLogEnabled() && dt.logErrorExc(new Error("backtrace"), "Duplicated message", "seq=", u, "prog=", h, "ptr=", l === g),
                            dt.logError(m.resolve(749), "seq=", u, "prog=", h))
                        }
                }
        }
        )();
        var t = this._owner.getPushServerAddress()
          , n = OF(e, t, this.policyBean.isCookieHandlingRequired(), this.policyBean.extractHttpExtraHeaders(!1));
        if (n == null)
            return dt.logDebug(m.resolve(750)),
            d3;
        dt.logDebug(m.resolve(751));
        var i = !1;
        if (this.wsConn) {
            dt.logDebug(m.resolve(752));
            var r = this.customizeRequest(e, this.wsConn);
            if (r == null)
                return dt.logDebug(m.resolve(753)),
                d3;
            if (n.setFile(r.getFile()),
            n.setData(r.getData()),
            i = this.wsConn._send(n),
            i === !1)
                this.wsConn = null;
            else
                return i === null ? Rg : SS
        }
        this.conn && (this.connectionList.isGood(t, this.conn.constr, n.isCrossSite(), this.policyBean.isCookieHandlingRequired(), n.isCrossProtocol(), this.policyBean.hasHttpExtraHeaders(!1)) || (this.connectionList._reset(),
        this.conn = null));
        for (var s = !1; (this.conn || this.connectionList.hasNext()) && s === !1; ) {
            if (!this.conn) {
                var o = this.connectionList.getNext(t, n.isCrossSite(), this.policyBean.isCookieHandlingRequired(), n.isCrossProtocol(), this.policyBean.hasHttpExtraHeaders(!1));
                if (!o)
                    return dt.logWarn(m.resolve(754), this.conn),
                    this.connectionList._reset(),
                    f3;
                this.conn = new o("LS6__CONTROLFRAME"),
                dt.logDebug(m.resolve(755), this.conn)
            }
            var r = this.customizeRequest(e, this.conn);
            if (r == null)
                return dt.logDebug(m.resolve(756)),
                d3;
            if (n.setFile(r.getFile()),
            n.setData(r.getData()),
            n.setMethod(r.getMethod()),
            this.lastBatch.setPhase(this.statusPhase),
            this.conn._close(),
            this.fakeSyncError && (n._data = n._data.replace(/LS_session=.*&/g, "LS_session=FAKE&")),
            i = this.conn._load(n, this.lastBatch.getPhase(), Se.packTask(this.onReadyForNextRequest, this), Se.packTask(this.onErrorEvent, this)),
            i === !1)
                dt.logDebug(m.resolve(757)),
                this.conn = null;
            else
                return i === null ? (dt.logDebug(m.resolve(758)),
                Rg) : (this.connectionList._reset(),
                bS)
        }
        return i === !1 || (ut.fail(),
        dt.logError(m.resolve(759))),
        f3
    },
    customizeRequest: function(e, t) {
        var n = t.getEncoder();
        if (this.lastBatch == null)
            this.lastBatch = new ex,
            this.lastBatch.setEncoder(n),
            this.lastBatch.fill(e, this.requestLimit, this._owner.getSessionId(), this.policyBean.isCookieHandlingRequired(), this.policyBean.extractHttpExtraHeaders(!1));
        else if (this.lastBatch.needsNewEncode(n)) {
            this.lastBatch.setEncoder(n);
            var i = this.lastBatch.refill(this.requestLimit, this._owner.getSessionId(), this.policyBean.isCookieHandlingRequired(), this.policyBean.extractHttpExtraHeaders(!1));
            if (i)
                for (var r = i.getBatchType(); i.getLength() > 0; )
                    this.addToProperBatch(r, i.shift())
        }
        return this.lastBatch.isEmpty() ? (this.lastBatch = null,
        null) : this.lastBatch.getRequest()
    },
    onReadyForNextRequest: function(e, t) {
        if (!(!this.lastBatch || t != this.lastBatch.getPhase())) {
            yS.isDebugLogEnabled() && yS.logDebug(m.resolve(760), t, e),
            dt.logInfo(m.resolve(761), t),
            this.changeStatus(ms, "onReadyForNextRequest");
            var n = this.lastBatch.firstRequest().getType();
            this.lastBatch = null,
            this._owner.enqueueControlResponse(e),
            this.dequeue(Su, "ready4next")
        }
    },
    onErrorEvent: function(e, t) {
        !this.lastBatch || t != this.lastBatch.getPhase() || (dt.logInfo(m.resolve(762), this, e),
        this.changeStatus(ms, "onErrorEvent"),
        this.lastBatch = null,
        this.dequeue(Su, "error"))
    },
    addRequestListener: function(e, t) {
        var n = e.LS_reqId;
        n != null && t != null && (this.requestListenerMap[n] = t)
    },
    getAndRemoveRequestListener: function(e) {
        var t = this.requestListenerMap[e];
        return delete this.requestListenerMap[e],
        t
    }
};
var ex = function() {
    this.batch = null,
    this.encoder = null,
    this.request = null,
    this.phase = null
};
ex.prototype = {
    toString: function() {
        return this.batch ? this.batch.toString() : null
    },
    getBatchType: function() {
        return this.batch ? this.batch.getBatchType() : null
    },
    firstRequest: function() {
        return this.batch ? this.batch.firstRequest() : null
    },
    getLength: function() {
        return this.batch ? this.batch.getLength() : 0
    },
    shift: function() {
        return this.batch ? this.batch.shift() : null
    },
    getRequest: function() {
        return this.request
    },
    needsNewEncode: function(e) {
        return e != this.encoder
    },
    setEncoder: function(e) {
        this.encoder = e
    },
    fill: function(e, t, n, i, r) {
        if (!(e.getLength() <= 0)) {
            this.batch = new Rc(e.getBatchType()),
            this.request = this.encoder.initRequest(e, i, r);
            var s = ""
              , o = this.encoder.encode(e, n, !0);
            if (o === null) {
                this.batch = null,
                this.request = null;
                return
            }
            var a = this.encoder.getFixedOverhead(this.request.getFile())
              , c = this.encoder.getInvisibleOverhead(o) + o.length;
            t > 0 && c + a > t && dt.logWarn(m.resolve(763), s);
            do
                s += o,
                this.batch.addRequestToBatch(e.shift()),
                a += c,
                e.getLength() > 0 && (o = this.encoder.encode(e, n),
                o && (c = this.encoder.getInvisibleOverhead(o) + o.length));
            while (o && (t == 0 || a + c < t) && e.getLength() > 0);
            this.request.setData(this.encoder.wrapUp(s))
        }
    },
    refill: function(e, t, n, i) {
        var r = this.batch;
        return this.batch = null,
        this.fill(r, e, t, n, i),
        r.getLength() > 0 ? r : null
    },
    getPhase: function() {
        return this.phase
    },
    setPhase: function(e) {
        this.phase = e
    },
    isEmpty: function() {
        return this.getLength() <= 0
    },
    notifySenders: function(e) {
        for (var t = 0, n = null; n = this.batch.getRequestObject(t); ) {
            var i = n.getBridge();
            i && Se.addTimedTask(i.notifySender, 0, i, [e]),
            t++
        }
    }
};
var tx;
for (xS in {
    notifySender: !0
})
    tx = xS;
var xS, ku = function(e, t, n, i, r, s, o) {
    this._callSuperConstructor(ku, [t]),
    this.seqData = i,
    this.num = r,
    this.sequence = s,
    this.phase = n,
    this._owner = e,
    this.waitingAck = o
};
ku.prototype = {
    notifySender: function(e) {
        if (this._callSuperMethod(ku, tx, [e]),
        !e && (this._owner.sentOnNetwork(this.sequence, this.num),
        !this.waitingAck)) {
            this._owner.noAckMessageSent(this.sequence, this.num);
            return
        }
    },
    verifySuccess: function() {
        return !(this._owner.checkMessagePhase(this.phase) && this.seqData.messages[this.num] && this.seqData.messages[this.num].query != null)
    },
    doRecovery: function() {
        this._owner.resend(this.num, this)
    },
    notifyAborted: function() {},
    getProg: function() {
        return this.num
    },
    getOwner: function() {
        return this._owner
    }
};
ot(ku, Xl);
var wr = m.getLoggerProxy(G.MESSAGES)
  , nx = function(e, t, n) {
    this.active = !1,
    this.messagePhase = 0,
    this.sequences = {},
    this.unorderedMap = {},
    this.unorderedSeqNum = 0,
    this.controlHandler = e,
    this.pushPagesHandler = t,
    this.connOptions = n
};
nx.prototype = {
    _close: function() {
        this.active = !1,
        this.sequences = {},
        this.unorderedSeqNum = 0,
        this.unorderedMap = {},
        this.messagePhase++,
        wr.logDebug(m.resolve(764))
    },
    activate: function() {
        if (wr.logDebug(m.resolve(765)),
        !this.active) {
            for (var e in this.sequences) {
                var t = this.sequences[e];
                for (var n in t.messages) {
                    var i = t.messages[n].query;
                    if (i != null) {
                        var r = new ku(this,this.connOptions,this.messagePhase,t,n);
                        this.sendExe(n, i, r)
                    }
                }
            }
            this.active = !0
        }
    },
    _send: function(e, t, n, i) {
        wr.logDebug(m.resolve(766));
        var r = this.sequences[t];
        r == null && (r = {},
        r.messageNum = 0,
        r.messages = {},
        this.sequences[t] = r),
        r.messageNum++;
        var s = {
            LS_message: e,
            LS_reqId: Ke.nextRequestId()
        }
          , o = !1;
        n ? o = !0 : s.LS_outcome = "false",
        t != G._UNORDERED_MESSAGES && (s.LS_sequence = encodeURIComponent(t),
        o = !0,
        i && (s.LS_max_wait = i)),
        o ? s.LS_msg_prog = t == G._UNORDERED_MESSAGES ? this.mapUnordered(r.messageNum) : r.messageNum : n == null && (s.LS_ack = "false");
        var a = {};
        if (a.query = s,
        a.listener = n,
        r.messages[r.messageNum] = a,
        this.active) {
            wr.logInfo(m.resolve(767), s);
            var c = new ku(this,this.connOptions,this.messagePhase,r,r.messageNum,t,o);
            this.sendExe(r.messageNum, s, c)
        }
    },
    mapUnordered: function(e) {
        var t = ++this.unorderedSeqNum;
        return this.unorderedMap[t] = e,
        t
    },
    resolveUnorderedNum: function(e) {
        return this.unorderedMap[e] ? this.unorderedMap[e] : e
    },
    removeFromUnorderedMap: function(e) {
        for (var t in this.unorderedMap)
            if (this.unorderedMap[t] == e) {
                delete this.unorderedMap[t];
                return
            }
    },
    extractMappedUnordered: function(e) {
        for (var t in this.unorderedMap)
            if (this.unorderedMap[t] == e)
                return t
    },
    checkMessagePhase: function(e) {
        return e == this.messagePhase
    },
    resend: function(e, t) {
        var n = t.seqData.messages[e].query;
        wr.logDebug(m.resolve(768), n),
        this.sendExe(e, n, t)
    },
    sendExe: function(e, t, n) {
        var i = t.LS_sequence == null ? G._UNORDERED_MESSAGES : t.LS_sequence
          , r = t.LS_ack != "false"
          , s = {
            onREQOK: function(o) {
                r && o.LS_w(4, e, i, 0, 0)
            },
            onREQERR: function(o, a, c, l) {
                o.LS_l(c, e, "MSG" + i, l, !0)
            }
        };
        this.controlHandler.addRequest(e, t, je.MESSAGE, n, null, s)
    },
    ack: function(e, t) {
        t = e == G._UNORDERED_MESSAGES ? this.resolveUnorderedNum(t) : t,
        wr.logInfo(m.resolve(769), e, t);
        var n = this.sequences[e];
        n.messages[t] && (n.messages[t].query != null && (wr.logDebug(m.resolve(770)),
        n.messages[t].query = null),
        n.messages[t].listener == null && (wr.logDebug(m.resolve(771)),
        this._clear(e, t)))
    },
    noAckMessageSent: function(e, t) {
        wr.logDebug(m.resolve(772), e, t),
        this._clear(e, t)
    },
    _clear: function(e, t) {
        wr.logDebug(m.resolve(773));
        var n = this.sequences[e];
        n && n.messages[t] && (delete n.messages[t],
        e == G._UNORDERED_MESSAGES && this.removeFromUnorderedMap(t))
    },
    getListener: function(e, t) {
        var n = this.sequences[e];
        return n && n.messages[t] && n.messages[t].listener ? n.messages[t].listener : null
    },
    sentOnNetwork: function(e, t) {
        wr.logDebug(m.resolve(774), e, t);
        var n = this.getListener(e, t);
        if (n) {
            var i = this.pushPagesHandler.getPushPageHandler(n.pageNum);
            i && i.onMessageOnNetwork(n.prog)
        }
    },
    _complete: function(e, t) {
        t = e == G._UNORDERED_MESSAGES ? this.resolveUnorderedNum(t) : t,
        wr.logInfo(m.resolve(775), e, t);
        var n = this.getListener(e, t);
        if (n) {
            var i = this.pushPagesHandler.getPushPageHandler(n.pageNum);
            i && i.onMessageComplete(n.prog)
        }
        this._clear(e, t)
    },
    notifyDiscarded: function(e, t) {
        t = e == G._UNORDERED_MESSAGES ? this.resolveUnorderedNum(t) : t,
        wr.logInfo(m.resolve(776), e, t);
        var n = this.getListener(e, t);
        if (n) {
            var i = this.pushPagesHandler.getPushPageHandler(n.pageNum);
            i && i.onMessageDiscarded(n.prog)
        }
        this._clear(e, t)
    },
    notifyDenied: function(e, t, n, i) {
        i = e == G._UNORDERED_MESSAGES ? this.resolveUnorderedNum(i) : i,
        wr.logInfo(m.resolve(777), e, i);
        var r = this.getListener(e, i);
        if (r) {
            var s = this.pushPagesHandler.getPushPageHandler(r.pageNum);
            s && s.onMessageDenied(r.prog, t, n)
        }
        this._clear(e, i)
    },
    notifyError: function(e, t, n, i) {
        i = e == G._UNORDERED_MESSAGES ? this.resolveUnorderedNum(i) : i,
        wr.logInfo(m.resolve(778), e, i);
        var r = this.getListener(e, i);
        if (r) {
            var s = this.pushPagesHandler.getPushPageHandler(r.pageNum);
            s && s.onMessageError(r.prog, t, n)
        }
        this._clear(e, i)
    }
};
var ix = {
    unquote: decodeURIComponent
}
  , rx = function(e) {
    this.msg = e,
    this.fields = e.split(",")
};
rx.prototype = {
    getField: function(e) {
        if (e >= this.fields.length)
            throw new Error("Field " + e + " does not exist");
        return this.fields[e]
    },
    getFieldUnquoted: function(e) {
        return ix.unquote(this.getField(e))
    },
    getFieldAsInt: function(e) {
        var t = this.getField(e)
          , n = parseInt(t, 10);
        if (isNaN(n))
            throw new Error("Not an integer field");
        return n
    },
    getFieldAsFloat: function(e) {
        var t = this.getField(e)
          , n = parseFloat(t);
        if (isNaN(n))
            throw new Error("Not a float field");
        return n
    },
    getRawMsg: function() {
        return this.msg
    }
};
var Pc = m.getLoggerProxy(G.STREAM)
  , sx = function(e) {
    this.engId = e,
    this.equeue = [],
    this.hasFailed = !1,
    this.lsc = {},
    this.lsc.LS_window = Ut["_" + e],
    this.lsc.window = this.lsc.LS_window,
    this.LS_window = this.lsc.LS_window,
    this.LS_l = this.LS_window.LS_l,
    this.LS_u = this.LS_window.LS_u,
    this.LS_w = this.LS_window.LS_w,
    this.LS_e = this.LS_window.LS_e,
    this.LS_svrname = this.LS_window.LS_svrname,
    this.LS_n = this.LS_window.LS_n,
    this.LS_s = this.LS_window.LS_s,
    this.LS_o = this.LS_window.LS_o,
    this.LS_l = this.LS_window.LS_l,
    this.LS_MPNREG = this.LS_window.LS_MPNREG,
    this.LS_MPNOK = this.LS_window.LS_MPNOK,
    this.LS_MPNDEL = this.LS_window.LS_MPNDEL,
    this.dequeueAction = this.generateClosure(this.lsc)
};
sx.prototype = {
    toString: function() {
        return "[EvalQueue|" + this.equeue.length + "]"
    },
    generateClosure: function() {
        var e = this;
        return function(t) {
            try {
                e.parseText(t)
            } catch {
                e.LS_l(61, null, null, "Malformed message received")
            }
        }
    },
    _enqueue: function(e, t) {
        this.stillValid() && (this.equeue.push({
            p: e,
            d: t
        }),
        Pc.isDebugLogEnabled() && Pc.logDebug(m.resolve(779)),
        Se.addTimedTask(this.dequeueAll, 0, this))
    },
    changeSession: function(e) {
        this.session = e
    },
    dequeueAll: function() {
        for (Pc.isDebugLogEnabled() && Pc.logDebug(m.resolve(780), this.equeue.length); this.equeue.length > 0; ) {
            var e = this.equeue.shift();
            if (!this.session || !this.session.checkSessionPhase(e.p)) {
                Pc.logWarn(m.resolve(781), e.p, e.d, this.session);
                continue
            }
            try {
                this.dequeueAction(e.d)
            } catch (t) {
                this.hasFailed = !0,
                this.equeue = [],
                console.log(t),
                Pc.logError(m.resolve(782), t, e.d),
                this.session.evaluationError()
            }
        }
    },
    stillValid: function() {
        return !this.hasFailed
    },
    dispose: function() {},
    parseText: function(e) {
        for (var t = e.split(`\r
`), n = 0; n < t.length; n++) {
            var i = t[n];
            if (i != "")
                try {
                    var r = new rx(i);
                    switch (r.getField(0)) {
                    case "U":
                        this.processUpdate(r);
                        break;
                    case "REQOK":
                        this.processREQOK(r);
                        break;
                    case "SUBOK":
                        this.processSUBOK(r);
                        break;
                    case "SUBCMD":
                        this.processSUBCMD(r);
                        break;
                    case "UNSUB":
                        this.processUNSUB(r);
                        break;
                    case "CONOK":
                        this.processCONOK(r);
                        break;
                    case "SERVNAME":
                        this.processSERVNAME(r);
                        break;
                    case "CLIENTIP":
                        this.processCLIENTIP(r);
                        break;
                    case "CONS":
                        this.processCONS(r);
                        break;
                    case "LOOP":
                        this.processLOOP(r);
                        break;
                    case "PROG":
                        this.processPROG(r);
                        break;
                    case "CONERR":
                        this.processCONERR(r);
                        break;
                    case "REQERR":
                        this.processREQERR(r);
                        break;
                    case "ERROR":
                        this.processERROR(r);
                        break;
                    case "MSGDONE":
                        this.processMSGDONE(r);
                        break;
                    case "MSGFAIL":
                        this.processMSGFAIL(r);
                        break;
                    case "EOS":
                        this.processEOS(r);
                        break;
                    case "CS":
                        this.processCS(r);
                        break;
                    case "OV":
                        this.processOV(r);
                        break;
                    case "CONF":
                        this.processCONF(r);
                        break;
                    case "PROBE":
                        this.processPROBE(r);
                        break;
                    case "SYNC":
                        this.processSYNC(r);
                        break;
                    case "NOOP":
                        break;
                    case "END":
                        this.processEND(r);
                        break;
                    case "MPNREG":
                        this.processMPNREG(r);
                        break;
                    case "MPNOK":
                        this.processMPNOK(r);
                        break;
                    case "MPNDEL":
                        this.processMPNDEL(r);
                        break;
                    default:
                        throw new Error("Unknown message: " + i)
                    }
                } catch (s) {
                    throw Pc.logError(m.resolve(783), i, s),
                    new Error("Malformed message: " + i)
                }
        }
    },
    processUpdate: function(e) {
        var t = null
          , n = e.getFieldAsInt(1)
          , i = e.getFieldAsInt(2)
          , r = this.parseUpdates(e.getRawMsg());
        try {
            this.LS_u(t, [n, i].concat(r))
        } catch (s) {
            Pc.logError(m.resolve(784), s)
        }
    },
    processSUBOK: function(e) {
        var t = null
          , n = e.getFieldAsInt(1)
          , i = e.getFieldAsInt(2)
          , r = e.getFieldAsInt(3);
        this.LS_w(6, t, n, i, r, -1, -1)
    },
    processSUBCMD: function(e) {
        var t = null
          , n = e.getFieldAsInt(1)
          , i = e.getFieldAsInt(2)
          , r = e.getFieldAsInt(3)
          , s = e.getFieldAsInt(4)
          , o = e.getFieldAsInt(5);
        this.LS_w(6, t, n, i, r, s - 1, o - 1)
    },
    processUNSUB: function(e) {
        var t = null
          , n = e.getFieldAsInt(1);
        this.LS_w(8, t, n)
    },
    processCONOK: function(e) {
        var t = null
          , n = e.getField(1)
          , i = e.getFieldAsInt(2)
          , r = e.getFieldAsInt(3)
          , s = e.getField(4) == "*" ? null : e.getField(4);
        this.LS_e(1, t, n, s, r, i)
    },
    processSERVNAME: function(e) {
        var t = e.getField(1);
        this.LS_svrname(t)
    },
    processCLIENTIP: function(e) {
        var t = e.getField(1);
        this.session != null && this.session.onIPReceived(t)
    },
    processCONS: function(e) {
        var t = null, n, i = e.getField(1);
        i == "unlimited" || i == "unmanaged" ? n = i : n = e.getFieldAsFloat(1),
        this.LS_e(5, t, n)
    },
    processLOOP: function(e) {
        var t = null
          , n = e.getFieldAsInt(1);
        this.LS_e(2, t, n)
    },
    processCONERR: function(e) {
        var t = null
          , n = e.getFieldAsInt(1)
          , i = e.getFieldUnquoted(2);
        this.LS_l(n, t, null, i)
    },
    processREQOK: function(e) {
        if (e.getRawMsg() != "REQOK") {
            var t = e.getFieldAsInt(1)
              , n = this.getRequestListener(t);
            n?.onREQOK(this)
        }
    },
    processREQERR: function(e) {
        var t = null
          , n = e.getFieldAsInt(1)
          , i = e.getFieldAsInt(2)
          , r = e.getFieldUnquoted(3)
          , s = this.getRequestListener(n)
          , o = null;
        if (s != null) {
            var a = this;
            o = function() {
                s.onREQERR(a, t, i, r)
            }
        }
        this.session != null && this.session.forwardREQERR(i, r, o)
    },
    processERROR: function(e) {
        var t = e.getFieldAsInt(1)
          , n = e.getFieldUnquoted(2);
        this.session != null && this.session.forwardERROR(t, n)
    },
    processEOS: function(e) {
        var t = null
          , n = e.getFieldAsInt(1)
          , i = e.getFieldAsInt(2);
        this.LS_n(t, [n, i])
    },
    processCS: function(e) {
        var t = null
          , n = e.getFieldAsInt(1)
          , i = e.getFieldAsInt(2);
        this.LS_s(t, [n, i])
    },
    processMSGDONE: function(e) {
        var t = e.getField(1);
        t == "*" && (t = G._UNORDERED_MESSAGES);
        var n = e.getFieldAsInt(2);
        this.LS_w(5, n, t, 0, 0)
    },
    processMSGFAIL: function(e) {
        var t = e.getField(1);
        t == "*" && (t = G._UNORDERED_MESSAGES);
        var n = e.getFieldAsInt(2)
          , i = e.getFieldAsInt(3)
          , r = e.getFieldUnquoted(4);
        this.LS_l(i, n, "MSG" + t, r)
    },
    processOV: function(e) {
        var t = null
          , n = e.getFieldAsInt(1)
          , i = e.getFieldAsInt(2)
          , r = e.getFieldAsInt(3);
        this.LS_o(t, [n, i, r])
    },
    processCONF: function(e) {
        var t = null, n = e.getFieldAsInt(1), i, r = e.getField(2), s = e.getField(3);
        if (s != "filtered" && s != "unfiltered")
            throw new Error("Unknown mode");
        r == "unlimited" ? i = r : i = e.getFieldAsFloat(2),
        this.LS_w(9, t, n, i)
    },
    processPROG: function(e) {
        var t = null
          , n = e.getFieldAsInt(1);
        this.LS_e(7, t, n)
    },
    processPROBE: function(e) {
        var t = null;
        this.LS_u(t, [])
    },
    processEND: function(e) {
        var t = null
          , n = e.getFieldAsInt(1)
          , i = e.getFieldUnquoted(2);
        this.LS_e(4, t, n, i)
    },
    processSYNC: function(e) {
        var t = null
          , n = e.getFieldAsInt(1);
        this.LS_s(t, n)
    },
    processMPNREG: function(e) {
        var t = e.getField(1)
          , n = e.getField(2);
        this.LS_MPNREG(t, n)
    },
    processMPNOK: function(e) {
        var t = e.getField(1)
          , n = e.getField(2);
        this.LS_MPNOK(t, n)
    },
    processMPNDEL: function(e) {
        var t = e.getField(1);
        this.LS_MPNDEL(t)
    },
    parseUpdates: function(e) {
        var t = e.indexOf(",") + 1;
        ut.verifyOk(t == 2);
        var n = e.indexOf(",", t) + 1;
        if (n <= 0)
            throw new Error("Missing subscription field");
        var i = e.indexOf(",", n) + 1;
        if (i <= 0)
            throw new Error("Missing item field");
        ut.verifyOk(e.substring(0, t) == "U,");
        var r = Dg(e.substring(t, n - 1), "Invalid subscription")
          , s = Dg(e.substring(n, i - 1), "Invalid item")
          , o = {};
        o.length = -1;
        var a = []
          , c = i - 1;
        for (ut.verifyOk(e.charAt(c) == ","); c < e.length; ) {
            var l = e.indexOf("|", c + 1);
            l == -1 && (l = e.length);
            var u = e.substring(c + 1, l);
            if (u == "")
                a.push(o);
            else if (u.charAt(0) == "#") {
                if (u.length != 1)
                    throw new Error("Wrong field quoting");
                a.push(null)
            } else if (u.charAt(0) == "$") {
                if (u.length != 1)
                    throw new Error("Wrong field quoting");
                a.push("")
            } else if (u.charAt(0) == "^")
                for (var h = Dg(u.substring(1), "Invalid field count"); h-- > 0; )
                    a.push(o);
            else {
                var d = ix.unquote(u);
                a.push(d)
            }
            c = l
        }
        return a
    },
    getRequestListener: function(e) {
        e: {
            if (this.session == null)
                break e;
            var t = this.session.controlHandler.getAndRemoveRequestListener(e);
            if (t == null)
                break e;
            return t
        }
        return null
    }
};
function Dg(e, t) {
    var n = parseInt(e, 10);
    if (isNaN(n))
        throw new Error(t);
    return n
}
var to = 1
  , Ns = 2
  , jn = 3
  , jo = 4
  , $o = 5
  , ro = 6
  , zr = 7
  , ka = 8
  , Or = 9
  , kc = 10
  , Xr = "_"
  , zg = "";
function eo(e) {
    switch (e) {
    case to:
        return "No session";
    case Ns:
        return "WS Streaming";
    case jn:
        return "prepare WS Streaming";
    case jo:
        return "WS Polling";
    case $o:
        return "prepare WS Polling";
    case ro:
        return "HTTP Streaming";
    case zr:
        return "prepare HTTP Streaming";
    case ka:
        return "HTTP Polling";
    case Or:
        return "prepare HTTP Polling";
    case kc:
        return "Shutting down"
    }
}
var Ra = {};
Ra[Ns] = zr;
Ra[ro] = Or;
Ra[jo] = jn;
Ra[ka] = jn;
Ra[Xr + Ns] = jn;
Ra[Xr + ro] = Or;
Ra[Xr + jo] = jn;
Ra[Xr + ka] = zr;
var Xo = {};
Xo[Ns] = zr;
Xo[ro] = Or;
Xo[jo] = jn;
Xo[ka] = jn;
Xo[Xr + Ns] = jn;
Xo[Xr + ro] = Or;
Xo[Xr + jo] = jn;
Xo[Xr + ka] = Or;
var Au = {};
Au[Ns] = jn;
Au[ro] = zr;
Au[jo] = $o;
Au[ka] = Or;
var a1 = {};
a1[Ns] = $o;
a1[ro] = Or;
a1[zr] = Or;
a1[Or] = Or;
var Iu = {};
Iu[jn] = !0;
Iu[$o] = !0;
Iu[zr] = !0;
Iu[Or] = !0;
var jd = !1
  , qd = !0
  , zd = !1
  , Xd = !0
  , wS = !0
  , PF = !0
  , MF = !1
  , Dt = m.getLoggerProxy(G.PROTOCOL)
  , kn = m.getLoggerProxy(G.SESSION)
  , kF = 1
  , T3 = function(e, t, n) {
    this.objectId = kF++,
    kn.isDebugLogEnabled() && kn.logDebug(m.resolve(785), this.objectId),
    this.status = to,
    this.statusPhase = 0,
    this.session = null,
    this.clientIP = null,
    this.frozen = zg,
    this.owner = e,
    this.pushPagesHandler = t,
    this.policyBean = e._policy,
    this.connectionBean = e._connection,
    this.engineId = e.getEngineId(),
    this.slowing = new QS(this.policyBean,this.engineId),
    this.pEvents = new k3(this.engineId,t),
    Bt.addUnloadHandler(this),
    this.exportForceReload(),
    this.disableXSXHRTime = null,
    this.controlHandler = new ZS(this,e._policy,this.engineId,!1),
    this.sendMessageHandler = new nx(this.controlHandler,this.pushPagesHandler,this.policyBean),
    this.mpnManager = n,
    this.nBindAfterCreate = 0
};
T3.prototype = {
    exportForceReload: function() {
        var e = this;
        Ut.exportGlobal(this.engineId, "LS_forceReload", function() {
            e.session && e.session.onErrorEvent("server.exit", {
                closedOnServer: !0
            })
        })
    },
    changeStatus: function(e) {
        kn.isDebugLogEnabled() && kn.logDebug(m.resolve(786), eo(this.status), "->", eo(e)),
        this.status = e,
        this.statusPhase++
    },
    closeSession: function(e, t, n) {
        this.status == to || this.status == kc || this.session && this.session.closeSession(e ? "api" : t, !1, n)
    },
    disconnectAndReconnect: function() {
        this.status == to || this.status == kc || this.session && this.session.disconnectAndReconnect()
    },
    syncErrorOnControl: function() {
        this.status == to || this.status == kc || this.session && this.session.onSyncError("control.syncerror")
    },
    isAlive: function() {
        return this.status != to && this.status != kc
    },
    changeTransport: function(e, t, n, i, r) {
        if (this.session != null && this.session.isActive())
            this.createOrSwitchSession(e, t, n, i, r);
        else {
            var s = i ? r ? Or : $o : r ? zr : jn;
            this.status = s,
            this.session.switchRequired = !0
        }
    },
    retry: function(e, t, n, i) {
        if (e == this.statusPhase) {
            var r = this.status === Ns || this.status === ro ? jd : qd
              , s = this.status === Ns || this.status === jo ? zd : Xd;
            this.createSession(!1, this.frozen, n, r, s, t, i)
        }
    },
    createOrSwitchSession: function(e, t, n, i, r, s, o) {
        !o && this.isAlive() ? this.switchSession(e, t, n, i, r, s) : this.createSession(e, t, n, i, r, s, !1)
    },
    switchSession: function(e, t, n, i, r, s) {
        e && Rs.init(),
        this.disableCorsCheck();
        var o = e ? "api" : s;
        this.frozen = t ? Xr : zg;
        var a = i ? r ? Or : $o : r ? zr : jn;
        this.changeStatus(a),
        this.startSwitchTimeout(o),
        this.session.requestSwitch(this.statusPhase, o, n)
    },
    createSession: function(e, t, n, i, r, s, o) {
        e && Rs.init(),
        this.disableCorsCheck();
        var a = e ? "api" : s;
        this.frozen = t ? Xr : zg,
        this.resetControlHandlers();
        var c = this.session ? this.session.getSessionId() : null;
        a = "new." + a,
        this.closeSession(!1, a, MF);
        var l = i ? r ? ka : jo : r ? ro : Ns;
        this.changeStatus(l),
        this.session != null && this.session.shutdown(!1),
        this.prepareNewSessionInstance(i, n, r),
        this.session.createSession(c, a, o)
    },
    prepareNewSessionInstance: function(e, t, n, i, r) {
        var s = this.disableXSXHRTime !== null
          , o = n ? no : or;
        r && (s = !1),
        this.session = new o(e,t,this,this.statusPhase,i,s,r,this.mpnManager),
        i && i.shutdown(),
        this.slowing.changeSession(this.session),
        this.evalQueue && this.evalQueue.changeSession(this.session),
        this.pEvents.changeSession(this.session)
    },
    bindSession: function(e, t, n, i) {
        var r = t ? n ? ka : jo : n ? ro : Ns;
        this.changeStatus(r),
        this.prepareNewSessionInstance(t, e, n, this.session),
        this.session.bindSession(i)
    },
    recoverSession: function(e, t, n) {
        if (kn.logDebug(m.resolve(787), t),
        e != this.statusPhase) {
            kn.logDebug(m.resolve(788));
            return
        }
        var i = Au[this.status] || this.status
          , r = i == jn || i == zr ? jd : qd
          , s = i == jn || i == $o ? zd : Xd
          , o = r ? s ? ka : jo : s ? ro : Ns;
        this.changeStatus(o),
        this.prepareNewSessionInstance(r, n, s, this.session, !0),
        this.session.recoverSession()
    },
    shouldGiveUpTrying: function() {
        return this.frozen == Xr && Au[this.status] == Xo[this.frozen + this.status]
    },
    onSessionGivesUp: function(e, t, n) {
        if (e == this.statusPhase) {
            if (n) {
                kn.logInfo(m.resolve(789)),
                this.changeStatus(to);
                return
            }
            var i = Xo[this.status] || this.status;
            if (i == zr && vi.isProbablyEdge() && (i = Or),
            kn.logInfo(m.resolve(790), eo(this.status), eo(i)),
            i == to || i == kc) {
                ut.fail(),
                kn.logError(m.resolve(791));
                return
            }
            this.changeStatus(i),
            this.startSwitchTimeout(t),
            this.session.requestSwitch(this.statusPhase, t, !1)
        }
    },
    onSlowRequired: function(e) {
        if (e == this.statusPhase) {
            var t = a1[this.status];
            if (kn.logInfo(m.resolve(792), eo(this.status), eo(t)),
            !t) {
                ut.fail(),
                kn.logError(m.resolve(793), eo(this.status), this.session);
                return
            }
            this.changeStatus(t),
            this.startSwitchTimeout("slow"),
            this.session.requestSlow(this.statusPhase)
        }
    },
    createMachine: function(e, t, n) {
        if (e == this.statusPhase) {
            var i = Ra[this.frozen + this.status] || this.status;
            if (kn.logInfo(m.resolve(794), eo(this.status), eo(i)),
            i == to || i == kc) {
                ut.fail(),
                kn.logError(m.resolve(795));
                return
            }
            var r = i == jn || i == zr ? jd : qd
              , s = i == jn || i == $o ? zd : Xd;
            this.createOrSwitchSession(!1, this.frozen == Xr, n, r, s, t, wS)
        }
    },
    switchMachine: function(e, t, n) {
        if (e == this.statusPhase) {
            var i = this.status;
            if (kn.logInfo(m.resolve(796), eo(this.status)),
            !Iu[i]) {
                ut.fail(),
                kn.logError(m.resolve(797));
                return
            }
            var r = i == jn || i == zr ? jd : qd
              , s = i == jn || i == $o ? zd : Xd;
            this.bindSession(n, r, s, t)
        }
    },
    slowMachine: function(e) {
        kn.logInfo(m.resolve(798)),
        this.switchMachine(e, "slow", !1)
    },
    switchTimeout: function(e, t) {
        if (e == this.statusPhase) {
            var n = this.status;
            if (kn.logInfo(m.resolve(799), eo(this.status)),
            !Iu[n]) {
                ut.fail(),
                kn.logError(m.resolve(800));
                return
            }
            t = "switch.timeout." + t;
            var i = n == jn || n == zr ? jd : qd
              , r = n == jn || n == $o ? zd : Xd;
            this.createOrSwitchSession(!1, this.frozen == Xr, !1, i, r, t, wS)
        }
    },
    startSwitchTimeout: function(e) {
        var t = this.policyBean.switchCheckTimeout + (this.slowing.getDelay() || 0);
        Se.addTimedTask(this.switchTimeout, t, this, [this.statusPhase, e])
    },
    resetControlHandlers: function() {
        this.controlHandler._reset(),
        this.sendMessageHandler._close()
    },
    connectionsEnableFlagsChanged: function() {
        var e = this.disableXSXHRTime !== null;
        this.session && this.session.resetConnectionList(e),
        this.controlHandler && this.controlHandler.resetConnectionList(e)
    },
    onCorsError: function(e) {
        e == this.statusPhase && this.connectionsEnableFlagsChanged()
    },
    disableCorsCheck: function() {
        if (this.disableXSXHRTime !== null) {
            var e = Et.getTimeStamp() - this.disableXSXHRTime;
            e > 1e3 && (this.disableXSXHRTime = null,
            this.connectionsEnableFlagsChanged())
        }
    },
    isSessionOpen: function() {
        return this.session ? this.session.isOpen() : null
    },
    isSessionOpenOrRecovering: function() {
        return this.session ? this.session.isOpen() || this.session.isRecovering() : null
    },
    getHighLevelStatus: function() {
        return this.session ? this.session.getHighLevelStatus() : G.DISCONNECTED
    },
    getSessionHost: function() {
        return this.session ? this.session.getSessionHost() : null
    },
    getPushServerAddress: function() {
        return this.session ? this.session.getPushServerAddress() : this.connectionBean.serverAddress
    },
    getSessionId: function() {
        return this.session ? this.session.getSessionId() : null
    },
    getPolicyBean: function() {
        return this.policyBean
    },
    getConnectionBean: function() {
        return this.connectionBean
    },
    getSlowing: function() {
        return this.slowing
    },
    getEvalQueue: function() {
        return (!this.evalQueue || !this.evalQueue.stillValid()) && (this.evalQueue = new sx(this.engineId),
        this.evalQueue.changeSession(this.session)),
        this.evalQueue
    },
    dispose: function() {
        this.evalQueue && this.evalQueue.dispose(),
        Bt.removeUnloadHandler(this)
    },
    unloadEvent: function() {
        this.closeSession(!1, "unload", PF),
        this.changeStatus(kc)
    },
    getControlConnectionHandler: function() {
        return this.controlHandler
    },
    getEngineId: function() {
        return this.engineId
    },
    statusChanged: function(e) {
        e == this.statusPhase && this.owner.notifyLSStatus()
    },
    onSessionStart: function(e) {
        kn.logInfo(m.resolve(801), this.session),
        this.onChangeRequestLimitLength(e),
        this.sendMessageHandler.activate(),
        this.owner.onSessionStart(),
        this.handleReverseHeartbeat(!1),
        this.nBindAfterCreate = 0
    },
    onChangeRequestLimitLength: function(e) {
        e && this.controlHandler.setRequestLimit(e)
    },
    onSessionBound: function() {
        this.nBindAfterCreate == 0 && this.mpnManager.eventManager.onSessionStart(),
        this.nBindAfterCreate++
    },
    onSessionClose: function(e, t) {
        return e != this.statusPhase ? null : (kn.logDebug(m.resolve(802), this.session),
        this.resetControlHandlers(),
        this.owner.onSessionEnd(),
        t ? this.changeStatus(to) : this.changeStatus(this.status),
        this.mpnManager.eventManager.onSessionClose(!t),
        this.statusPhase)
    },
    onUpdateReceived: function(e, t) {
        this.pushPagesHandler.onSubscriptionEvent(e[0]);
        var n = this.pushPagesHandler.getPushPageHandlerFromTableNumber(e[0]);
        if (!n) {
            Dt.logDebug(m.resolve(803), this);
            return
        }
        Dt.isDebugLogEnabled() && Dt.logDebug(m.resolve(804), e),
        n.onUpdate(e, t)
    },
    onLostUpdatesEvent: function(e) {
        this.pushPagesHandler.onSubscriptionEvent(e[0]);
        var t = this.pushPagesHandler.getPushPageHandlerFromTableNumber(e[0]);
        if (!t) {
            Dt.logDebug(m.resolve(805), this);
            return
        }
        Dt.isDebugLogEnabled() && Dt.logDebug(m.resolve(806), e),
        t.onLostUpdates(e[0], e[1], e[2])
    },
    onEndOfSnapshotEvent: function(e) {
        this.pushPagesHandler.onSubscriptionEvent(e[0]);
        var t = this.pushPagesHandler.getPushPageHandlerFromTableNumber(e[0]);
        if (!t) {
            Dt.logDebug(m.resolve(807), this);
            return
        }
        Dt.isDebugLogEnabled() && Dt.logDebug(m.resolve(808), e),
        t.onEndOfSnapshot(e[0], e[1])
    },
    onClearSnapshotEvent: function(e) {
        this.pushPagesHandler.onSubscriptionEvent(e[0]);
        var t = this.pushPagesHandler.getPushPageHandlerFromTableNumber(e[0]);
        if (!t) {
            Dt.logDebug(m.resolve(809), this);
            return
        }
        Dt.isDebugLogEnabled() && Dt.logDebug(m.resolve(810), e),
        t.onClearSnapshot(e[0], e[1])
    },
    onServerError: function(e, t) {
        Dt.isDebugLogEnabled() && Dt.logDebug(m.resolve(811), e, t),
        this.changeStatus(to),
        this.pushPagesHandler.notifyServerError(e, t)
    },
    onTableError: function(e, t, n) {
        var i = this.pushPagesHandler.getPushPageHandlerFromTableNumber(e);
        i ? (Dt.isDebugLogEnabled() && Dt.logDebug(m.resolve(812), e, t, n),
        i.onSubscriptionError(e, t, n)) : Dt.logDebug(m.resolve(813), this),
        this.pushPagesHandler.onSubscriptionError(e)
    },
    onUnsubscription: function(e) {
        var t = this.pushPagesHandler.getPushPageHandlerFromTableNumber(e);
        t ? (Dt.isDebugLogEnabled() && Dt.logDebug(m.resolve(814), e),
        t.onUnsubscription(e)) : Dt.logDebug(m.resolve(815), this),
        this.pushPagesHandler.onUnsubscription(e)
    },
    onSubscriptionReconf: function(e, t, n) {
        Dt.isDebugLogEnabled() && Dt.logDebug(m.resolve(816), e, t, n),
        this.pushPagesHandler.onSubscriptionReconfEvent(e, t);
        var i = this.pushPagesHandler.getPushPageHandlerFromTableNumber(e);
        i != null ? i.onSubscriptionReconf(e, n) : Dt.logWarn(m.resolve(817), e)
    },
    onSubscription: function(e, t, n, i, r) {
        this.pushPagesHandler.onSubscription(e);
        var s = this.pushPagesHandler.getPushPageHandlerFromTableNumber(e);
        if (!s) {
            Dt.logDebug(m.resolve(818), this);
            return
        }
        Dt.isDebugLogEnabled() && Dt.logDebug(m.resolve(819), e, t, n, i, r),
        s.onSubscription(e, i, r, t, n)
    },
    onMessageAck: function(e, t) {
        Dt.isDebugLogEnabled() && Dt.logDebug(m.resolve(820), e, t),
        this.sendMessageHandler.ack(e, t)
    },
    onMessageOk: function(e, t) {
        Dt.isDebugLogEnabled() && Dt.logDebug(m.resolve(821), e, t),
        this.sendMessageHandler._complete(e, t)
    },
    onMessageDeny: function(e, t, n, i) {
        Dt.isDebugLogEnabled() && Dt.logDebug(m.resolve(822), e, i, t, n),
        this.sendMessageHandler.notifyDenied(e, t, i, n)
    },
    onMessageDiscarded: function(e, t) {
        Dt.isDebugLogEnabled() && Dt.logDebug(m.resolve(823), e, t),
        this.sendMessageHandler.notifyDiscarded(e, t)
    },
    onMessageError: function(e, t, n, i) {
        Dt.isDebugLogEnabled() && Dt.logDebug(m.resolve(824), e, i, t, n),
        this.sendMessageHandler.notifyError(e, t, i, n)
    },
    onObsoleteControlLink: function(e) {
        this.owner.onObsoleteControlLink(e)
    },
    onNewControlLink: function(e) {
        Dt.isDebugLogEnabled() && Dt.logDebug(m.resolve(825), e),
        this.owner.onNewControlLink(e)
    },
    onIPReceived: function(e) {
        this.clientIP && e != this.clientIP && qn.isDisabledClass() && (qn.restoreClass(),
        this.createOrSwitchSession(!1, this.frozen == Xr, !1, !1, !1, "ip", !1)),
        this.clientIP = e
    },
    onServerKeepalive: function() {
        this.owner.onServerKeepalive()
    },
    sendAMessage: function(e, t, n, i) {
        this.sendMessageHandler._send(e, t, n, i)
    },
    sendLog: function(e, t) {
        var n = io.getLogRequestParams(this.statusPhase, e, t);
        this.controlHandler.addRequest(null, n, je.LOG, null)
    },
    changeBandwidth: function(e) {
        this.session && this.session.changeBandwidth()
    },
    sendSubscription: function(e, t, n, i, r) {
        var s = {
            onREQOK: function(o) {},
            onREQERR: function(o, a, c, l) {
                o.LS_l(c, a, e, l)
            }
        };
        this.controlHandler.addRequest(e, t, je.ADD, r, i, s)
    },
    sendUnsubscription: function(e, t, n, i, r) {
        var s = {
            onREQOK: function(o) {},
            onREQERR: function(o, a, c, l) {
                c != 19 && r.discard(),
                kn.logError(m.resolve(826) + CS(t) + " caused the error: ", c, l)
            }
        };
        this.controlHandler.addRequest(e, t, je.REMOVE, r, i, s)
    },
    sendSubscriptionChange: function(e, t, n) {
        var i = {
            onREQOK: function(r) {},
            onREQERR: function(r, s, o, a) {
                n.discard(),
                kn.logError(m.resolve(827) + CS(t) + "] caused the error: " + o + " " + a)
            }
        };
        this.controlHandler.addRequest(e, t, je.CHANGE_SUB, n, null, i)
    },
    handleReverseHeartbeat: function(e) {
        this.session && this.session.handleReverseHeartbeat(e)
    },
    enqueueControlResponse: function(e) {
        var t = this.session == null ? null : this.session.push_phase;
        this.getEvalQueue()._enqueue(t, e)
    },
    sendRegisterForMpn: function(e, t) {
        var n = this
          , i = {
            onREQOK: function(o) {
                t.onResponse()
            },
            onREQERR: function(o, a, c, l) {
                t.onResponse(),
                n.session != null && n.session.onMpnRegisterError(c, l)
            }
        }
          , r = e.reqId
          , s = null;
        this.controlHandler.addRequest(r, e.query, je.MPN, t, s, i)
    },
    sendMpnSubscription: function(e, t) {
        var n = this
          , i = {
            onREQOK: function(o) {
                t.onResponse()
            },
            onREQERR: function(o, a, c, l) {
                t.onResponse(),
                n.session != null && n.session.onMpnSubscribeError(e.subscriptionId, c, l)
            }
        }
          , r = e.reqId
          , s = null;
        this.controlHandler.addRequest(r, e.query, je.MPN, t, s, i)
    },
    sendMpnUnsubscription: function(e, t) {
        var n = this
          , i = {
            onREQOK: function(o) {
                t.onResponse()
            },
            onREQERR: function(o, a, c, l) {
                t.onResponse(),
                n.session != null && n.session.onMpnUnsubscribeError(e.subscriptionId, c, l)
            }
        }
          , r = e.reqId
          , s = null;
        this.controlHandler.addRequest(r, e.query, je.MPN, t, s, i)
    },
    sendMpnFilteredUnsubscription: function(e, t) {
        var n = {
            onREQOK: function(s) {
                t.onResponse()
            },
            onREQERR: function(s, o, a, c) {
                t.onResponse()
            }
        }
          , i = e.reqId
          , r = null;
        this.controlHandler.addRequest(i, e.query, je.MPN, t, r, n)
    },
    onFatalError: function(e) {
        kn.logError(m.resolve(828), e.stack || e),
        this.session && this.session.onFatalError(61, "Internal error: " + e)
    }
};
function CS(e) {
    var t = "{";
    for (var n in e)
        t += n + "=" + e[n] + " ";
    return t += "}",
    t
}
T3.prototype.unloadEvent = T3.prototype.unloadEvent;
var Wn = Mi.simple
  , AF = Mi.simpleWithResponseAndTimeout
  , Xg = {
    onEngineConfigurationChange: Wn,
    onEngineDeath: Wn,
    onStatusChange: Wn,
    onSessionStart: Wn,
    onSessionEnd: Wn,
    onEngineDying: Wn,
    onServerError: Wn,
    onServerKeepalive: Wn,
    ping: AF,
    onSubscription: Wn,
    onUnsubscription: Wn,
    onEndOfSnapshot: Wn,
    onUpdate: Wn,
    onLostUpdates: Wn,
    onClearSnapshot: Wn,
    onSubscriptionError: Wn,
    onMessageDiscarded: Wn,
    onMessageDenied: Wn,
    onMessageError: Wn,
    onMessageComplete: Wn,
    onMessageOnNetwork: Wn,
    onSubscriptionReconf: Wn
};
function Du(e, t) {
    this.engine = e,
    this.id = t
}
Du.methods = Xg;
Du.prototype = {
    setEngineHandler: function(e) {
        this.target = e
    },
    onClientConfigurationChange: function(e, t, n) {
        var i = e == "ConnectionDetails" ? this.engine._connection : e == "ConnectionOptions" ? this.engine._policy : this.engine._configuration;
        i.simpleSetter(t, n)
    },
    callConnect: function(e) {
        e == this.engine.getSessionPhase() && this.engine.doConnect()
    },
    callDisconnect: function(e) {
        e == this.engine.getSessionPhase() && this.engine.doDisconnect()
    },
    callDisconnectAndReconnect: function(e) {
        e == this.engine.getSessionPhase() && this.engine.doDisconnectAndReconnect()
    },
    pong: function() {
        if (this.engine === null)
            throw "net";
        return !0
    },
    clientDeath: function() {
        Se.addTimedTask(this.engine.checkClientHealth, 0, this.engine),
        Se.addTimedTask(this.engine.checkClientHealth, 1e3, this.engine)
    },
    subscribeTable: function(e, t) {
        return e != this.engine.getSessionPhase() ? null : this.engine.subscribe(this.id, t)
    },
    unsubscribeTable: function(e, t) {
        return e != this.engine.getSessionPhase() ? null : this.engine.unsubscribe(t)
    },
    updateSubscriptionParams: function(e, t, n) {
        return e != this.engine.getSessionPhase() ? null : this.engine.updateSubscriptionParams(t, n)
    },
    forwardMessage: function(e, t, n, i, r) {
        if (e != this.engine.getSessionPhase())
            return null;
        var s = i == null ? null : {
            prog: i,
            pageNum: this.id
        };
        this.engine.sendAMessage(t, n, s, r)
    },
    forwardLog: function(e) {
        this.engine.sendLog(e)
    },
    dispose: function() {
        this.engine = null
    }
};
for (p3 in Xg)
    Du.prototype[p3] = VS.createCaller(p3, Xg[p3]);
var p3, ox = Et.randomG(), Kg = G.BUILD;
isNaN(Kg) && (Kg = 0);
var Ng = m.getLoggerProxy(G.SESSION)
  , ax = function(e, t, n, i, r, s, o) {
    if (this._configuration = new o1(e),
    this._configuration.setBroadcaster(this, !0),
    this._connection = new ln(n),
    this._connection.setBroadcaster(this, !0),
    this._policy = new ae(t),
    this._policy.setBroadcaster(this, !0),
    this.lastStatus = null,
    this.pushPages = new qo(this,this._configuration,this._connection,this._policy),
    i && i.isPossible()) {
        this.sharedStatus = i.createSharedStatus(this, Se.packTask(this.dispose, this), s);
        var a = this.sharedStatus.getBridge();
        a != null && (this.channels = i.createChannelsManager(this, a),
        this.channels.addListener(this.pushPages)),
        this.id = this.sharedStatus.getId()
    } else {
        this.sharedStatus = null;
        do
            this.id = "NS" + ox++;
        while (Ut.hasGlobal(this.id, "lsEngine"))
    }
    Ut.exportGlobal(this.id, "lsEngine", this),
    this.sessionHandler = new T3(this,this.pushPages,o),
    this.bindLocalClient(r, G.MAIN_CLIENT),
    this._configuration.connectionRequested && this.doConnect()
};
ax.prototype = {
    toString: function() {
        return "[LightstreamerEngine " + this.id + "]"
    },
    bindLocalClient: function(e, t) {
        t || (t = "LOCAL" + ox++);
        var n = new Du(this,t);
        n.setEngineHandler(e),
        e.setPushPageHandler(n),
        this.pushPages.onNewPushPage(t, n)
    },
    getEngineId: function() {
        return this.id
    },
    isSessionOpen: function() {
        return this.sessionHandler.isSessionOpen()
    },
    isSessionOpenOrRecovering: function() {
        return this.sessionHandler.isSessionOpenOrRecovering()
    },
    getSharedStatus: function() {
        return this.sharedStatus
    },
    getSessionPhase: function() {
        return this.pushPages.getSessionPhase()
    },
    onSessionEnd: function() {
        this.pushPages.onSessionEnd()
    },
    onSessionStart: function() {
        this.pushPages.onSessionStart()
    },
    dispose: function() {
        this.sessionHandler.closeSession(!1, "suicide", !0),
        this.sessionHandler.dispose(),
        Ut.cleanAllGlobals(this.id),
        this.sharedStatus && this.sharedStatus.dispose(),
        this.pushPages.notifyEngineDeath(!0),
        this.pushPages.dispose(),
        this.channels && this.channels.dispose()
    },
    doDisconnect: function() {
        Ng.logInfo(m.resolve(829)),
        this._configuration.simpleSetter("connectionRequested", !1),
        this.sessionHandler.closeSession(!0, "api", !0)
    },
    doDisconnectAndReconnect: function() {
        this._configuration.simpleSetter("connectionRequested", !1),
        this.sessionHandler.disconnectAndReconnect()
    },
    doChangeTransport: function() {
        var e = this._policy.forcedTransport;
        if (Ng.logInfo(m.resolve(830), e),
        e === null) {
            var t = !0
              , n = !1
              , i = !1
              , r = !1
              , s = !1;
            this.sessionHandler.changeTransport(t, n, i, r, s)
        } else {
            var t = !0
              , n = e == G.WS_ALL || e == G.HTTP_ALL
              , i = !n
              , r = e == G.WS_POLLING || e == G.HTTP_POLLING
              , s = e == G.HTTP_POLLING || e == G.HTTP_STREAMING || e == G.HTTP_ALL;
            this.sessionHandler.changeTransport(t, n, i, r, s)
        }
    },
    doConnect: function() {
        Ng.logInfo(m.resolve(831)),
        this._configuration.simpleSetter("connectionRequested", !0);
        var e = this._policy.forcedTransport;
        e === null ? this.sessionHandler.createOrSwitchSession(!0, !1, !1, !1, !1) : this.doConnectForced(e)
    },
    doConnectForced: function(e) {
        var t = e == G.WS_POLLING || e == G.HTTP_POLLING
          , n = e == G.HTTP_POLLING || e == G.HTTP_STREAMING || e == G.HTTP_ALL
          , i = e == G.WS_ALL || e == G.HTTP_ALL
          , r = !i;
        this.sessionHandler.createOrSwitchSession(!0, i, r, t, n)
    },
    broadcastSetting: function(e, t, n) {
        return this.pushPages.forEachPushPage(function(i) {
            i.onEngineConfigurationChange(e, t, n)
        }),
        t == "requestedMaxBandwidth" ? this.sessionHandler.changeBandwidth(n) : t == "forcedTransport" ? this._configuration.connectionRequested && this.doChangeTransport() : t == "reverseHeartbeatInterval" ? this.sessionHandler.handleReverseHeartbeat(!1) : (t == "corsXHREnabled" || t == "xDomainStreamingEnabled") && this.sessionHandler.connectionsEnableFlagsChanged(),
        !0
    },
    onObsoleteControlLink: function(e) {
        this.sharedStatus && this.sharedStatus.removeConnectionToServerFlag(e)
    },
    onNewControlLink: function(e) {
        this.sharedStatus && this.sharedStatus.addConnectionToServerFlag(e)
    },
    getStatus: function() {
        return this.sessionHandler.getHighLevelStatus()
    },
    notifyLSStatus: function() {
        var e = this.getStatus();
        if (this.lastStatus != e) {
            var t = this.lastStatus;
            this.lastStatus = e,
            this.pushPages.notifyNewStatus(e, t),
            this.onStatusChange && this.onStatusChange(e)
        }
    },
    sendAMessage: function(e, t, n, i) {
        var r = this.getStatus();
        return r == G.DISCONNECTED || r == G.WILL_RETRY ? !1 : (this.sessionHandler.sendAMessage(e, t, n, i),
        !0)
    },
    sendLog: function(e) {
        return this.sessionHandler.sendLog(e, Kg),
        !0
    },
    subscribe: function(e, t) {
        return this.pushPages.handleTable(e, t)
    },
    unsubscribe: function(e) {
        this.pushPages.removeTable(e)
    },
    updateSubscriptionParams: function(e, t) {
        this.pushPages.updateSubscriptionParams(e, t)
    },
    checkClientHealth: function() {
        this.pushPages.cleanThread()
    },
    onServerKeepalive: function() {
        this.pushPages.onServerKeepalive()
    },
    sendRegisterForMpn: function(e, t) {
        this.sessionHandler.sendRegisterForMpn(e, t)
    },
    sendMpnSubscription: function(e, t) {
        this.sessionHandler.sendMpnSubscription(e, t)
    },
    sendMpnUnsubscription: function(e, t) {
        this.sessionHandler.sendMpnUnsubscription(e, t)
    },
    sendMpnFilteredUnsubscription: function(e, t) {
        this.sessionHandler.sendMpnFilteredUnsubscription(e, t)
    },
    onFatalError: function(e) {
        this.sessionHandler.onFatalError(e)
    }
};
var Uo = "|";
function cx(e, t, n) {
    this.id = e,
    this.shareName = t,
    this.status = n
}
cx.prototype = {
    getStatus: function() {
        return this.status
    }
};
var n7 = {
    readSharedStatus: function(e, t) {
        return this.readComposedValue(t + "_" + e)
    },
    writeSharedStatus: function(e, t, n) {
        n = n.join(Uo);
        var i = G.STORAGE_PREFIX + t + "_" + e;
        this.write(i, n)
    },
    cleanSharedStatus: function(e, t) {
        var n = G.STORAGE_PREFIX + t + "_" + e;
        this.clean(n)
    },
    readIds: function(e) {
        return this.readComposedValue(e)
    },
    readIdsObjects: function(e) {
        var t = this.readComposedValue(e);
        if (!t)
            return null;
        for (var n = [], i = 0; i < t.length; i++) {
            var r = t[i].split("_");
            if (r.length == 2) {
                var s = this.readSharedStatus(r[1], r[0]);
                s != null && n.push(new cx(r[0],r[1],s))
            }
        }
        return n
    },
    addId: function(e, t, n) {
        e = G.STORAGE_PREFIX + e,
        t = t + (n ? "_" + n : "");
        var i = this.read(e);
        if (!i)
            i = Uo;
        else if (i.indexOf(Uo + t + Uo) > -1)
            return !1;
        return i += t + Uo,
        this.write(e, i),
        !0
    },
    removeId: function(e, t, n) {
        e = G.STORAGE_PREFIX + e,
        t = t + (n ? "_" + n : "");
        var i = this.read(e);
        if (i) {
            var r = Uo + t + Uo;
            i.indexOf(r) > -1 && (i = i.replace(r, Uo),
            i == Uo ? this.clean(e) : this.write(e, i))
        }
    },
    getAllKeys: function() {
        for (var e = this.keys(), t = [], n = 0; n < e.length; n++)
            e[n].indexOf(G.STORAGE_PREFIX) == 0 && (e[n] = e[n].substring(G.STORAGE_PREFIX.length),
            t.push(e[n]));
        return t
    },
    readComposedValue: function(e) {
        e = G.STORAGE_PREFIX + e;
        var t = this.read(e);
        if (!t)
            return null;
        var n = t.split(Uo);
        return n[0] == "" && n.shift(),
        n[n.length - 1] == "" && n.pop(),
        n.length > 0 ? n : null
    }
}
  , lx = Ke.extendObj({
    read: function(e) {
        return localStorage.getItem(e)
    },
    write: function(e, t) {
        localStorage.setItem(e, t)
    },
    clean: function(e) {
        localStorage.removeItem(e)
    },
    keys: function() {
        for (var e = [], t = 0; t < localStorage.length; t++)
            e.push(localStorage.key(t));
        return e
    }
}, n7)
  , g3 = function() {
    var e = null
      , t = {
        areCookiesEnabled: function() {
            return e === null && t.checkCookiesFunctionality(),
            e
        },
        getAllCookiesAsSingleString: function() {
            return this.areCookiesEnabled() ? document.cookie.toString() : null
        },
        writeCookie: function(n, i) {
            this.writeCookieExe(n, i, "")
        },
        writeCookieExe: function(n, i, r) {
            if (this.areCookiesEnabled()) {
                var s = ""
                  , o = encodeURIComponent(n) + "=" + i + "; "
                  , a = o + s + r + "path=/;";
                document.cookie = a
            }
        },
        readCookie: function(n) {
            if (!this.areCookiesEnabled())
                return null;
            n = encodeURIComponent(n) + "=";
            var i = this.getAllCookiesAsSingleString();
            i = i.split(";");
            for (var r = 0; r < i.length; r++)
                if (i[r] = Et.trim(i[r]),
                i[r].indexOf(n) == 0)
                    return i[r].substring(n.length, i[r].length);
            return null
        },
        removeCookie: function(n) {
            if (this.areCookiesEnabled()) {
                var i = new Date;
                i.setTime(i.getTime() - 864e5);
                var r = "expires=" + i.toUTCString() + "; ";
                this.writeCookieExe(n, "deleting", r)
            }
        },
        checkCookiesFunctionality: function() {
            if (e = !1,
            !!vt.isBrowserDocument() && !(document.location.protocol != "http:" && document.location.protocol != "https:")) {
                e = !0;
                var n = Et.randomG()
                  , i = "LS__cookie_test" + n;
                this.writeCookie(i, "testing");
                var r = this.readCookie(i);
                r == "testing" && (this.removeCookie(i),
                r = this.readCookie(i),
                r == null) || (e = !1)
            }
        }
    };
    return t.areCookiesEnabled = t.areCookiesEnabled,
    t.getAllCookiesAsSingleString = t.getAllCookiesAsSingleString,
    t.writeCookie = t.writeCookie,
    t.removeCookie = t.removeCookie,
    t.readCookie = t.readCookie,
    t
}()
  , F3 = Ke.extendObj({
    read: function(e) {
        return g3.readCookie(e)
    },
    write: function(e, t) {
        g3.writeCookie(e, t)
    },
    clean: function(e) {
        g3.removeCookie(e)
    },
    keys: function() {
        var e = []
          , t = g3.getAllCookiesAsSingleString();
        e = t.split(";");
        for (var n = 0; n < e.length; n++)
            e[n] = Et.trim(e[n]),
            e[n] = e[n].substring(0, e[n].indexOf("=")),
            e[n] = decodeURIComponent(e[n]);
        return e
    }
}, n7)
  , Wo = []
  , IF = G.REFRESH_STATUS_INTERVAL + G.REFRESH_STATUS_INTERVAL_TOLERANCE
  , ux = 6e4
  , c1 = function(e) {
    this._callSuperConstructor(c1),
    this.manager = e,
    this.task = null
};
c1.prototype = {
    start: function() {
        this.task && Se.stopRepetitiveTask(this.task),
        this.task = Se.addRepetitiveTask(this.collect, ux, this),
        Se.addTimedTask(this.collect, 0, this)
    },
    clean: function() {
        Se.stopRepetitiveTask(this.task);
        for (var e = 0; e < Wo.length; e++)
            if (Wo[e] == this) {
                Wo.splice(e, 1);
                return
            }
    },
    collect: function() {
        for (var e = Et.getTimeStamp(), t = this.manager.getAllKeys(), n = 0; n < t.length; n++)
            t[n].indexOf("_") > 0 && this.checkEngine(t[n], null, e);
        for (var n = 0; n < t.length; n++)
            t[n].indexOf("_") <= -1 && this.checkList(t[n])
    },
    checkEngine: function(e, t, n) {
        if (!t) {
            var i = e.split("_");
            if (i.length != 2)
                return !1;
            e = i[0],
            t = i[1]
        }
        var r = this.manager.readSharedStatus(t, e);
        if (!r)
            return !1;
        if (!n)
            return !0;
        var s = n - r[G.TIMESTAMP_INDEX];
        return s > IF ? (this.manager.cleanSharedStatus(t, e),
        !1) : !0
    },
    checkList: function(e) {
        for (var t = this.manager.readIds(e), n = 0; n < t.length; n++)
            t[n].indexOf("_") > 0 ? this.checkEngine(t[n]) || this.manager.removeId(e, t[n]) : this.checkEngine(t[n], e) || this.manager.removeId(e, t[n])
    }
};
ot(c1, KS, !1, !0);
var RF = new c1(lx)
  , Yg = new c1(F3)
  , ES = Ke.canUseLocalStorage() ? RF : Yg
  , Fg = {
    start: function(e) {
        for (var t = e ? Yg : ES, n = 0; n < Wo.length; n++)
            if (Wo[n] == t) {
                t.touch();
                return
            }
        Wo.push(t),
        t.touch(),
        t.start()
    },
    stop: function(e) {
        for (var t = e ? Yg : ES, n = 0; n < Wo.length; n++)
            Wo[n] == t && t.dismiss()
    },
    changeInterval: function(e) {
        ux = e;
        for (var t = 0; t < Wo.length; t++)
            Wo[t].start()
    }
}
  , m3 = {}
  , DF = Ke.extendObj({
    read: function(e) {
        return m3[e]
    },
    write: function(e, t) {
        m3[e] = t
    },
    clean: function(e) {
        delete m3[e]
    },
    keys: function() {
        var e = [];
        for (var t in m3)
            e.push(t);
        return e
    }
}, n7)
  , x3 = {
    canGenerate: function() {
        return vt.isBrowserDocument() && typeof SharedWorker < "u" && typeof Blob < "u" && window.URL
    },
    createWorker: function(e) {
        var t = new Blob([e])
          , n = window.URL.createObjectURL(t);
        return n
    },
    removeWorker: function(e) {
        window.URL.revokeObjectURL(e)
    }
}
  , NF = G.MASTER
  , FF = "REMOTE"
  , LF = "INITIALIZATION"
  , BF = "REMOVE"
  , UF = "FAILED"
  , HF = "KILL"
  , Ll = m.getLoggerProxy(G.SHARING);
function Wl() {
    this._callSuperConstructor(Wl),
    this.worker = null,
    this.senderId = null
}
Wl.WORKER_CODE = 'var listeners={},nextId=0,MASTER="MASTER",REMOTE="REMOTE",INITIALIZATION="INITIALIZATION",REMOVE="REMOVE",ALL="ALL",FAILED="FAILED",KILL="KILL";onconnect=function(a){var b=a.ports[0];a=nextId++;listeners[MASTER]||(a=MASTER);listeners[a]=b;b.addEventListener("message",function(a){a=a.data;if(a.type==REMOVE)delete listeners[a.target];else if(a.type==KILL)terminate();else if(a.target===ALL)for(var c in listeners)listeners[c]!=b&&sendMessage(c,a,b);else sendMessage(a.target,a,b)});b.start();b.postMessage({type:INITIALIZATION,id:a});a!==MASTER&&listeners[MASTER].postMessage({type:REMOTE,id:a})};function sendMessage(a,b,d){(a=listeners[a])?a.postMessage(b):(b.type=FAILED,d.postMessage(b))}function terminate(){self.close();for(var a in listeners)listeners[a].close()};';
Wl.prototype = {
    isReady: function() {
        return this.senderId !== null
    },
    getBridgeId: function() {
        return this.senderId
    },
    start: function(e) {
        var t = new SharedWorker(e)
          , n = new Promise(function(r, s) {
            t.onerror = function() {
                Ll.logInfo(m.resolve(833)),
                s("SharedWorker broken")
            }
        }
        );
        this.worker = t.port;
        var i = this;
        return this.worker.onmessage = function(r) {
            i.onMessageReceived(r.data)
        }
        ,
        this.worker.start(),
        n
    },
    dispose: function() {
        try {
            this.senderId == NF && this.worker.postMessage({
                type: HF
            }),
            this.worker.close()
        } catch {}
        this.worker = null
    },
    onMessageReceived: function(e) {
        try {
            if (Ll.isDebugLogEnabled()) {
                var t = "RECEIVED";
                for (var n in e)
                    t += " " + n.toString() + ":" + e[n];
                Ll.logDebug(t)
            }
            e.type == LF ? (this.senderId = e.id,
            this.dispatchEvent("onReady")) : e.type == FF ? this.dispatchEvent("onRemote", [e.id]) : e.type == UF ? this.dispatchEvent("onMessageFail", [e.target, e.messageId]) : this.dispatchEvent("onMessage", [e])
        } catch (i) {
            Ll.logError(m.resolve(836), i)
        }
    },
    removeTarget: function(e) {
        e || (e = this.senderId);
        try {
            this.worker.postMessage({
                type: BF,
                target: e
            })
        } catch {}
    },
    sendMessage: function(e, t, n, i) {
        if (!this.isReady())
            return !1;
        var r = this.senderId
          , s = {
            type: t,
            sender: r,
            target: e,
            messageId: n,
            params: i
        };
        if (Ll.isDebugLogEnabled()) {
            var o = "SENDING";
            for (var a in s)
                o += " " + a.toString() + ":" + s[a];
            Ll.logDebug(o)
        }
        try {
            this.worker.postMessage(s)
        } catch (c) {
            Ll.logError(m.resolve(837), c),
            this.dispatchEvent("onMessageFail", [e, n])
        }
        return !0
    }
};
ot(Wl, Ru);
var Lg = m.getLoggerProxy(G.SHARING)
  , TS = "INITIALIZATION"
  , OS = G.MASTER;
function l1() {
    this._callSuperConstructor(l1),
    this.connections = {},
    this.senderId = null,
    this.othersIds = 1
}
l1.prototype = {
    isReady: function() {
        return this.senderId !== null
    },
    start: function(e) {
        if (this.ready = !0,
        e) {
            this.connections[OS] = e;
            var t = this;
            Se.addTimedTask(function() {
                try {
                    e.connect(t)
                } catch (n) {
                    n.number == -2147467260 || Lg.logError(m.resolve(838), n)
                }
            }, 0)
        } else
            this.senderId = OS,
            this.dispatchEvent("onReady")
    },
    dispose: function() {},
    connect: function(e) {
        Se.addTimedTask(this._connect, 0, this, [e])
    },
    _connect: function(e) {
        var t = this.othersIds++;
        this.connections[t] = e,
        this.dispatchEvent("onRemote", [t]),
        this.sendMessage(t, TS, -1, [t])
    },
    removeTarget: function(e) {
        delete this.connections[e]
    },
    sendMessage: function(e, t, n, i) {
        if (!this.isReady())
            return !1;
        if (e == "ALL")
            for (var r in this.connections)
                this._sendOneMessage(r, t, n, i);
        else
            this._sendOneMessage(e, t, n, i);
        return !0
    },
    _sendOneMessage: function(e, t, n, i) {
        try {
            if (!this.connections[e] || !this.connections[e].onMessageReceived)
                this.dispatchEvent("onMessageFail", [e, n]);
            else {
                var r = this;
                Se.addTimedTask(function() {
                    try {
                        r.connections[e].onMessageReceived(e, r.senderId, t, n, i)
                    } catch (s) {
                        s.number == -2147467260 || (Lg.logError(m.resolve(839), s),
                        r.dispatchEvent("onMessageFail", [e, n]))
                    }
                }, 0)
            }
        } catch {
            this.dispatchEvent("onMessageFail", [e, n])
        }
    },
    onMessageReceived: function(e, t, n, i, r) {
        var s = {
            target: Ke.copyByValue(e),
            type: Ke.copyByValue(n),
            messageId: Ke.copyByValue(i),
            sender: Ke.copyByValue(t)
        };
        if (r) {
            s.params = [];
            for (var o = 0; o < r.length; o++)
                s.params[o] = Ke.copyByValue(r[o])
        }
        this._onMessageReceived(s)
    },
    _onMessageReceived: function(e) {
        try {
            e.type == TS ? (this.senderId = e.params[0],
            this.dispatchEvent("onReady")) : this.dispatchEvent("onMessage", [e])
        } catch (t) {
            t.number == -2147467260 || Lg.logError(m.resolve(840), t)
        }
    }
};
ot(l1, Ru, !1, !0);
var Cr = m.getLoggerProxy(G.SHARING)
  , hx = Ke.canUseLocalStorage() ? lx : F3
  , GF = Et.randomG()
  , PS = 500
  , Ia = function(e, t) {
    this.shareName = e,
    this.engine = t,
    this.id = null,
    this.bridge = null,
    this.manager = DF
}
  , v3 = G.TIMESTAMP_INDEX;
Ia.getManager = function(e) {
    return e ? F3 : hx
}
;
Ia.prototype = {
    toString: function() {
        return ["[SharedStatus", this.id, this.shareName, "]"].join("|")
    },
    getBridge: function() {
        return this.bridge
    },
    _start: function() {
        this.running = !0,
        Bt.addBeforeUnloadHandler(this),
        Bt.addUnloadHandler(this)
    },
    setupCrossTabSharing: function(e, t, n, i) {
        return this.running ? !1 : (this.dontDieFor = t || {},
        this.lastTimestamp = null,
        this.shareFrameTimeout = PS,
        this.suicideNotification = e,
        this.currentServer = null,
        this.host = location.host,
        this.frameName = G.NULL_VALUE,
        this.blobId = G.NULL_VALUE,
        this.preClean = !1,
        this.foolOffset = 0,
        n ? (this.manager = F3,
        Fg.start(!0)) : (this.manager = hx,
        Fg.start()),
        this.forceCookies = n,
        this.startupThread = null,
        this.thread = null,
        this._initId(),
        this._setupLocalSharing(),
        this.bridge = null,
        i || !x3.canGenerate() ? this.frameName = this.generateFrame() : this.blobId = this.generateWorker(),
        this.newerEngines = {},
        Cr.logInfo(m.resolve(841)),
        this._start(),
        !0)
    },
    setupLocalSharing: function() {
        return this.running ? !1 : (this._initId(!0),
        this._setupLocalSharing(),
        Cr.logInfo(m.resolve(842)),
        this._start(),
        !0)
    },
    _setupLocalSharing: function() {
        Ut.addSharableEngine(this.shareName, this.engine)
    },
    _initId: function(e) {
        do
            this.id = GF++;
        while (Ut.hasGlobal(this.id, "lsEngine"));
        if (!e) {
            if (!this.manager.addId(this.shareName, this.id)) {
                this._initId();
                return
            }
            if (this.manager.readSharedStatus(this.shareName, this.id)) {
                this._initId();
                return
            }
        }
    },
    _startRefreshThread: function() {
        this.thread = Se.addRepetitiveTask(this.refreshStatusThread, G.REFRESH_STATUS_INTERVAL, this),
        Cr.logInfo(m.resolve(843), this)
    },
    generateFrame: function() {
        var e = this.frameName;
        return e == G.NULL_VALUE && (e = Ke.sanitizeIFrameName("LSF__" + Ke.getDomain() + "_" + this.id + "_" + this.shareName),
        this.bridge = new l1,
        Ut.exportGlobal(this.id, G.FRAME_BRIDGE_GLOBAL, this.bridge)),
        Dc.getFrameWindow(e, !0) ? (this.shareFrameTimeout = PS,
        this._startBridge()) : (this.startupThread = Se.addTimedTask(this.generateFrame, this.shareFrameTimeout, this),
        this.shareFrameTimeout *= 2),
        e
    },
    generateWorker: function() {
        var e = x3.createWorker(Wl.WORKER_CODE);
        return this.bridge = new Wl,
        this._startBridge(e),
        Ut.exportGlobal(this.id, G.WORKER_BRIDGE_GLOBAL, e),
        e
    },
    _startBridge: function(e) {
        var t = this;
        this.bridge.addListener({
            onReady: function() {
                t.refreshStatus(),
                t.startupThread = Se.addTimedTask(t._startRefreshThread, 0, t),
                t.bridge.removeListener(this)
            }
        }),
        this.bridge.start(e)
    },
    getId: function() {
        return this.id
    },
    addConnectionToServerFlag: function(e) {
        e != this.currentServer && (this.currentServer = e,
        this.manager.addId(e, this.id, this.shareName))
    },
    removeConnectionToServerFlag: function(e) {
        this.currentServer != e ? this.currentServer == null ? Cr.logWarn(m.resolve(844), e) : Cr.logError(m.resolve(845), this.currentServer, e) : this.currentServer = null,
        this.manager.removeId(e, this.id, this.shareName)
    },
    getNumberOfConnectionsToServer: function(e) {
        var t = this.manager.readIdsObjects(e);
        if (!t)
            return 0;
        for (var n = 0, i = 0; i < t.length; i++) {
            var r = Et.getTimeStamp() - t[i].getStatus()[v3];
            r > G.REFRESH_STATUS_INTERVAL || n++
        }
        return n
    },
    refreshStatus: function() {
        this.lastTimestamp = Et.getTimeStamp() + this.foolOffset;
        var e = [this.lastTimestamp, this.frameName, this.host, G.BUILD, G.PAGE_PROTOCOL, this.blobId];
        this.manager.writeSharedStatus(this.shareName, this.id, e)
    },
    refreshStatusThread: function() {
        if (this.preClean) {
            Cr.logDebug(m.resolve(846)),
            this.preClean = !1;
            return
        }
        var e = !1;
        if (this.suicideNotification) {
            Cr.logDebug(m.resolve(847), this);
            var t = this.manager.readIds(this.shareName);
            if (!t)
                Cr.logDebug(m.resolve(848), this);
            else {
                Cr.logDebug(m.resolve(849), this.shareName);
                for (var n = 0; n < t.length; n++)
                    if (t[n] != this.id) {
                        var i = this.manager.readSharedStatus(this.shareName, t[n]);
                        if (!i) {
                            Cr.logDebug(m.resolve(850), t[n]);
                            continue
                        }
                        if (i[G.BUILD_INDEX] != G.BUILD || i[G.PROTOCOL_INDEX] != G.PAGE_PROTOCOL) {
                            Cr.logDebug(m.resolve(851), t[n]);
                            continue
                        }
                        i[v3] == this.lastTimestamp && (this.foolOffset = Et.randomG(5)),
                        i[v3] > this.lastTimestamp ? e |= this.newerEngineFound(t[n], i[v3]) : this.newerEngines[t[n]] && delete this.newerEngines[t[n]]
                    }
            }
        }
        e || (Cr.logDebug(m.resolve(852)),
        this.manager.addId(this.shareName, this.id),
        this.refreshStatus())
    },
    newerEngineFound: function(e, t) {
        if (Cr.logDebug(m.resolve(853), e + " with a newer status"),
        this.newerEngines[e])
            if (this.newerEngines[e] != t && !this.dontDieFor[e])
                Cr.logInfo(m.resolve(854), this.id),
                this.executeSuicide();
            else
                return !1;
        return this.newerEngines[e] = t,
        !0
    },
    executeSuicide: function() {
        this.clean(),
        this.suicideNotification && Se.executeTask(this.suicideNotification)
    },
    lightClean: function() {
        this.manager.cleanSharedStatus(this.shareName, this.id),
        this.manager.removeId(this.shareName, this.id),
        this.preClean = !0
    },
    clean: function() {
        Cr.logInfo(m.resolve(855), this),
        Se.stopRepetitiveTask(this.thread),
        Se.stopRepetitiveTask(this.startupThread),
        this.thread = null,
        this.startupThread = null,
        this.frameName != G.NULL_VALUE ? Dc.disposeFrame(this.frameName) : this.blobId != G.NULL_VALUE && x3.removeWorker(this.blobId),
        this.frameName = G.NULL_VALUE,
        this.blobId = G.NULL_VALUE,
        this.removeConnectionToServerFlag(this.currentServer),
        this.shareName && Ut.removeSharableEngine(this.shareName, this.engine),
        this.bridge && (Ut.cleanGlobal(this.id, G.FRAME_BRIDGE_GLOBAL),
        Ut.cleanGlobal(this.id, G.WORKER_BRIDGE_GLOBAL)),
        this.bridge = null,
        this.lightClean()
    },
    unloadEvent: function() {
        this.clean()
    },
    preUnloadEvent: function() {
        this.lightClean()
    },
    dispose: function() {
        this.clean(),
        Bt.removeBeforeUnloadHandler(this),
        Bt.removeUnloadHandler(this),
        Fg.stop(this.forceCookies)
    }
};
Ia.prototype.unloadEvent = Ia.prototype.unloadEvent;
Ia.prototype.preUnloadEvent = Ia.prototype.preUnloadEvent;
var VF = 0
  , MS = "RESPONSE";
function Ko(e, t, n) {
    this.receiver = e,
    this.target = n,
    this.id = VF++,
    this.buffer = [],
    this.ready = !1,
    this.pendingRequests = {},
    this.nextMessageId = 0,
    t && this.setBridge(t)
}
Ko.prototype = {
    setBridge: function(e) {
        this.bridge = e,
        e.addListener(this),
        e.isReady() && this.onReady()
    },
    dispose: function(e) {
        this.bridge && !e && this.bridge.dispose()
    },
    onListenStart: function() {
        this.bridge.isReady() && this.onReady()
    },
    onReady: function() {
        if (!this.ready) {
            this.ready = !0;
            for (var e = 0; e < this.buffer.length; e++) {
                var t = this.buffer[e]
                  , n = this.call(t.method, t.params, t.expectResponse);
                t.expectResponse && t.promised(n)
            }
            this.buffer = []
        }
    },
    onMessage: function(e) {
        this._onMessage(e.sender, e.messageId, e.type, e.params)
    },
    _onMessage: function(e, t, n, i) {
        if (n == MS)
            this.pendingRequests[t] && (this.pendingRequests[t].ok(i[0]),
            delete this.pendingRequests[t]);
        else if (e === this.target) {
            var r = this.receiver[n].apply(this.receiver, i);
            typeof r < "u" && this.sendResponse(e, t, r)
        }
    },
    onMessageFail: function(e, t) {
        this.pendingRequests[t] && (this.pendingRequests[t].no(G.PROMISE_FAILURE),
        delete this.pendingRequests[t])
    },
    sendResponse: function(e, t, n) {
        this.bridge.sendMessage(e, MS, t, [n])
    },
    call: function(e, t, n, i) {
        if (t = Ke.argumentsToArray(t),
        this.ready) {
            var s = this.id + "_" + this.nextMessageId++;
            if (this.bridge.sendMessage(this.target, e, s, t),
            n) {
                var o = this
                  , a = new Promise(function(c, l) {
                    o.pendingRequests[s] = {
                        ok: c,
                        no: l
                    },
                    i && Se.addTimedTask(function() {
                        o.pendingRequests[s] && l(G.PROMISE_TIMEOUT)
                    }, i)
                }
                );
                return a
            }
        } else {
            var r = {
                target: this.target,
                method: e,
                params: t,
                expectResponse: n,
                callTimeout: i
            };
            if (this.buffer.push(r),
            n)
                return new Promise(function(c) {
                    r.promised = c
                }
                )
        }
    }
};
Ko.prototype.onReady = Ko.prototype.onReady;
Ko.prototype.onMessageFail = Ko.prototype.onMessageFail;
Ko.prototype.onMessage = Ko.prototype.onMessage;
Ko.prototype.onListenStart = Ko.prototype.onListenStart;
function Nu(e, t) {
    this.initChannel(e, t)
}
Nu.createCaller = function(e, t) {
    return t.addSessionPhase ? function() {
        return this.channel.call(e, [this.sessionPhase].concat(Ke.argumentsToArray(arguments)), t.wantsResponse, t.responseTimeout)
    }
    : function() {
        return this.channel.call(e, arguments, t.wantsResponse, t.responseTimeout)
    }
}
;
Nu.prototype = {
    initChannel: function(e, t) {
        this.channel = new Ko(this,e,t)
    },
    terminateChannel: function(e) {
        this.channel.dispose(e)
    }
};
var dx;
for (Hl in {
    dispose: !0
})
    dx = Hl;
var Hl;
function $l(e, t, n) {
    this._callSuperConstructor($l, [e, n]),
    this.initChannel(t, n)
}
$l.prototype = {
    dispose: function() {
        this._callSuperMethod($l, dx),
        this.terminateChannel(!0)
    }
};
var kS = Du.methods;
for (Hl in kS)
    $l.prototype[Hl] = Nu.createCaller(Hl, kS[Hl]);
var Hl;
ot($l, Du);
ot($l, Nu, !0);
function Fc(e, t) {
    this._callSuperConstructor(Fc),
    this.bridge = t,
    this.engine = e,
    this.bridge.addListener(this)
}
Fc.prototype = {
    onRemote: function(e) {
        var t = new $l(this.engine,this.bridge,e);
        this.dispatchEvent("onNewPushPage", [e, t])
    },
    onMessageFail: function(e) {
        this.bridge.removeTarget(e),
        this.dispatchEvent("onPushPageLost", [e])
    },
    dispose: function() {
        this.bridge.dispose()
    }
};
Fc.prototype.onRemote = Fc.prototype.onRemote;
Fc.prototype.onMessageFail = Fc.prototype.onMessageFail;
ot(Fc, Ru);
var wn = {
    ATTACH: "ATTACH",
    FAST: "ATTACH:FAST",
    IGNORE: "IGNORE",
    ABORT: "ABORT",
    CREATE: "CREATE",
    WAIT: "WAIT"
}, fx;
for (Gl in {
    dispose: !0
})
    fx = Gl;
var Gl, WF = m.getLoggerProxy(G.SHARING), AS = 2e3, jl = function(e, t) {
    this._callSuperConstructor(jl, [e]),
    this.engineType = "remote",
    this.initChannel(t, G.MASTER),
    this.verifyBridge(t)
};
jl.prototype = {
    verifyBridge: function(e) {
        var t = this;
        e.isReady() ? this.remoteReady(e) : (e.addListener({
            onReady: function() {
                t.remoteReady(e)
            }
        }),
        Se.addTimedTask(this.verifyRemoteReady, AS, this))
    },
    verifyRemoteReady: function(e) {
        e.isReady() || (AS *= 2,
        this.onEngineDeath())
    },
    remoteReady: function(e) {
        e.getBridgeId() == G.MASTER && (WF.logInfo(m.resolve(856), this.engineId + " is a master but should be a slave: engine must die"),
        Se.addTimedTask(this.onEngineDeath, 0, this, [!1, !0]))
    },
    dispose: function() {
        this._callSuperMethod(jl, fx),
        this.terminateChannel()
    }
};
var IS = zl.methods;
for (Gl in IS)
    jl.prototype[Gl] = Nu.createCaller(Gl, IS[Gl]);
var Gl;
ot(jl, zl);
ot(jl, Nu, !0);
var $F = function() {
    var e = 0
      , t = 0
      , n = !1
      , i = !1
      , r = m.getLoggerProxy(G.SHARING)
      , s = [];
    function o(d, f) {
        var g = function(v, b) {
            window.name == v && window == top && !(window.Lightstreamer && window.Lightstreamer.wstatus) && (window.name = b,
            window.close())
        }
          , p = "callFun";
        return "var " + p + " = " + g.toString() + "; " + p + "('" + d + "', '" + f + "');"
    }
    function a(d, f, g) {
        d.name != f && d.name != g || d.close()
    }
    function c(d, f) {
        var g = null;
        if (r.logDebug(m.resolve(857)),
        i)
            return !1;
        try {
            g = u(d, f)
        } catch (p) {
            return r.logDebug(m.resolve(858), p),
            !1
        }
        if (g)
            try {
                t++
            } catch {
                i = !0
            }
        return g
    }
    function l(d, f) {
        var g = !0;
        return t - e < -5 && (g = !1),
        window.SymRealWinOpen && g ? (e++,
        window.SymRealWinOpen(d, f, "height=100,width=100", !0)) : (n || (n = !0,
        r.logWarn(m.resolve(859))),
        e = 0,
        null)
    }
    function u(d, f) {
        try {
            return window.SymError ? l(d, f) : window.open(d, f, "height=100,width=100", !0)
        } catch {
            return null
        }
    }
    var h = function() {
        this.refPage = null
    };
    return h.prototype = {
        getWindowRef: function() {
            return this.refPage
        },
        linkLSPage: function(d, f) {
            var g = null;
            try {
                s[d] && (g = s[d])
            } catch {
                g = null
            }
            if (g && (delete s[d],
            this.linkedLSPageVerify(g, d, f)))
                return !0;
            var p = d + "__TRASH"
              , v = o(d, p)
              , b = 'eval("' + v + '; ")';
            return g = c("javascript:" + b, d),
            g === !1 ? (r.logDebug(m.resolve(860)),
            !1) : g ? (r.logDebug(m.resolve(862)),
            this.linkedLSPageVerify(g, d, f),
            !0) : (r.logDebug(m.resolve(861)),
            !0)
        },
        linkedLSPageVerify: function(d, f, g) {
            try {
                if (r.logDebug(m.resolve(863)),
                d.closed)
                    return r.logDebug(m.resolve(864)),
                    !1;
                var p = d;
                if (g) {
                    if (d == d.top && !d.Lightstreamer) {
                        r.logDebug(m.resolve(865));
                        var v = f + "__TRASH";
                        try {
                            a(d, f, v)
                        } catch (b) {
                            r.logDebug(m.resolve(866), b)
                        }
                        return !1
                    }
                    if (p = d.parent,
                    p == null)
                        return r.logDebug(m.resolve(867)),
                        !1
                }
                if (!p.Lightstreamer)
                    return r.logDebug(m.resolve(868)),
                    !1;
                if (!p.Lightstreamer.wstatus)
                    return r.logDebug(m.resolve(869)),
                    !1;
                r.logDebug(m.resolve(870)),
                this.refPage = p,
                this.pageName = f,
                s[f] = d
            } catch (b) {
                return r.logDebug(m.resolve(871), b),
                !1
            }
            return !0
        }
    },
    h
}()
  , RS = {};
function px(e) {
    this.frameName = e
}
px.prototype = {
    getRemotePageReference: function() {
        if (RS[this.frameName])
            return Promise.resolve(null);
        var e = new $F
          , t = e.linkLSPage(this.frameName, !0);
        if (t) {
            var n = e.getWindowRef();
            return n == null ? (RS[this.frameName] = !0,
            Promise.resolve(null)) : Promise.resolve(n)
        } else
            return Promise.resolve(null)
    }
};
var mn = m.getLoggerProxy(G.SHARING)
  , DS = 1e3
  , jF = 1
  , NS = 2
  , FS = 3;
function LS(e, t) {
    var n = Ia.getManager();
    n.cleanSharedStatus(t, e),
    n.removeId(t, e)
}
function Aa(e, t, n, i, r, s, o) {
    this.shareName = t,
    this.localOnly = r,
    this.policyOnFound = n,
    this.policyOnNotFound = i,
    this.shareRef = s,
    this.getNextPhase = 0,
    this.checkedEngines = {},
    this.searchPhase = 0,
    this.client = e,
    this.resolved = !1,
    this.aloneTimeout = o || G.ALONE_CHECK_TIMEOUT,
    this.ok = null,
    this.no = null,
    this.noHope = !1
}
Aa.activeSearches = 0;
Aa.prototype = {
    stop: function() {
        mn.logInfo(m.resolve(873)),
        this.searchPhase++,
        this.resolved || this._callNo()
    },
    find: function(e) {
        this.checkedEngines = e || {};
        var t = this._makePromise();
        return this._find(this.searchPhase, !1),
        t
    },
    getCheckedEngineList: function() {
        return this.checkedEngines
    },
    _callOk: function(e) {
        this.resolved = !0,
        this.ok(e),
        this.stop()
    },
    _callNo: function() {
        this.resolved = !0,
        this.no(),
        this.stop()
    },
    _noHope: function() {
        this.noHope = !0
    },
    _onEngineNotFound: function() {
        this.policyOnNotFound == wn.CREATE ? (mn.logInfo(m.resolve(874)),
        this._callOk(null)) : this.policyOnNotFound == wn.WAIT ? (mn.logInfo(m.resolve(875), DS),
        Se.addTimedTask(this._find, DS, this, [this.searchPhase, !1])) : (mn.logInfo(m.resolve(876)),
        this._callNo())
    },
    _onEngineFound: function(e, t, n) {
        if (this.policyOnFound == wn.ABORT)
            mn.logInfo(m.resolve(877)),
            this._callNo();
        else if (this.policyOnFound != wn.IGNORE) {
            mn.logInfo(m.resolve(878), n);
            var i;
            if (e == jF)
                i = new zl(this.client),
                t.bindLocalClient(i);
            else {
                var r;
                e == NS ? r = new l1 : r = new Wl;
                var s = r.start(t);
                i = new jl(this.client,r),
                s.then(null, function() {
                    mn.logInfo(m.resolve(879), n + " must die"),
                    i.onEngineDeath(!1, !0)
                })
            }
            i.setEngineId(n),
            this._callOk(i)
        } else
            mn.logInfo(m.resolve(880)),
            this.stop()
    },
    _find: function(e, t) {
        if (this.searchPhase == e)
            if (e = ++this.searchPhase,
            mn.logDebug(m.resolve(881)),
            this.localOnly)
                mn.logDebug(m.resolve(883)),
                this._onEngineNotFound();
            else if (this.shareRef) {
                mn.logDebug(m.resolve(884));
                try {
                    var n = this.shareRef.Lightstreamer
                      , i = n.getSharableEngine(this.shareName);
                    if (mn.logDebug(m.resolve(885), i + " (" + this.shareName + ")."),
                    i != null) {
                        var r = i.getEngineId();
                        if (n.hasGlobal(r, G.WORKER_BRIDGE_GLOBAL)) {
                            var s = n.getGlobal(r, G.WORKER_BRIDGE_GLOBAL);
                            this._onEngineFound(FS, s, r);
                            return
                        } else if (n.hasGlobal(r, G.FRAME_BRIDGE_GLOBAL)) {
                            var o = n.getGlobal(r, G.FRAME_BRIDGE_GLOBAL);
                            this._onEngineFound(NS, o, r);
                            return
                        }
                    } else
                        t == !0 && this._noHope()
                } catch (l) {
                    mn.logDebug(m.resolve(886), l)
                }
                this.shareRef = null,
                this._find(this.searchPhase, !1)
            } else {
                mn.logDebug(m.resolve(887));
                var a = this
                  , c = ++this.getNextPhase;
                Se.addTimedTask(function() {
                    c == a.getNextPhase && a.getNextPhase++
                }, G.STOP_SEARCH_TIMEOUT),
                Aa.activeSearches++,
                this._getNextEngineValues(this.getNextPhase).then(function(l) {
                    if (Aa.activeSearches--,
                    e == a.searchPhase)
                        if (mn.logDebug(m.resolve(888)),
                        l == null)
                            mn.logDebug(m.resolve(889)),
                            a._onEngineNotFound();
                        else {
                            mn.logInfo(m.resolve(890), l.id);
                            var u = l.values
                              , h = u[G.BLOB_INDEX]
                              , d = u[G.FRAME_NAME_INDEX];
                            if (h !== G.NULL_VALUE)
                                try {
                                    mn.logDebug(m.resolve(891), l.id + " shares through shared worker", h),
                                    a._onEngineFound(FS, h, l.id)
                                } catch {
                                    a._find(e, !1)
                                }
                            else if (d !== G.NULL_VALUE) {
                                mn.logDebug(m.resolve(892), l.id + " shares through direct communication", d);
                                var f = new px(d)
                                  , g = f.getRemotePageReference();
                                g != null ? g.then(function(p) {
                                    a.shareRef = p,
                                    p || a._noHope(),
                                    a._find(e, !0)
                                }) : a._find(e, !1)
                            } else
                                mn.logInfo(m.resolve(893), u),
                                a._find(e, !1)
                        }
                })
            }
    },
    _makePromise: function() {
        var e = this;
        return new Promise(function(t, n) {
            e.ok = t,
            e.no = n
        }
        )
    },
    _getNextEngineValues: function(e, t) {
        if (this.getNextPhase != e)
            return Promise.resolve(null);
        var n = this
          , i = G.REFRESH_STATUS_INTERVAL
          , r = G.REFRESH_STATUS_INTERVAL + G.REFRESH_STATUS_INTERVAL_TOLERANCE
          , s = Ia.getManager();
        return new Promise(function(o) {
            if (t)
                for (var a in t) {
                    var c = s.readSharedStatus(n.shareName, a);
                    if (c && c[G.TIMESTAMP_INDEX] != t[a]) {
                        n.checkedEngines[a] = !0,
                        o({
                            id: a,
                            values: c
                        });
                        return
                    }
                }
            var l = {}
              , u = s.readIds(n.shareName);
            if (u) {
                for (var h = !1, d = 0; d < u.length; d++)
                    if (!n.checkedEngines[u[d]]) {
                        var c = s.readSharedStatus(n.shareName, u[d]);
                        if (!c || c.length < 5) {
                            LS(u[d], n.shareName),
                            mn.logDebug(m.resolve(894), u[d]);
                            continue
                        }
                        if (c[G.BUILD_INDEX] != G.BUILD || c[G.PROTOCOL_INDEX] != G.PAGE_PROTOCOL) {
                            mn.logDebug(m.resolve(895), c);
                            continue
                        }
                        var f = Et.getTimeStamp()
                          , g = parseInt(c[G.TIMESTAMP_INDEX])
                          , p = f - g
                          , v = c[G.BLOB_INDEX] != G.NULL_VALUE || n.policyOnFound == wn.FAST
                          , b = v ? i : r;
                        if (p <= b)
                            if (v) {
                                n.checkedEngines[u[d]] = !0,
                                o({
                                    id: u[d],
                                    values: c
                                });
                                return
                            } else
                                h = !0,
                                l[u[d]] = g;
                        else if (v && p <= r)
                            h = !0,
                            l[u[d]] = g;
                        else if (p > 6e4) {
                            mn.logInfo(m.resolve(896)),
                            LS(u[d], n.shareName);
                            continue
                        }
                    }
            }
            h ? (mn.logDebug(m.resolve(897)),
            Se.addTimedTask(function() {
                n._getNextEngineValues(e, l).then(function(S) {
                    o(S)
                })
            }, G.REFRESH_STATUS_INTERVAL)) : t ? (mn.logDebug(m.resolve(898)),
            o(null)) : (mn.logDebug(m.resolve(899), n.aloneTimeout),
            Se.addTimedTask(function() {
                n._getNextEngineValues(e, {}).then(function(S) {
                    o(S)
                })
            }, n.aloneTimeout))
        }
        )
    }
};
Aa.failSearch = {
    stop: function() {},
    find: function() {
        return Promise.resolve(null)
    },
    getCheckedEngineList: function() {
        return {}
    }
};
Aa.abortSearch = {
    stop: function() {},
    find: function() {
        return Promise.reject(null)
    },
    getCheckedEngineList: function() {
        return {}
    }
};
var qF = function() {
    var e = new RegExp("^[a-zA-Z0-9]*$")
      , t = {};
    t[wn.ATTACH] = !0,
    t[wn.FAST] = !0,
    t[wn.IGNORE] = !0,
    t[wn.ABORT] = !0;
    var n = {};
    n[wn.CREATE] = !0,
    n[wn.ABORT] = !0,
    n[wn.WAIT] = !0;
    var i = {};
    i[wn.ATTACH] = !0,
    i[wn.FAST] = !0;
    var r = "The share name is missing"
      , s = "The given share name is not valid, use only alphanumeric characters"
      , o = "sharePolicyOnFound must be one of: ATTACH, ATTACH:FAST, IGNORE, ABORT"
      , a = "ATTACH* can only be used if the LightstreamerClient is loaded inside a browser document"
      , c = "sharePolicyOnNotFound must be one of: CREATE, ABORT, WAIT"
      , l = m.getLoggerProxy(G.SHARING)
      , u = function(h, d, f, g, p) {
        if (!h)
            throw new ct(r);
        if (!e.test(h))
            throw new ct(s);
        if (!n[f])
            throw new ct(c);
        if (!t[d])
            throw new ct(o);
        if (this.preventCrossWindowShare = this.checkBool(g, !0),
        !vt.isBrowserDocument()) {
            if (i[d])
                throw new ct(a);
            this.preventCrossWindowShare = !0
        }
        G.PAGE_PROTOCOL == "file:" && !g && (l.logWarn(m.resolve(900)),
        g = !0),
        this.checkEngineTimeout = 5e3,
        this.disposing = !1,
        this.preventCrossWindowShare = g,
        this.shareName = h,
        this.sharePolicyOnFound = d,
        this.sharePolicyOnNotFound = f,
        this.shareRef = p,
        this.aloneTimeout = null,
        this.noHopeToAttach = !1,
        l.isDebugLogEnabled() && l.logDebug(m.resolve(901), "shareName=" + this.shareName, "sharePolicyOnFound=" + this.sharePolicyOnFound, "sharePolicyOnNotFound=" + this.sharePolicyOnNotFound, "preventCrossWindowShare=" + this.preventCrossWindowShare, "shareRef=" + this.shareRef)
    };
    return u.prototype = {
        createSharedStatus: function(h, d, f) {
            var g = new Ia(this.shareName,h);
            return this.preventCrossWindowShare ? g.setupLocalSharing() : (d = this.avoidSuicide() ? null : d,
            g.setupCrossTabSharing(d, f)),
            g
        },
        createChannelsManager: function(h, d) {
            return new Fc(h,d)
        },
        avoidSuicide: function() {
            return this.sharePolicyOnFound === wn.IGNORE || this.noHopeToAttach
        },
        noHope: function() {
            this.noHopeToAttach = !0
        },
        convertToElectionVersion: function(h, d) {
            var f = d ? wn.IGNORE : this.sharePolicyOnFound
              , g = this.sharePolicyOnFound == wn.ATTACH || this.sharePolicyOnFound == wn.FAST ? wn.CREATE : this.sharePolicyOnNotFound
              , p = new u(this.shareName,f,g,this.preventCrossWindowShare,this.shareRef);
            return p.aloneTimeout = h,
            p
        },
        findEngine: function(h) {
            return this.sharePolicyOnFound == wn.IGNORE && this.sharePolicyOnNotFound == wn.CREATE ? (l.logInfo(m.resolve(902)),
            Aa.failSearch) : (this.sharePolicyOnFound == wn.IGNORE || this.sharePolicyOnFound == wn.ABORT) && this.sharePolicyOnNotFound == wn.ABORT ? (l.logInfo(m.resolve(903)),
            Aa.abortSearch) : (l.logInfo(m.resolve(904)),
            new Aa(h,this.shareName,this.sharePolicyOnFound,this.sharePolicyOnNotFound,this.preventCrossWindowShare,this.shareRef,this.aloneTimeout))
        },
        getShareName: function() {
            return this.shareName
        },
        isPossible: function() {
            return this.preventCrossWindowShare || x3.canGenerate()
        }
    },
    u.prototype.getShareName = u.prototype.getShareName,
    ot(u, O3, !0, !0),
    u
}();
function zF(e) {
    return {
        enableSharing: function(t, n, i, r, s) {
            n == i && n == "ABORT" ? e.enableSharing(null) : e.enableSharing(new qF(t,n,i,r,s))
        },
        isMaster: function() {
            return e.isMaster()
        }
    }
}
var Lc = function(e, t, n) {
    this.parentTable = e,
    this.itemReference = t,
    this.relKey = n
};
Lc.prototype = {
    onItemLostUpdates: function(e, t, n) {
        this.shouldDispatch() && (jt.verifyValue(t, 1, "Unexpected item position"),
        this.parentTable.sonLostUpdates(this.relKey, n))
    },
    onSubscriptionError: function(e, t) {
        this.shouldDispatch() && this.parentTable.sonServerDeny(e, t, this.relKey)
    },
    onItemUpdate: function(e) {
        if (this.shouldDispatch()) {
            jt.verifyValue(e.getItemPos(), 1, "Unexpected item position");
            var t = e.extract();
            return this.parentTable.setSecondLevelSchemaSize(t.length - 2),
            t = this.convertMultiSonUpdate(t),
            this.parentTable.update(t, !1, !0)
        }
    },
    shouldDispatch: function() {
        return this.parentTable.hasSubTable(this.itemReference, this.relKey)
    },
    convertMultiSonUpdate: function(e) {
        var t = this.parentTable
          , n = this.itemReference
          , i = [];
        i[0] = t.getTableNumber(),
        i[1] = n,
        i.changedFields = [];
        for (var r = t.getFullSchemaSize() + 2, s = 2, o = 2; o < r; o++)
            o == t.getKeyPos() + 1 ? i[o] = this.relKey : o == t.getCommandPos() + 1 ? i[o] = "UPDATE" : o <= t.getMainSchemaSize() + 1 ? i[o] = G.UNCHANGED : (i[o] = e[s],
            e.unchangedMap[s] ? i[o] = G.UNCHANGED : i.changedFields.push(o - 1),
            s++);
        return i
    }
};
Lc.prototype.onSubscriptionError = Lc.prototype.onSubscriptionError;
Lc.prototype.onItemUpdate = Lc.prototype.onItemUpdate;
Lc.prototype.onItemLostUpdates = Lc.prototype.onItemLostUpdates;
var BS = m.getLoggerProxy(G.ACTIONS)
  , cr = function() {
    this.itemPos = arguments[1],
    this.itemName = arguments[0],
    this._isSnapshot = arguments[3],
    this.fieldDescriptor = arguments[2],
    this.updateValues = arguments[4]
};
cr.prototype = {
    getItemName: function() {
        return this.itemName
    },
    getItemPos: function() {
        return this.itemPos
    },
    getValue: function(e) {
        var t = this.toPos(e)
          , n = this.updateValues[t];
        return n && n.isUnchanged ? n.value : n
    },
    isValueChanged: function(e) {
        var t = this.toPos(e);
        return !this.updateValues.unchangedMap[t]
    },
    isSnapshot: function() {
        return this._isSnapshot
    },
    forEachChangedField: function(e) {
        for (var t = this.updateValues.changedFields, n = 0; n < t.length; n++) {
            var i = this.fieldDescriptor.getName(t[n])
              , r = this.updateValues[t[n] + 1];
            try {
                e(i, t[n], r)
            } catch (s) {
                BS.logErrorExc(s, m.resolve(905))
            }
        }
    },
    forEachField: function(e) {
        for (var t = 2; t < this.updateValues.length; t++) {
            var n = t - 1
              , i = this.fieldDescriptor.getName(n)
              , r = this.updateValues[t];
            try {
                e(i, n, r)
            } catch (s) {
                BS.logErrorExc(s, m.resolve(906))
            }
        }
    },
    toPos: function(e) {
        var t = isNaN(e) ? this.fieldDescriptor.getPos(e) : e;
        if (t == null)
            throw new ct("the specified field does not exist");
        if (t <= 0 || t > this.fieldDescriptor.getFullSize() + 1)
            throw new ct("the specified field position is out of bounds");
        return t + 1
    },
    extract: function() {
        return this.updateValues
    },
    getNumFields: function() {
        return this.updateValues.length - 2
    },
    getFieldName: function(e) {
        return this.fieldDescriptor.getName(e)
    }
};
cr.prototype.getItemName = cr.prototype.getItemName;
cr.prototype.getItemPos = cr.prototype.getItemPos;
cr.prototype.getValue = cr.prototype.getValue;
cr.prototype.isValueChanged = cr.prototype.isValueChanged;
cr.prototype.isSnapshot = cr.prototype.isSnapshot;
cr.prototype.forEachChangedField = cr.prototype.forEachChangedField;
cr.prototype.forEachField = cr.prototype.forEachField;
var i7 = function() {
    this.subDescriptor = null,
    this.len = 0
};
i7.prototype = {
    setSubDescriptor: function(e) {
        this.subDescriptor = e
    },
    getSubDescriptor: function() {
        return this.subDescriptor
    },
    getSize: function() {
        return this.len
    },
    getFullSize: function() {
        return this.subDescriptor ? this.getSize() + this.subDescriptor.getSize() : this.getSize()
    },
    setSize: function(e) {
        this.len = e
    }
};
function XF(e) {
    for (var t = {}, n = 0; n < e.length; n++)
        t[e[n]] = n + 1;
    return t
}
var Tu = function(e) {
    this._callSuperConstructor(Tu),
    this.list = e,
    this.reverseList = XF(e),
    this.len = e.length
};
Tu.prototype = {
    setSize: function(e) {},
    getComposedString: function() {
        return this.list.join(" ")
    },
    getPos: function(e) {
        if (this.reverseList[e])
            return this.reverseList[e];
        if (this.subDescriptor) {
            var t = this.subDescriptor.getPos(e);
            return t !== null ? t + this.len : null
        }
        return null
    },
    getName: function(e) {
        return e > this.len && this.subDescriptor ? this.subDescriptor.getName(e - this.len) : this.list[e - 1] || null
    },
    getOriginal: function() {
        return this.list
    },
    isList: function() {
        return !0
    }
};
ot(Tu, i7);
var Ou = function(e) {
    this._callSuperConstructor(Ou),
    this.name = e
};
Ou.prototype = {
    getComposedString: function() {
        return this.name
    },
    getPos: function(e) {
        if (this.subDescriptor) {
            var t = this.subDescriptor.getPos(e);
            return t !== null ? t + this.len : null
        }
        return null
    },
    getName: function(e) {
        return this.subDescriptor ? this.subDescriptor.getName(e - this.len) : null
    },
    getOriginal: function() {
        return this.name
    },
    isList: function() {
        return !1
    }
};
ot(Ou, i7);
var Mc = function() {
    var e = function(t) {
        this.matrix = t || {}
    };
    return e.prototype = {
        insert: function(t, n, i) {
            n in this.matrix || (this.matrix[n] = {}),
            this.matrix[n][i] = t
        },
        get: function(t, n) {
            return t in this.matrix && n in this.matrix[t] ? this.matrix[t][n] : null
        },
        del: function(t, n) {
            if (!(!t in this.matrix)) {
                n in this.matrix[t] && delete this.matrix[t][n];
                for (var i in this.matrix[t])
                    return;
                delete this.matrix[t]
            }
        },
        insertRow: function(t, n) {
            this.matrix[n] = t
        },
        getRow: function(t) {
            return t in this.matrix ? this.matrix[t] : null
        },
        delRow: function(t) {
            t in this.matrix && delete this.matrix[t]
        },
        getEntireMatrix: function() {
            return this.matrix
        },
        isEmpty: function() {
            for (var t in this.matrix)
                return !1;
            return !0
        },
        forEachElement: function(t) {
            for (var n in this.matrix)
                this.forEachElementInRow(n, t)
        },
        forEachRow: function(t) {
            for (var n in this.matrix)
                t(n)
        },
        forEachElementInRow: function(t, n) {
            var i = this.matrix[t];
            for (var r in i)
                n(i[r], t, r)
        }
    },
    e.prototype.insert = e.prototype.insert,
    e.prototype.get = e.prototype.get,
    e.prototype.del = e.prototype.del,
    e.prototype.insertRow = e.prototype.insertRow,
    e.prototype.getRow = e.prototype.getRow,
    e.prototype.delRow = e.prototype.delRow,
    e.prototype.getEntireMatrix = e.prototype.getEntireMatrix,
    e.prototype.forEachElement = e.prototype.forEachElement,
    e.prototype.forEachElementInRow = e.prototype.forEachElementInRow,
    e.prototype.forEachRow = e.prototype.forEachRow,
    e.prototype.isEmpty = e.prototype.isEmpty,
    e
}()
  , Fu = function(e) {
    this.frequency = e
};
Fu.prototype = {
    isGTE: function(e) {
        return this.frequency == "unlimited" ? !0 : e.frequency == "unlimited" ? !1 : this.frequency > e.frequency
    },
    equals: function(e) {
        return this.frequency == e.frequency
    }
};
var gx = function(e) {
    this.subscription = e
};
gx.prototype = {
    configure: function(e) {
        var t = this.subscription.realMaxFrequency;
        this.subscription.realMaxFrequency = new Fu(e),
        t.equals(this.subscription.realMaxFrequency) || this.subscription.dispatchEvent("onRealMaxFrequency", [this.subscription.realMaxFrequency.frequency])
    }
};
var mx = function(e) {
    this.subscription = e,
    this.multiMetaPushRealMaxFrequency = new Fu(null)
};
mx.prototype = {
    configure: function(e) {
        this.subscription.realMaxFrequency = new Fu(e),
        this.configureMultiMetaPushRealMaxFrequency()
    },
    configureMultiMetaPushRealMaxFrequency: function() {
        var e = this.subscription.realMaxFrequency;
        this.subscription.subTables.forEachElement(function(t) {
            t.realMaxFrequency.isGTE(e) && (e = t.realMaxFrequency)
        }),
        e.equals(this.multiMetaPushRealMaxFrequency) || (this.multiMetaPushRealMaxFrequency = e,
        this.subscription.dispatchEvent("onRealMaxFrequency", [this.multiMetaPushRealMaxFrequency.frequency]))
    },
    onDeleteSecondLevelSubscription: function() {
        this.configureMultiMetaPushRealMaxFrequency()
    }
};
var vx = function(e, t) {
    this.subscription = e,
    this.firstLevelSubscription = t
};
vx.prototype = {
    configure: function(e) {
        this.subscription.realMaxFrequency = new Fu(e),
        this.firstLevelSubscription.realMaxFrequencyManager.configureMultiMetaPushRealMaxFrequency()
    }
};
var _3 = {
    Frequency: Fu,
    FlatPushRealMaxFrequencyManager: gx,
    FirstLevelMultiMetaPushRealMaxFrequencyManager: mx,
    SecondLevelMultiMetaPushRealMaxFrequencyManager: vx
}
  , _x = "Please specifiy a valid array"
  , yx = " name cannot be empty"
  , bx = " name cannot contain spaces"
  , KF = " name cannot be a number";
function YF(e, t) {
    if (!Et.isArray(e))
        throw new ct(_x);
    for (var n = 0; n < e.length; n++)
        if (e[n]) {
            if (e[n].indexOf(" ") > -1)
                throw new ct(t + bx);
            if (!isNaN(e[n]))
                throw new ct(t + KF)
        } else
            throw new ct(t + yx)
}
function QF(e, t) {
    if (!Et.isArray(e))
        throw new ct(_x);
    for (var n = 0; n < e.length; n++)
        if (e[n]) {
            if (e[n].indexOf(" ") > -1)
                throw new ct(t + bx)
        } else
            throw new ct(t + yx)
}
var Cn = {
    checkItemNames: YF,
    checkFieldNames: QF,
    NO_SCHEMA_NOR_LIST: "The field list/field schema of this Subscription was not initiated",
    NO_GROUP_NOR_LIST: "The item list/item group of this Subscription was not initiated",
    USE_GET_ITEM_GROUP: "This Subscription was initiated using an item group, use getItemGroup instead of using getItems",
    USE_GET_ITEMS: "This Subscription was initiated using an item list, use getItems instead of using getItemGroup",
    USE_GET_FIELD_SCHEMA: "This Subscription was initiated using a field schema, use getFieldSchema instead of using getFields",
    USE_GET_FIELDS: "This Subscription was initiated using a field list, use getFields instead of using getFieldSchema",
    MAX_BUF_EXC: "The given value is not valid for this setting; use null, 'unlimited' or a positive number instead",
    MAX_FREQ_EXC: "The given value is not valid for this setting; use null, 'unlimited', 'unfiltered' or a positive number instead",
    YES_FIELDS_NO_ITEMS: "Please specify a valid item or item list",
    NO_VALID_FIELDS: "Please specify a valid field list"
}
  , Bc = function() {
    var e = 1
      , t = 2
      , n = 3
      , i = 4
      , r = 5
      , s = {
        COMMAND: !0,
        RAW: !0,
        MERGE: !0,
        DISTINCT: !0
    }
      , o = 1
      , a = 2
      , c = 3
      , l = G.UNCHANGED
      , u = m.getLoggerProxy(G.SUBSCRIPTIONS)
      , h = "The given value is not a valid subscription mode. Admitted values are MERGE, DISTINCT, RAW, COMMAND"
      , d = "The received key value is not a valid name for an Item"
      , f = "Invalid Subscription, please specify an item list or item group"
      , g = "Invalid Subscription, please specify a field list or field schema"
      , p = "Cannot modify an active Subscription, please unsubscribe before applying any change"
      , v = "Subscription is not active"
      , b = "Can't change the frequency from/to 'unfiltered' or to null while the Subscription is active"
      , S = "Numeric values are only allowed when the subscription mode is DISTINCT"
      , w = "Snapshot is not permitted if RAW was specified as mode"
      , k = "The given value is not valid for this setting; use null, 'yes', 'no' or a positive number instead"
      , B = "The second level of this Subscription was not initiated"
      , N = "Second level field list is only available on COMMAND Subscriptions"
      , E = "This method can only be used on COMMAND subscriptions";
    function F(x, j) {
        return x - j
    }
    var O = function(x, j, fe) {
        if (this._callSuperConstructor(O),
        x = new String(x).toUpperCase(),
        !x || !s[x])
            throw new ct(h);
        if (this._mode = x,
        this.itemList = null,
        this.itemGroup = null,
        this.itemDescriptor = null,
        this.fieldList = null,
        this.fieldSchema = null,
        this.fieldDescriptor = null,
        this.isRequiredSnapshot = x === "RAW" ? null : "yes",
        this.requestedMaxFrequency = null,
        this.requestedBufferSize = null,
        this._start = null,
        this._end = null,
        this._selector = null,
        this.dataAdapter = null,
        this.tableNumber = null,
        this.requestParams = null,
        this.realMaxFrequency = new _3.Frequency(null),
        this.realMaxFrequencyManager = null,
        this.oldValuesByItem = new Mc,
        this.oldValuesByKey = new Mc,
        this.handler = null,
        this.tablePhaseType = e,
        this.tablePhase = 0,
        this._id = null,
        this.onCount = 0,
        this.sCount = 0,
        this.setBehavior(this._mode == G.COMMAND ? a : o),
        this.commandCode = null,
        this.keyCode = null,
        this.underDataAdapter = null,
        this.subTables = new Mc,
        this.subFieldList = null,
        this.subFieldSchema = null,
        this.subFieldDescriptor = null,
        this.subMode = G.MERGE,
        j) {
            if (!fe || !Et.isArray(fe))
                throw new ct(Cn.NO_VALID_FIELDS);
            Et.isArray(j) ? this.setItems(j) : this.setItems([j]),
            this.setFields(fe)
        } else if (fe)
            throw new ct(Cn.YES_FIELDS_NO_ITEMS)
    };
    O.prototype = {
        toString: function() {
            return ["[", "Subscription", this.tablePhaseType, this.tablePhase, this._id, this.tableNumber, "]"].join("|")
        },
        cleanData: function() {
            this.tableNumber = null,
            this.oldValuesByItem = new Mc,
            this.oldValuesByKey = new Mc,
            this.snapshotByItem = null,
            this.fieldDescriptor.setSize(0),
            this.itemDescriptor.setSize(0),
            this.behavior == c && (this.fieldDescriptor.setSubDescriptor(null),
            this.subTables = new Mc),
            u.logDebug(m.resolve(907), this)
        },
        onAdd: function(x, j, fe) {
            if (this.notAliveCheck(),
            !this.itemDescriptor)
                throw new ct(f);
            if (!this.fieldDescriptor)
                throw new ct(g);
            return this.tablePhaseType = r,
            this._id = x,
            this.handler = fe,
            this.onCount++,
            jt.verifyValue(this.onCount, 1, "Wrong count while adding"),
            u.logInfo(m.resolve(908), this),
            !0
        },
        onSubmission: function() {
            this.tablePhaseType = t,
            u.logDebug(m.resolve(909), this)
        },
        onTableNumber: function(x) {
            this.tableNumber = x,
            this.tablePhaseType = n,
            u.logDebug(m.resolve(910), this)
        },
        onPause: function() {
            var x = this.isPushing();
            this.tablePhaseType = r,
            this.cleanData(),
            x && this.onEndPush(),
            u.logDebug(m.resolve(911), this)
        },
        onRemove: function() {
            this.isAliveCheck();
            var x = this.isPushing();
            this.tablePhaseType = e,
            this._id = null,
            delete this.requestParams,
            this.behavior == c && this.removeSubTables(),
            this.cleanData(),
            this.onCount--,
            jt.verifyValue(this.onCount, 0, "Wrong count while removing"),
            x && this.onEndPush(),
            this.handler = null,
            u.logDebug(m.resolve(912), this)
        },
        onStartPush: function(x, j, fe, he) {
            this.tablePhaseType = i,
            this.sCount++,
            jt.verifyValue(this.sCount, 1, "Wrong count starting push"),
            u.logInfo(m.resolve(913), this),
            this.behavior == c && this.fieldDescriptor.setSubDescriptor(this.subFieldDescriptor),
            this.fieldSchema && this.behavior != o && this.setServerSentMetapushFields(j, x),
            this.itemDescriptor.setSize(fe),
            this.fieldDescriptor.setSize(he),
            this.snapshotByItem = [];
            for (var Re = 1; Re <= fe; Re++)
                this.snapshotByItem[Re] = new V(this);
            this.dispatchEvent("onSubscription")
        },
        onStopPush: function() {},
        onEndPush: function() {
            this.sCount--,
            jt.verifyValue(this.sCount, 0, "Wrong count ending push"),
            u.logInfo(m.resolve(914), this),
            this.dispatchEvent("onUnsubscription")
        },
        removeSubTables: function() {
            var x = this;
            this.subTables.forEachElement(function(j, fe, he) {
                x.removeSubTable(fe, he)
            })
        },
        removeItemSubTables: function(x) {
            var j = this;
            this.subTables.forEachElementInRow(function(fe, he, Re) {
                j.removeSubTable(he, Re)
            })
        },
        getTableNumber: function() {
            return this.tableNumber
        },
        getTablePhase: function() {
            return this.tablePhase
        },
        getRequestParams: function() {
            return this.generateRequest(),
            this.requestParams
        },
        generateMaxFrequencyParam: function() {
            if (this.requestedMaxFrequency != null) {
                var x = this.requestedMaxFrequency;
                return {
                    LS_requested_max_frequency: x
                }
            }
            return {}
        },
        generateRequest: function() {
            var x = {
                LS_mode: this._mode,
                LS_group: encodeURIComponent(this.itemDescriptor.getComposedString()),
                LS_schema: encodeURIComponent(this.fieldDescriptor.getComposedString())
            };
            if (this.dataAdapter != null && (x.LS_data_adapter = encodeURIComponent(this.dataAdapter)),
            this._selector != null && (x.LS_selector = encodeURIComponent(this._selector)),
            this._start != null && (x.LS_start = this._start),
            this._end != null && (x.LS_end = this._end),
            this.isRequiredSnapshot != null && (x.LS_snapshot = this.isRequiredSnapshot === "yes" ? "true" : this.isRequiredSnapshot === "no" ? "false" : this.isRequiredSnapshot),
            Ke.extendObj(x, this.generateMaxFrequencyParam()),
            this.requestedBufferSize != null) {
                var j = this.requestedBufferSize;
                (j == "unlimited" || j > 0) && (x.LS_requested_buffer_size = j)
            }
            return u.logDebug(m.resolve(915), this),
            this.requestParams = x,
            this.requestParams
        },
        setSchemaReadMetapushFields: function() {
            if (!(this._mode != G.COMMAND || this.fieldList == null) && (this.commandCode = this.fieldList.getPos("command"),
            this.keyCode = this.fieldList.getPos("key"),
            !this.commandCode || !this.keyCode))
                throw new ct("A field list for a COMMAND subscription must contain the key and command fields")
        },
        setServerSentMetapushFields: function(x, j) {
            u.logDebug(m.resolve(916), this, x, j),
            this.commandCode = x,
            this.keyCode = j
        },
        getSubscriptionId: function() {
            return this._id
        },
        notAliveCheck: function() {
            if (this.isActive())
                throw new St(p)
        },
        isAliveCheck: function() {
            if (!this.isActive())
                throw new St(v)
        },
        secondLevelCheck: function() {
            if (this._mode != G.COMMAND)
                throw new St(N)
        },
        commandCheck: function() {
            if (this._mode != G.COMMAND)
                throw new St(E)
        },
        isOff: function() {
            return this.tablePhaseType == e
        },
        isWaiting: function() {
            return this.tablePhaseType == t
        },
        isSubscribing: function() {
            return this.tablePhaseType == n
        },
        isPushing: function() {
            return this.tablePhaseType == i
        },
        isPaused: function() {
            return this.tablePhaseType == r
        },
        isActive: function() {
            return this.tablePhaseType != e
        },
        isSubscribed: function() {
            return this.isPushing()
        },
        setItems: function(x) {
            this.notAliveCheck(),
            Cn.checkItemNames(x, "An item"),
            this.itemList = x == null ? null : new Tu(x),
            this.itemGroup = null,
            this.itemDescriptor = this.itemList
        },
        getItems: function() {
            if (!this.itemList)
                throw this.itemGroup ? new St(Cn.USE_GET_ITEM_GROUP) : new St(Cn.NO_GROUP_NOR_LIST);
            return this.itemList.getOriginal()
        },
        setItemGroup: function(x) {
            this.notAliveCheck(),
            this.itemList = null,
            this.itemGroup = x == null ? null : new Ou(x),
            this.itemDescriptor = this.itemGroup
        },
        getItemGroup: function() {
            if (!this.itemGroup)
                throw this.itemList ? new St(Cn.USE_GET_ITEMS) : new St(Cn.NO_GROUP_NOR_LIST);
            return this.itemGroup.getOriginal()
        },
        setFields: function(x) {
            this.notAliveCheck(),
            Cn.checkFieldNames(x, "A field"),
            this.fieldList = x == null ? null : new Tu(x),
            this.fieldSchema = null,
            this.fieldDescriptor = this.fieldList,
            this.setSchemaReadMetapushFields()
        },
        getFields: function() {
            if (!this.fieldList)
                throw this.fieldSchema ? new St(Cn.USE_GET_FIELD_SCHEMA) : new St(Cn.NO_SCHEMA_NOR_LIST);
            return this.fieldList.getOriginal()
        },
        setFieldSchema: function(x) {
            this.notAliveCheck(),
            this.fieldList = null,
            this.fieldSchema = x == null ? null : new Ou(x),
            this.fieldDescriptor = this.fieldSchema
        },
        getFieldSchema: function() {
            if (!this.fieldSchema)
                throw this.fieldList ? new St(Cn.USE_GET_FIELDS) : new St(Cn.NO_SCHEMA_NOR_LIST);
            return this.fieldSchema.getOriginal()
        },
        getMode: function() {
            return this._mode
        },
        setDataAdapter: function(x) {
            this.notAliveCheck(),
            this.dataAdapter = x,
            u.logDebug(m.resolve(917), this, x)
        },
        getDataAdapter: function() {
            return this.dataAdapter
        },
        setSelector: function(x) {
            this.notAliveCheck(),
            this._selector = x,
            u.logDebug(m.resolve(918), this, x)
        },
        getSelector: function() {
            return this._selector
        },
        setRequestedMaxFrequency: function(x) {
            x && (x = new String(x),
            x = x.toLowerCase());
            var j = this.requestedMaxFrequency;
            if (this.isActive()) {
                if (!x && x != 0)
                    throw new St(b);
                if (x == "unfiltered" || this.requestedMaxFrequency == "unfiltered")
                    throw new St(b)
            }
            if (!x && x != 0)
                this.requestedMaxFrequency = null;
            else if (x == "unfiltered" || x == "unlimited")
                this.requestedMaxFrequency = x;
            else
                try {
                    this.requestedMaxFrequency = this.checkPositiveNumber(x, !1, !0)
                } catch {
                    throw new ct(Cn.MAX_FREQ_EXC)
                }
            if ((this.isWaiting() || this.isSubscribing() || this.isPushing()) && String(j) != String(this.requestedMaxFrequency) && (this.handler.updateSubscriptionParams(this, this.generateMaxFrequencyParam()),
            this.behavior == c)) {
                var fe = this;
                this.subTables.forEachElement(function(he, Re, Xe) {
                    jt.verifyOk(fe.isPushing(), "Table not pushing"),
                    he.setRequestedMaxFrequency(fe.requestedMaxFrequency)
                })
            }
            u.logDebug(m.resolve(919), this, this.requestedMaxFrequency)
        },
        getRequestedMaxFrequency: function() {
            return this.requestedMaxFrequency == null ? null : String(this.requestedMaxFrequency)
        },
        setRequestedBufferSize: function(x) {
            if (this.notAliveCheck(),
            !x && x != 0)
                this.requestedBufferSize = null;
            else if (x = new String(x),
            x = x.toLowerCase(),
            x == "unlimited")
                this.requestedBufferSize = x;
            else
                try {
                    this.requestedBufferSize = this.checkPositiveNumber(x)
                } catch {
                    throw new ct(Cn.MAX_BUF_EXC)
                }
            u.logDebug(m.resolve(920), this, this.requestedBufferSize)
        },
        getRequestedBufferSize: function() {
            return this.requestedBufferSize == null ? null : String(this.requestedBufferSize)
        },
        setRequestedSnapshot: function(x) {
            if (this.notAliveCheck(),
            !x && x != 0)
                this.isRequiredSnapshot = null;
            else if (x = new String(x),
            x = x.toLowerCase(),
            x == "no")
                this.isRequiredSnapshot = x;
            else {
                if (this._mode == G.RAW)
                    throw new St(w);
                if (x == "yes")
                    this.isRequiredSnapshot = x;
                else {
                    if (isNaN(x))
                        throw new ct(k);
                    if (this._mode != G.DISTINCT)
                        throw new St(S);
                    try {
                        this.isRequiredSnapshot = this.checkPositiveNumber(x)
                    } catch {
                        throw new ct(k)
                    }
                }
            }
            u.logDebug(m.resolve(921), this, this.isRequiredSnapshot)
        },
        getRequestedSnapshot: function() {
            return this.isRequiredSnapshot
        },
        setCommandSecondLevelFields: function(x) {
            this.notAliveCheck(),
            this.secondLevelCheck(),
            Cn.checkFieldNames(x, "A field"),
            this.subFieldList = x == null ? null : new Tu(x),
            this.subFieldSchema = null,
            this.subFieldDescriptor = this.subFieldList,
            this.prepareSecondLevel()
        },
        getCommandSecondLevelFields: function() {
            if (!this.subFieldList)
                throw this.subFieldSchema ? new St("The second level of this Subscription was initiated using a field schema, use getCommandSecondLevelFieldSchema instead of using getCommandSecondLevelFields") : new St(B);
            return this.subFieldList.getOriginal()
        },
        setCommandSecondLevelFieldSchema: function(x) {
            this.notAliveCheck(),
            this.secondLevelCheck(),
            this.subFieldList = null,
            this.subFieldSchema = x == null ? null : new Ou(x),
            this.subFieldDescriptor = this.subFieldSchema,
            this.prepareSecondLevel()
        },
        getCommandSecondLevelFieldSchema: function() {
            if (!this.subFieldSchema)
                throw this.subFieldList ? new St("The second level of this Subscription was initiated using a field list, use getCommandSecondLevelFields instead of using getCommandSecondLevelFieldSchema") : new St(B);
            return this.subFieldSchema.getOriginal()
        },
        setCommandSecondLevelDataAdapter: function(x) {
            this.notAliveCheck(),
            this.secondLevelCheck(),
            this.underDataAdapter = x,
            u.logDebug(m.resolve(922), this, x)
        },
        getCommandSecondLevelDataAdapter: function() {
            return this.underDataAdapter
        },
        getValue: function(x, j) {
            return this.oldValuesByItem.get(this.toItemPos(x), this.toFieldPos(j))
        },
        getCommandValue: function(x, j, fe) {
            return this.commandCheck(),
            this.oldValuesByKey.get(this.toItemPos(x) + " " + j, this.toFieldPos(fe, !0))
        },
        getKeyPosition: function() {
            if (this.commandCheck(),
            !this.fieldSchema && this.fieldList)
                throw new St("This Subscription was initiated using a field list, key field is always 'key'");
            if (this.keyCode == null)
                throw new St("The position of the key field is currently unknown");
            return this.keyCode
        },
        getCommandPosition: function() {
            if (this.commandCheck(),
            !this.fieldSchema && this.fieldList)
                throw new St("This Subscription was initiated using a field list, command field is always 'command'");
            if (this.commandCode == null)
                throw new St("The position of the command field is currently unknown");
            return this.commandCode
        },
        toFieldPos: function(x, j) {
            var fe = this.toPos(x, this.fieldDescriptor, j);
            if (fe === null)
                throw new ct("the specified field does not exist");
            if (fe === !1)
                throw new ct("the specified field position is out of bounds");
            return fe
        },
        toItemPos: function(x) {
            var j = this.toPos(x, this.itemDescriptor);
            if (j === null)
                throw new ct("the specified item does not exist");
            if (j === !1)
                throw new ct("the specified item position is out of bounds");
            return j
        },
        toPos: function(x, j, fe) {
            var he = isNaN(x) ? j.getPos(x) : x;
            return he == null ? null : he <= 0 || he > (fe ? j.getFullSize() : j.getSize()) ? !1 : he
        },
        prepareSecondLevel: function() {
            this.subFieldDescriptor == null ? this.setBehavior(a) : this.setBehavior(c)
        },
        endOfSnapshot: function(x) {
            var j = this.itemDescriptor.getName(x);
            jt.assertNotNull(this.snapshotByItem[x], "Item index out of range"),
            this.snapshotByItem[x].endOfSnapshot(),
            this.dispatchEvent("onEndOfSnapshot", [j, x])
        },
        clearSnapshot: function(x) {
            var j = this.itemDescriptor.getName(x);
            this.behavior == a ? this.oldValuesByKey = new Mc : this.behavior == c && (this.oldValuesByKey = new Mc,
            this.removeItemSubTables(x)),
            this.dispatchEvent("onClearSnapshot", [j, x])
        },
        lostUpdates: function(x, j, fe) {
            var he = this.itemDescriptor.getName(x);
            this.dispatchEvent("onItemLostUpdates", [he, x, j])
        },
        sonLostUpdates: function(x, j) {
            this.dispatchEvent("onCommandSecondLevelItemLostUpdates", [j, x])
        },
        serverDeny: function(x, j) {
            this.dispatchEvent("onSubscriptionError", [x, j])
        },
        sonServerDeny: function(x, j, fe) {
            this.dispatchEvent("onCommandSecondLevelSubscriptionError", [x, j, fe])
        },
        update: function(x, j, fe) {
            jt.verifyValue(i, this.tablePhaseType, "Wrong table phase");
            var he = x[1];
            jt.assertNotNull(this.snapshotByItem[he], "Item index out of range"),
            this.snapshotByItem[he].update();
            var Re = this.snapshotByItem[he].isSnapshot()
              , Xe = new String(he);
            this.behavior != o && (Xe = this.organizeMPUpdate(x, he, fe)),
            this.behavior == c && !fe && this.handleMultiTableSubscriptions(x),
            this.behavior == o ? this.updateStructure(this.oldValuesByItem, he, x, !0) : this.updateStructure(this.oldValuesByKey, Xe, x, !0);
            var pt = new cr(this.itemDescriptor.getName(he),he,this.fieldDescriptor,Re,x);
            this.dispatchEvent("onItemUpdate", [pt]),
            this.oldValuesByKey.get(Xe, this.commandCode) == "DELETE" && this.oldValuesByKey.delRow(Xe)
        },
        updateStructure: function(x, j, fe, he) {
            var Re = fe.length - 2
              , Xe = 1
              , pt = 2;
            for (fe.unchangedMap = {}; Xe <= Re; Xe++,
            pt++)
                fe[pt] !== l ? x.insert(fe[pt], j, Xe) : he && (fe[pt] = x.get(j, Xe),
                fe.unchangedMap[pt] = !0)
        },
        organizeMPUpdate: function(x, j, fe) {
            var he;
            if (typeof x[this.keyCode + 1] > "u" || typeof x[this.commandCode + 1] > "u")
                return u.logWarn(m.resolve(923)),
                null;
            if (x[this.keyCode + 1] == l ? he = j + " " + this.oldValuesByItem.get(j, this.keyCode) : he = j + " " + x[this.keyCode + 1],
            fe)
                x[this.keyCode + 1] = l,
                x[this.commandCode + 1] == this.oldValuesByKey.get(he, this.commandCode) ? x[this.commandCode + 1] = l : (x.changedFields.push(this.commandCode),
                x.changedFields.sort(F));
            else {
                x.changedFields = [];
                for (var Re = 2; Re < x.length; Re++)
                    x[Re] && x[Re] == l ? x[Re] = this.oldValuesByItem.get(j, Re - 1) : this.oldValuesByItem.insert(x[Re], j, Re - 1),
                    x[Re] == this.oldValuesByKey.get(he, Re - 1) ? x[Re] = l : x.changedFields.push(Re - 1);
                if (this.behavior == c) {
                    var Xe = this.getFullSchemaSize() + 2;
                    if (Xe > x.length)
                        for (var Re = x.length; Re < Xe; Re++)
                            x[Re] = l
                }
            }
            return he
        },
        handleMultiTableSubscriptions: function(x) {
            var j = x[1]
              , fe = x[this.keyCode + 1] == l ? this.oldValuesByItem.get(j, this.keyCode) : x[this.keyCode + 1]
              , he = x[this.commandCode + 1]
              , Re = this.hasSubTable(j, fe);
            he == "DELETE" ? Re && this.removeSubTable(j, fe) : Re || this.addSubTable(j, fe)
        },
        makeSubTable: function(x) {
            this.subTableFlag = !0,
            this.realMaxFrequencyManager = new _3.SecondLevelMultiMetaPushRealMaxFrequencyManager(this,x)
        },
        isSubTable: function() {
            return this.subTableFlag
        },
        hasSubTable: function(x, j) {
            return this.subTables.get(x, j) !== null
        },
        removeSubTable: function(x, j) {
            this.handler.removeATable(this.subTables.get(x, j)),
            this.subTables.del(x, j),
            this.realMaxFrequencyManager.onDeleteSecondLevelSubscription()
        },
        addSubTable: function(x, j) {
            var fe = new O(this.subMode);
            fe.makeSubTable(this);
            try {
                fe.setItems([j]),
                this.subTables.insert(fe, x, j)
            } catch {
                this.dispatchEvent("onCommandSecondLevelSubscriptionError", [14, d, j]);
                return
            }
            this.subFieldList ? fe.setFields(this.subFieldList.getOriginal()) : fe.setFieldSchema(this.subFieldSchema.getOriginal()),
            fe.setDataAdapter(this.underDataAdapter),
            fe.setRequestedSnapshot("yes"),
            fe.requestedMaxFrequency = this.requestedMaxFrequency;
            var he = new Lc(this,x,j);
            fe.addListener(he),
            this.handler.addATable(fe)
        },
        setSecondLevelSchemaSize: function(x) {
            this.subFieldDescriptor.setSize(x)
        },
        getMainSchemaSize: function() {
            return this.fieldDescriptor.getSize()
        },
        getFullSchemaSize: function() {
            return this.fieldDescriptor.getFullSize()
        },
        getKeyPos: function() {
            return this.keyCode
        },
        getCommandPos: function() {
            return this.commandCode
        },
        addListener: function(x) {
            this._callSuperMethod(O, "addListener", [x])
        },
        removeListener: function(x) {
            this._callSuperMethod(O, "removeListener", [x])
        },
        getListeners: function() {
            return this._callSuperMethod(O, "getListeners")
        },
        setBehavior: function(x) {
            switch (this.behavior = x,
            x) {
            case o:
            case a:
                this.realMaxFrequencyManager = new _3.FlatPushRealMaxFrequencyManager(this);
                break;
            case c:
                this.realMaxFrequencyManager = new _3.FirstLevelMultiMetaPushRealMaxFrequencyManager(this);
                break;
            default:
                ut.verifyOk(!1)
            }
        },
        configure: function(x) {
            this.realMaxFrequencyManager.configure(x)
        }
    };
    function V(x) {
        this.firstUpdate = !0,
        this.eosReceived = !1,
        this.state = X.NO_UPDATE_RECEIVED,
        this.subscription = x
    }
    V.prototype.update = function() {
        this.state == X.NO_UPDATE_RECEIVED ? this.state = X.ONE_UPDATE_RECEIVED : this.state == X.ONE_UPDATE_RECEIVED && (this.state = X.MORE_THAN_ONE_UPDATE_RECEIVED,
        this.firstUpdate = !1)
    }
    ,
    V.prototype.endOfSnapshot = function() {
        this.eosReceived = !0
    }
    ,
    V.prototype.snapshotRequested = function() {
        return this.subscription.isRequiredSnapshot != null && this.subscription.isRequiredSnapshot != "no"
    }
    ,
    V.prototype.isSnapshot = function() {
        return this.snapshotRequested() ? G.MERGE == this.subscription._mode ? this.firstUpdate : G.COMMAND == this.subscription._mode || G.DISTINCT == this.subscription._mode ? !this.eosReceived : !1 : !1
    }
    ;
    var X = {
        NO_UPDATE_RECEIVED: 0,
        ONE_UPDATE_RECEIVED: 1,
        MORE_THAN_ONE_UPDATE_RECEIVED: 2
    };
    return O.prototype.isActive = O.prototype.isActive,
    O.prototype.isSubscribed = O.prototype.isSubscribed,
    O.prototype.setItems = O.prototype.setItems,
    O.prototype.getItems = O.prototype.getItems,
    O.prototype.setItemGroup = O.prototype.setItemGroup,
    O.prototype.getItemGroup = O.prototype.getItemGroup,
    O.prototype.setFields = O.prototype.setFields,
    O.prototype.getFields = O.prototype.getFields,
    O.prototype.setFieldSchema = O.prototype.setFieldSchema,
    O.prototype.getFieldSchema = O.prototype.getFieldSchema,
    O.prototype.getMode = O.prototype.getMode,
    O.prototype.setDataAdapter = O.prototype.setDataAdapter,
    O.prototype.getDataAdapter = O.prototype.getDataAdapter,
    O.prototype.setSelector = O.prototype.setSelector,
    O.prototype.getSelector = O.prototype.getSelector,
    O.prototype.setRequestedMaxFrequency = O.prototype.setRequestedMaxFrequency,
    O.prototype.getRequestedMaxFrequency = O.prototype.getRequestedMaxFrequency,
    O.prototype.setRequestedBufferSize = O.prototype.setRequestedBufferSize,
    O.prototype.getRequestedBufferSize = O.prototype.getRequestedBufferSize,
    O.prototype.setRequestedSnapshot = O.prototype.setRequestedSnapshot,
    O.prototype.getRequestedSnapshot = O.prototype.getRequestedSnapshot,
    O.prototype.setCommandSecondLevelFields = O.prototype.setCommandSecondLevelFields,
    O.prototype.getCommandSecondLevelFields = O.prototype.getCommandSecondLevelFields,
    O.prototype.setCommandSecondLevelFieldSchema = O.prototype.setCommandSecondLevelFieldSchema,
    O.prototype.getCommandSecondLevelFieldSchema = O.prototype.getCommandSecondLevelFieldSchema,
    O.prototype.setCommandSecondLevelDataAdapter = O.prototype.setCommandSecondLevelDataAdapter,
    O.prototype.getCommandSecondLevelDataAdapter = O.prototype.getCommandSecondLevelDataAdapter,
    O.prototype.getValue = O.prototype.getValue,
    O.prototype.getCommandValue = O.prototype.getCommandValue,
    O.prototype.getKeyPosition = O.prototype.getKeyPosition,
    O.prototype.getCommandPosition = O.prototype.getCommandPosition,
    O.prototype.addListener = O.prototype.addListener,
    O.prototype.removeListener = O.prototype.removeListener,
    O.prototype.getListeners = O.prototype.getListeners,
    ot(O, Ru, !1, !0),
    ot(O, O3, !0, !0),
    O
}()
  , JF = m.getLoggerProxy(G.MPN)
  , Sx = function(e) {
    this.subscription = e
};
Sx.prototype = {
    onSubscribe: function(e) {
        this.subscription.coalescing = e,
        this.subscription.stateMachine.subscribe()
    },
    onUnsubscribe: function() {
        this.subscription.stateMachine.unsubscribe()
    },
    setSubscriptionId: function(e) {
        this.subscription.PN_subscriptionId = e
    },
    onSubscribeOK: function(e) {
        this.setSubscriptionId(e)
    },
    onStatusChange: function(e, t) {
        switch (this.subscription.statusTimestamp = t,
        e) {
        case "ACTIVE":
            this.subscription.stateMachine.activate();
            break;
        case "TRIGGERED":
            this.subscription.stateMachine.trigger();
            break;
        default:
            var n = "Unknown status " + e + " (" + this.subscription.PN_subscriptionId + ")";
            throw JF.logError(n),
            new Error(n)
        }
    },
    onSubscribeError: function(e, t) {
        this.subscription.stateMachine.onSubscribeError(e, t)
    },
    onUnsubscribeError: function(e, t) {
        this.subscription.stateMachine.onUnsubscribeError(e, t)
    },
    simulateSubscribe: function(e, t) {
        this.subscription.statusTimestamp = t,
        e == "ACTIVE" ? this.subscription.stateMachine.onAddSubscribed() : this.subscription.stateMachine.onAddTriggered()
    },
    simulateUnsubscribe: function() {
        this.subscription.stateMachine.onDelete()
    },
    cancelSubscription: function() {
        this.subscription.stateMachine.cancelSubscription()
    },
    onChangeMode: function(e) {
        this.subscription.mode != e && (this.subscription.mode = e,
        this.onPropertyChange("mode"))
    },
    onChangeGroup: function(e) {
        this.subscription.items != e && (this.subscription.items = e,
        this.onPropertyChange("group"))
    },
    onChangeSchema: function(e) {
        this.subscription.fields != e && (this.subscription.fields = e,
        this.onPropertyChange("schema"))
    },
    onChangeFormat: function(e) {
        this.subscription.format != e && (this.subscription.format = e,
        this.onPropertyChange("notification_format"))
    },
    onChangeTrigger: function(e) {
        this.subscription.trigger != e && (this.subscription.trigger = e,
        this.onPropertyChange("trigger"))
    },
    onChangeAdapter: function(e) {
        this.subscription.adapter != e && (this.subscription.adapter = e,
        this.onPropertyChange("adapter"))
    },
    onChangeRequestedBufferSize: function(e) {
        e = this.subscription._convertBufferSize(e),
        this.subscription.requestedBufferSize != e && (this.subscription.requestedBufferSize = e,
        this.onPropertyChange("requested_buffer_size"))
    },
    onChangeRequestedMaxFrequency: function(e) {
        e = this.subscription._convertFrequency(e),
        this.subscription.requestedMaxFrequency != e && (this.subscription.requestedMaxFrequency = e,
        this.onPropertyChange("requested_max_frequency"))
    },
    onChangeTimestamp: function(e) {
        this.subscription.statusTimestamp != e && (this.subscription.statusTimestamp = e,
        this.onPropertyChange("status_timestamp"))
    },
    onPropertyChange: function(e) {
        this.subscription.dispatchEvent("onPropertyChanged", [e])
    }
};
var ZF = function() {
    var e = m.getLoggerProxy(G.MPN)
      , t = function() {
        this.initDispatcher(),
        this.mode = null,
        this.format = null,
        this.trigger = null,
        this.items = null,
        this.fields = null,
        this.adapter = null,
        this.PN_subscriptionId = null,
        this.statusTimestamp = 0,
        this.requestedBufferSize = -1,
        this.requestedMaxFrequency = -2,
        this.coalescing = !1,
        this.needsInitialization = !0,
        this.eventManager = new Sx(this),
        this.stateMachine = new i(this);
        var r = arguments[0];
        if (typeof r == "string" || r instanceof String)
            this._init0(r, arguments[1], arguments[2]);
        else if (r instanceof t)
            this._initFromMpnSubscription(r);
        else if (r instanceof Bc)
            this._initFromSubscription(r);
        else
            throw new Error("Wrong arguments for MpnSubscription constructor")
    };
    t.prototype = {
        _init0: function(r, s, o) {
            if (r = new String(r).toUpperCase(),
            r != "MERGE" && r != "DISTINCT")
                throw new ct("Only MERGE and DISTINCT modes are allowed for MPN subscriptions");
            if (this.mode = r,
            s != null) {
                if (o == null)
                    throw new ct(Cn.NO_VALID_FIELDS);
                Et.isArray(s) ? this.setItems(s) : this.setItems([s]),
                this.setFields(o)
            } else if (o != null)
                throw new ct(Cn.YES_FIELDS_NO_ITEMS)
        },
        _initFromSubscription: function(r) {
            this.mode = r._mode,
            this.items = r.itemDescriptor.getComposedString(),
            this.fields = r.fieldDescriptor.getComposedString(),
            this.adapter = r.dataAdapter
        },
        _initFromMpnSubscription: function(r) {
            this.mode = r.mode,
            this.items = r.items,
            this.fields = r.fields,
            this.format = r.format,
            this.trigger = r.trigger,
            this.adapter = r.adapter,
            this.PN_subscriptionId = r.PN_subscriptionId,
            this.requestedBufferSize = r.requestedBufferSize,
            this.requestedMaxFrequency = r.requestedMaxFrequency
        },
        addListener: function(r) {
            this._callSuperMethod(t, "addListener", [r])
        },
        removeListener: function(r) {
            this._callSuperMethod(t, "removeListener", [r])
        },
        getListeners: function() {
            return this._callSuperMethod(t, "getListeners")
        },
        getNotificationFormat: function() {
            return this.format
        },
        setNotificationFormat: function(r) {
            this.throwErrorIfActive(),
            this.format = r
        },
        getTriggerExpression: function() {
            return this.trigger
        },
        setTriggerExpression: function(r) {
            this.throwErrorIfActive(),
            this.trigger = r
        },
        isActive: function() {
            return this.stateMachine.state.isActive
        },
        isSubscribed: function() {
            return this.stateMachine.state.isSubscribed
        },
        isTriggered: function() {
            return this.stateMachine.state.isTriggered
        },
        getStatus: function() {
            return this.stateMachine.state.status
        },
        getStatusTimestamp: function() {
            return this.statusTimestamp
        },
        setItems: function(r) {
            this.throwErrorIfActive(),
            Cn.checkItemNames(r, "An item"),
            this.items = r.join(" ")
        },
        getItems: function() {
            if (this.items == null)
                throw new St(Cn.NO_GROUP_NOR_LIST);
            return this.items.split(" ")
        },
        setItemGroup: function(r) {
            this.throwErrorIfActive(),
            this.items = r == null ? null : String(r)
        },
        getItemGroup: function() {
            if (this.items == null)
                throw new St(Cn.NO_GROUP_NOR_LIST);
            return this.items
        },
        setFields: function(r) {
            this.throwErrorIfActive(),
            Cn.checkFieldNames(r, "A field"),
            this.fields = r.join(" ")
        },
        getFields: function() {
            if (this.fields == null)
                throw new St(Cn.NO_SCHEMA_NOR_LIST);
            return this.fields.split(" ")
        },
        setFieldSchema: function(r) {
            this.throwErrorIfActive(),
            this.fields = r == null ? null : String(r)
        },
        getFieldSchema: function() {
            if (this.fields == null)
                throw new St(Cn.NO_SCHEMA_NOR_LIST);
            return this.fields
        },
        setDataAdapter: function(r) {
            this.throwErrorIfActive(),
            this.adapter = r
        },
        getDataAdapter: function() {
            return this.adapter
        },
        setRequestedBufferSize: function(r) {
            this.throwErrorIfActive();
            var s = this._convertBufferSize(r);
            if (isNaN(s))
                throw new ct(Cn.MAX_BUF_EXC);
            this.requestedBufferSize = s
        },
        _convertBufferSize: function(r) {
            if (r == null)
                return -1;
            if (new String(r).toLowerCase() == "unlimited")
                return 0;
            var s = parseInt(r, 10);
            return s > 0 ? s : NaN
        },
        getRequestedBufferSize: function() {
            return this.requestedBufferSize == -1 ? null : this.requestedBufferSize == 0 ? "unlimited" : String(this.requestedBufferSize)
        },
        setRequestedMaxFrequency: function(r) {
            this.throwErrorIfActive();
            var s = this._convertFrequency(r);
            if (isNaN(s))
                throw new ct("The given value is not valid for this setting; use null, 'unlimited' or a positive number instead");
            this.requestedMaxFrequency = s
        },
        _convertFrequency: function(r) {
            if (r == null)
                return -2;
            var s = String(r).toLowerCase();
            if (s == "unlimited")
                return 0;
            var o = parseFloat(r);
            return o > 0 ? o : NaN
        },
        getRequestedMaxFrequency: function() {
            return this.requestedMaxFrequency == -2 ? null : this.requestedMaxFrequency == 0 ? "unlimited" : String(this.requestedMaxFrequency)
        },
        getMode: function() {
            return this.mode
        },
        getSubscriptionId: function() {
            return this.PN_subscriptionId
        },
        throwErrorIfActive: function() {
            if (this.stateMachine.state.isActive)
                throw new St("Cannot modify an active subscription, please unsubscribe before applying any change")
        },
        throwErrorIfInactiveOrUnsubscribing: function() {
            if (this.stateMachine.state == n.INACTIVE || this.stateMachine.state == n.UNSUBSCRIBING)
                throw new St("MpnSubscription is not active")
        }
    };
    function n(r, s, o, a, c) {
        this.isActive = r,
        this.isSubscribed = s,
        this.isTriggered = o,
        this.status = a,
        this.internalName = c
    }
    n.INACTIVE = new n(!1,!1,!1,"UNKNOWN","INACTIVE"),
    n.SUBSCRIBING = new n(!0,!1,!1,"ACTIVE","SUBSCRIBING"),
    n.SUBSCRIBED = new n(!0,!0,!1,"SUBSCRIBED","SUBSCRIBED"),
    n.TRIGGERED = new n(!0,!0,!0,"TRIGGERED","TRIGGERED"),
    n.UNSUBSCRIBING = new n(!0,!1,!1,"UNKNOWN","UNSUBSCRIBING");
    var i = function(r) {
        this.subscription = r,
        this.state = n.INACTIVE
    };
    return i.prototype = {
        subscribe: function() {
            var r = "subscribe";
            switch (this.state) {
            case n.INACTIVE:
                this.next(n.SUBSCRIBING, r);
                break;
            default:
                this.throwError(r)
            }
        },
        unsubscribe: function() {
            var r = "unsubscribe";
            switch (this.state) {
            case n.SUBSCRIBING:
            case n.SUBSCRIBED:
            case n.TRIGGERED:
                this.next(n.UNSUBSCRIBING, r);
                break;
            default:
                this.throwError(r)
            }
        },
        cancelSubscription: function() {
            var r = "cancelSubscription";
            switch (this.state) {
            case n.UNSUBSCRIBING:
                this.next(n.INACTIVE, r),
                this.subscription.dispatchEvent("onUnsubscription");
                break;
            default:
                this.throwError(r)
            }
        },
        activate: function() {
            var r = "activate";
            switch (this.state) {
            case n.SUBSCRIBING:
            case n.TRIGGERED:
                this.next(n.SUBSCRIBED, r),
                this.subscription.dispatchEvent("onSubscription");
                break;
            case n.UNSUBSCRIBING:
                this.next(n.UNSUBSCRIBING, r),
                this.subscription.dispatchEvent("onSubscription");
                break;
            case n.SUBSCRIBED:
                break;
            default:
                this.throwError(r)
            }
        },
        trigger: function() {
            var r = "trigger";
            switch (this.state) {
            case n.SUBSCRIBING:
            case n.SUBSCRIBED:
                this.next(n.TRIGGERED, r),
                this.subscription.dispatchEvent("onTriggered");
                break;
            case n.UNSUBSCRIBING:
                this.next(n.UNSUBSCRIBING, r),
                this.subscription.dispatchEvent("onSubscription");
                break;
            case n.TRIGGERED:
                break;
            default:
                this.throwError(r)
            }
        },
        onDelete: function() {
            var r = "onDelete";
            switch (this.state) {
            case n.SUBSCRIBED:
            case n.TRIGGERED:
            case n.UNSUBSCRIBING:
                this.subscription.dispatchEvent("onUnsubscription"),
                this.next(n.INACTIVE, r);
                break;
            default:
                this.throwError(r)
            }
        },
        onSubscribeError: function(r, s) {
            var o = "onREQERR";
            switch (this.state) {
            case n.SUBSCRIBING:
            case n.UNSUBSCRIBING:
                this.subscription.dispatchEvent("onSubscriptionError", [r, s]),
                this.next(n.INACTIVE, o);
                break;
            default:
                this.throwError(o)
            }
        },
        onUnsubscribeError: function(r, s) {
            var o = "onREQERR";
            switch (this.state) {
            case n.UNSUBSCRIBING:
                this.subscription.dispatchEvent("onUnsubscriptionError", [r, s]),
                this.next(n.INACTIVE, o);
                break;
            default:
                this.throwError(o)
            }
        },
        onAddSubscribed: function() {
            this.state != n.INACTIVE && this.throwError("onAddAsSubscribed"),
            this.next(n.SUBSCRIBED, "onAddAsSubscribed"),
            this.subscription.dispatchEvent("onSubscription")
        },
        onAddTriggered: function() {
            this.state != n.INACTIVE && this.throwError("onAddAsTriggered"),
            this.next(n.TRIGGERED, "onAddAsTriggered"),
            this.subscription.dispatchEvent("onTriggered")
        },
        next: function(r, s) {
            if (e.isDebugLogEnabled()) {
                var o = this.state.internalName
                  , a = r.internalName;
                e.logDebug(m.resolve(924), this.subscription.PN_subscriptionId + " on '" + s + "': " + o + " -> " + a)
            }
            var c = this.state;
            this.state = r,
            c.status != r.status && this.subscription.dispatchEvent("onStatusChanged", [this.state.status, this.subscription.statusTimestamp])
        },
        throwError: function(r) {
            var s = "Unexpected event '" + r + "' in state " + this.state.internalName + " (" + this.subscription.PN_subscriptionId + ")";
            throw e.logError(s),
            new Error(s)
        }
    },
    t.prototype.getNotificationFormat = t.prototype.getNotificationFormat,
    t.prototype.setNotificationFormat = t.prototype.setNotificationFormat,
    t.prototype.getTriggerExpression = t.prototype.getTriggerExpression,
    t.prototype.setTriggerExpression = t.prototype.setTriggerExpression,
    t.prototype.isActive = t.prototype.isActive,
    t.prototype.isSubscribed = t.prototype.isSubscribed,
    t.prototype.isTriggered = t.prototype.isTriggered,
    t.prototype.getStatus = t.prototype.getStatus,
    t.prototype.getStatusTimestamp = t.prototype.getStatusTimestamp,
    t.prototype.setItems = t.prototype.setItems,
    t.prototype.getItems = t.prototype.getItems,
    t.prototype.setItemGroup = t.prototype.setItemGroup,
    t.prototype.getItemGroup = t.prototype.getItemGroup,
    t.prototype.setFields = t.prototype.setFields,
    t.prototype.getFields = t.prototype.getFields,
    t.prototype.setFieldSchema = t.prototype.setFieldSchema,
    t.prototype.getFieldSchema = t.prototype.getFieldSchema,
    t.prototype.setDataAdapter = t.prototype.setDataAdapter,
    t.prototype.getDataAdapter = t.prototype.getDataAdapter,
    t.prototype.setRequestedBufferSize = t.prototype.setRequestedBufferSize,
    t.prototype.getRequestedBufferSize = t.prototype.getRequestedBufferSize,
    t.prototype.setRequestedMaxFrequency = t.prototype.setRequestedMaxFrequency,
    t.prototype.getRequestedMaxFrequency = t.prototype.getRequestedMaxFrequency,
    t.prototype.getMode = t.prototype.getMode,
    t.prototype.getSubscriptionId = t.prototype.getSubscriptionId,
    t.prototype.addListener = t.prototype.addListener,
    t.prototype.removeListener = t.prototype.removeListener,
    t.prototype.getListeners = t.prototype.getListeners,
    ot(t, Ru),
    t
}()
  , xx = function(e) {
    this.mpnManager = e
};
xx.prototype = {
    onSessionStart: function() {
        try {
            this.mpnManager.stateMachine.onSessionStart()
        } catch (e) {
            this.mpnManager.onFatalError(e)
        }
    },
    onSessionClose: function(e) {
        try {
            this.mpnManager.stateMachine.onSessionClose(e)
        } catch (t) {
            this.mpnManager.onFatalError(t)
        }
    },
    onRegisterOK: function(e, t) {
        try {
            this.mpnManager.stateMachine.onRegisterOK(e, t)
        } catch (n) {
            this.mpnManager.onFatalError(n)
        }
    },
    onRegisterError: function(e, t) {
        this.mpnManager.stateMachine.onRegisterError(e, t)
    },
    onSubscribeOK: function(e, t) {
        this.mpnManager.subscribeManager.onUserSubscribeOK(e, t)
    },
    onSubscribeError: function(e, t, n) {
        this.mpnManager.subscribeManager.onSubscribeError(e, t, n)
    },
    onUnsubscribeOK: function(e) {
        this.mpnManager.subscribeManager.onUnsubscribeOK(e)
    },
    onUnsubscribeError: function(e, t, n) {
        this.mpnManager.unsubscribeManager.onUnsubscribeError(e, t, n)
    }
};
var wx = function() {
    this.dismissed = !1
}
  , Yl = function(e, t, n) {
    this._callSuperConstructor(Yl, [n.lsClient.connectionOptions, e]),
    this.responseReceived = !1,
    this.tutorContext = t,
    this.mpnManager = n
};
Yl.prototype = {
    onResponse: function() {
        this.responseReceived = !0
    },
    verifySuccess: function() {
        return this.responseReceived || this.tutorContext.dismissed
    },
    notifyAbort: function() {
        this.responseReceived = !0
    }
};
ot(Yl, Xl);
var L3 = function(e, t, n) {
    this._callSuperConstructor(L3, [e, n, t])
};
L3.prototype = {
    doRecovery: function() {
        this.mpnManager.requestManager.sendRegisterRequest(this.timeoutMs)
    }
};
ot(L3, Yl);
var u1 = function() {
    this.query = {},
    this.reqId = Ke.nextRequestId(),
    this.addParam("LS_reqId", this.reqId)
};
u1.prototype = {
    addParam: function(e, t) {
        this.query[e] = encodeURIComponent(t)
    }
};
var r7 = function(e) {
    this._callSuperConstructor(r7),
    this.addParam("LS_op", "register"),
    this.addParam("PN_type", e.platform),
    this.addParam("PN_appId", e.appId),
    e.prevDeviceToken == null ? this.addParam("PN_deviceToken", e.deviceToken) : (this.addParam("PN_deviceToken", e.prevDeviceToken),
    this.addParam("PN_newDeviceToken", e.deviceToken))
};
ot(r7, u1);
var s7 = function(e, t, n) {
    this._callSuperConstructor(s7),
    this.subscriptionId = e,
    this.addParam("LS_subId", e),
    this.addParam("LS_op", "activate"),
    this.addParam("LS_group", n.items),
    this.addParam("LS_schema", n.fields),
    this.addParam("LS_mode", n.getMode()),
    this.addParam("PN_deviceId", t),
    n.getDataAdapter() != null && this.addParam("LS_data_adapter", n.getDataAdapter()),
    n.getSubscriptionId() != null && this.addParam("PN_subscriptionId", n.getSubscriptionId()),
    n.getNotificationFormat() != null && this.addParam("PN_notificationFormat", n.getNotificationFormat()),
    n.getTriggerExpression() != null && this.addParam("PN_trigger", n.getTriggerExpression()),
    n.coalescing && this.addParam("PN_coalescing", "true"),
    n.getRequestedBufferSize() != null && this.addParam("LS_requested_buffer_size", n.getRequestedBufferSize()),
    n.getRequestedMaxFrequency() != null && this.addParam("LS_requested_max_frequency", n.getRequestedMaxFrequency())
};
ot(s7, u1);
var B3 = function(e, t, n, i, r) {
    this._callSuperConstructor(B3, [e, r, i]),
    this.ephemeralSubId = t,
    this.subscription = n
};
B3.prototype = {
    doRecovery: function() {
        this.mpnManager.requestManager.sendSubscribeRequest(this.timeoutMs, this.ephemeralSubId, this.subscription)
    }
};
ot(B3, Yl);
var o7 = function(e, t) {
    this._callSuperConstructor(o7),
    this.addParam("LS_op", "deactivate"),
    this.addParam("PN_deviceId", e),
    t != "ALL" && this.addParam("PN_subscriptionStatus", t)
};
ot(o7, u1);
var r1 = function(e, t, n, i) {
    this._callSuperConstructor(r1, [e, i, n]),
    this.filter = t
};
r1.prototype = {
    doRecovery: function() {
        this.mpnManager.requestManager.sendUnsubscribeFilteredRequest(this.timeoutMs, this.filter)
    },
    onResponse: function() {
        this._callSuperMethod(r1, "onResponse"),
        this.mpnManager.requestManager.onUnsubscriptionFilterResponse(this.filter)
    }
};
ot(r1, Yl);
var a7 = function(e, t) {
    this._callSuperConstructor(a7),
    this.subscriptionId = t.getSubscriptionId(),
    this.addParam("LS_op", "deactivate"),
    this.addParam("PN_deviceId", e),
    this.addParam("PN_subscriptionId", this.subscriptionId)
};
ot(a7, u1);
var U3 = function(e, t, n, i) {
    this._callSuperConstructor(U3, [e, i, n]),
    this.subscription = t
};
U3.prototype = {
    doRecovery: function() {
        this.mpnManager.requestManager.sendUnsubscribeRequest(this.timeoutMs, this.subscription)
    }
};
ot(U3, Yl);
var Cx = function(e) {
    this.mpnManager = e,
    this.tutorContext = new wx
};
Cx.prototype = {
    createTutorContext: function() {
        this.tutorContext.dismissed = !0,
        this.tutorContext = new wx
    },
    sendRegisterRequest: function(e) {
        var t = new r7(this.mpnManager.mpnDevice)
          , n = new L3(e,this.mpnManager,this.tutorContext);
        this.mpnManager.lsClient.getLsEngine().then(function(i) {
            i.sendRegisterForMpn(t, n)
        })
    },
    sendSubscribeRequest: function(e, t, n) {
        var i = new s7(t,this.mpnManager.mpnDevice.getDeviceId(),n)
          , r = new B3(e,t,n,this.mpnManager,this.tutorContext);
        this.mpnManager.lsClient.getLsEngine().then(function(s) {
            s.sendMpnSubscription(i, r)
        })
    },
    sendUnsubscribeRequest: function(e, t) {
        var n = new a7(this.mpnManager.mpnDevice.getDeviceId(),t)
          , i = new U3(e,t,this.mpnManager,this.tutorContext);
        this.mpnManager.lsClient.getLsEngine().then(function(r) {
            r.sendMpnUnsubscription(n, i)
        })
    },
    sendUnsubscribeFilteredRequest: function(e, t) {
        var n = new o7(this.mpnManager.mpnDevice.getDeviceId(),t.filter)
          , i = new r1(e,t,this.mpnManager,this.tutorContext);
        this.mpnManager.lsClient.getLsEngine().then(function(r) {
            r.sendMpnFilteredUnsubscription(n, i)
        })
    },
    sendWaitings: function() {
        this.mpnManager.subscribeManager.subscribeWaitings(),
        this.mpnManager.unsubscribeManager.unsubscribeWaitings(),
        this.mpnManager.unsubscribeFilterManager.unsubscribeWaitings()
    },
    onUnsubscriptionFilterResponse: function(e) {
        this.mpnManager.unsubscribeFilterManager.onUnsubscribeRepsone(e)
    }
};
var Ex = function(e) {
    this.mpnManager = e
};
Ex.prototype = {
    subscribeToDEVAdapter: function() {
        var e = this;
        this.listener = {
            dismissed: !1,
            onItemUpdate: function(t) {
                if (!this.dismissed)
                    try {
                        var n = t.getValue("status")
                          , i = parseInt(t.getValue("status_timestamp"), 10);
                        e.mpnManager.mpnDevice.eventManager.onStatusChange(n, i)
                    } catch (r) {
                        e.mpnManager.onFatalError(r)
                    }
            }
        },
        this.subscription = new Bc("MERGE","DEV-" + this.mpnManager.mpnDevice.deviceId,["status", "status_timestamp"]),
        this.subscription.setDataAdapter(this.mpnManager.mpnDevice.adapterName),
        this.subscription.setRequestedMaxFrequency("unfiltered"),
        this.subscription.addListener(this.listener),
        this.mpnManager.lsClient.subscribe(this.subscription)
    },
    unsubscribeFromDEVAdapter: function() {
        this.subscription != null && (this.mpnManager.lsClient.unsubscribe(this.subscription),
        this.subscription.removeListener(this.listener),
        this.listener.dismissed = !0,
        this.subscription = null,
        this.listener = null)
    }
};
var Tx = function(e) {
    this.mpnManager = e
};
Tx.prototype = {
    subscribeToSUBSAdapter: function(e) {
        var t = this;
        this.listener = {
            dismissed: !1,
            onItemUpdate: function(n) {
                if (!this.dismissed)
                    try {
                        var i = n.getValue("command");
                        switch (i) {
                        case "UPDATE":
                            t.onUpdate(n);
                            break;
                        case "ADD":
                            t.onAdd(n);
                            break;
                        case "DELETE":
                            t.onDelete(n);
                            break
                        }
                    } catch (r) {
                        t.mpnManager.onFatalError(r)
                    }
            },
            onEndOfSnapshot: function(n, i) {
                if (!this.dismissed)
                    try {
                        t.mpnManager.subscribeManager.onEndOfSnapshot()
                    } catch (r) {
                        t.mpnManager.onFatalError(r)
                    }
            }
        },
        this.subscription = new Bc("COMMAND","SUBS-" + this.mpnManager.mpnDevice.deviceId,["key", "command"]),
        this.subscription.setDataAdapter(this.mpnManager.mpnDevice.adapterName),
        this.subscription.setRequestedMaxFrequency("unfiltered"),
        this.subscription.setCommandSecondLevelFields(["status", "status_timestamp", "notification_format", "trigger", "group", "schema", "adapter", "mode", "requested_buffer_size", "requested_max_frequency"]),
        this.subscription.setCommandSecondLevelDataAdapter(this.mpnManager.mpnDevice.adapterName),
        this.subscription.addListener(this.listener),
        this.mpnManager.lsClient.subscribe(this.subscription)
    },
    unsubscribeFromSUBSAdapter: function() {
        this.subscription != null && (this.mpnManager.lsClient.unsubscribe(this.subscription),
        this.subscription.removeListener(this.listener),
        this.listener.dismissed = !0,
        this.subscription = null,
        this.listener = null)
    },
    onUpdate: function(e) {
        var t = this
          , n = this.getSubId(e);
        this.mpnManager.subscriptions.forEachWithSubId(n, {
            onEmpty: function() {
                t.doCreateNewSubscription(n, e)
            },
            visit: function(i) {
                t.doUpdateExistingSubscription(i, e)
            }
        })
    },
    doUpdateExistingSubscription: function(e, t) {
        var n = e.needsInitialization;
        if (n || t.isValueChanged("mode")) {
            var i = t.getValue("mode");
            e.eventManager.onChangeMode(i)
        }
        if (n || t.isValueChanged("group")) {
            var r = t.getValue("group");
            e.eventManager.onChangeGroup(r)
        }
        if (n || t.isValueChanged("schema")) {
            var s = t.getValue("schema");
            e.eventManager.onChangeSchema(s)
        }
        if (n || t.isValueChanged("adapter")) {
            var o = t.getValue("adapter");
            e.eventManager.onChangeAdapter(o)
        }
        if (n || t.isValueChanged("notification_format")) {
            var a = t.getValue("notification_format");
            e.eventManager.onChangeFormat(a)
        }
        if (n || t.isValueChanged("trigger")) {
            var c = t.getValue("trigger");
            e.eventManager.onChangeTrigger(c)
        }
        if (n || t.isValueChanged("requested_buffer_size")) {
            var l = t.getValue("requested_buffer_size");
            e.eventManager.onChangeRequestedBufferSize(l)
        }
        if (n || t.isValueChanged("requested_max_frequency")) {
            var u = t.getValue("requested_max_frequency");
            e.eventManager.onChangeRequestedMaxFrequency(u)
        }
        if (n || t.isValueChanged("status_timestamp")) {
            var h = t.getValue("status_timestamp")
              , d = h == null ? 0 : parseInt(h, 10);
            e.eventManager.onChangeTimestamp(d)
        }
        if (n || t.isValueChanged("status")) {
            var f = t.getValue("status")
              , h = t.getValue("status_timestamp")
              , d = h == null ? 0 : parseInt(h, 10);
            e.eventManager.onStatusChange(f, d)
        }
        n && (e.needsInitialization = !1)
    },
    doCreateNewSubscription: function(e, t) {
        var n = t.getValue("mode")
          , i = t.getValue("group")
          , r = t.getValue("schema")
          , s = t.getValue("adapter")
          , o = t.getValue("notification_format")
          , a = t.getValue("trigger")
          , c = t.getValue("requested_buffer_size")
          , l = t.getValue("requested_max_frequency")
          , u = t.getValue("status")
          , h = parseInt(t.getValue("status_timestamp"), 10)
          , d = new ZF(n);
        d.eventManager.onChangeGroup(i),
        d.eventManager.onChangeSchema(r),
        d.eventManager.onChangeAdapter(s),
        d.eventManager.onChangeFormat(o),
        d.eventManager.onChangeTrigger(a),
        d.eventManager.onChangeRequestedBufferSize(c),
        d.eventManager.onChangeRequestedMaxFrequency(l),
        d.eventManager.setSubscriptionId(e),
        d.eventManager.simulateSubscribe(u, h),
        d.needsInitialization = !1,
        this.mpnManager.subscribeManager.onServerSubscribeOK(e, d)
    },
    onDelete: function(e) {
        var t = this.getSubId(e);
        this.mpnManager.subscribeManager.onDelete(t)
    },
    onAdd: function(e) {
        var t = this.getSubId(e);
        this.mpnManager.subscribeManager.onAddedSubscription(t)
    },
    getSubId: function(e) {
        var t = e.getValue("key");
        return t.substring(4)
    }
};
function c7() {
    this.ls = []
}
c7.prototype = {
    add: function(e) {
        this.ls.push(e)
    },
    addAll: function(e) {
        for (var t = 0, n = e.size(); t < n; t++)
            this.add(e.get(t))
    },
    remove: function(e) {
        for (var t = 0, n = this.ls.length; t < n; t++)
            if (this.ls[t] == e)
                return this.ls.splice(t, 1),
                !0;
        return !1
    },
    contains: function(e) {
        for (var t = 0, n = this.ls.length; t < n; t++)
            if (this.ls[t] == e)
                return !0;
        return !1
    },
    clear: function() {
        this.ls.splice(0)
    },
    get: function(e) {
        return this.ls[e]
    },
    getLast: function() {
        return this.ls.length == 0 ? null : this.ls[this.ls.length - 1]
    },
    size: function() {
        return this.ls.length
    },
    isEmpty: function() {
        return this.ls.length == 0
    },
    toArray: function() {
        return this.ls
    }
};
function Ox() {
    this.map = {}
}
Ox.prototype = {
    get: function(e) {
        return this.map[e]
    },
    put: function(e, t) {
        this.map[e] = t
    },
    remove: function(e) {
        var t = this.map[e];
        return delete this.map[e],
        t
    },
    clear: function() {
        for (var e in this.map)
            delete this.map[e]
    },
    containsKey: function(e) {
        return this.get(e) != null
    },
    values: function() {
        var e = new c7;
        for (var t in this.map)
            e.add(this.map[t]);
        return e
    }
};
function Px() {
    this.set = {},
    this.size = 0
}
Px.prototype = {
    add: function(e) {
        this.set[e] || (this.set[e] = !0,
        this.size++)
    },
    remove: function(e) {
        var t = !!this.set[e];
        return t && (delete this.set[e],
        this.size--),
        t
    },
    contains: function(e) {
        return !!this.set[e]
    },
    clear: function() {
        for (var e in this.set)
            delete this.set[e];
        this.size = 0
    },
    isEmpty: function() {
        return this.size == 0
    }
};
var oo = {
    MyList: c7,
    MyMap: Ox,
    MySet: Px
}
  , Mx = function() {
    this.pendings = new oo.MyMap
};
Mx.prototype = {
    put: function(e, t) {
        this.pendings.put(e, new kx(t))
    },
    remove: function(e) {
        var t = this.pendings.remove(e);
        return t
    },
    values: function() {
        for (var e = new oo.MyList, t = this.pendings.values(), n = 0, i = t.size(); n < i; n++) {
            var r = t.get(n);
            e.add(r.subscription)
        }
        return e
    },
    clear: function() {
        this.pendings.clear()
    },
    getPendingRequest: function(e) {
        for (var t = this.pendings.values(), n = 0, i = t.size(); n < i; n++) {
            var r = t.get(n);
            if (r.subscription == e)
                return r
        }
        return null
    }
};
var kx = function(e) {
    this.subscription = e,
    this.handler = null
};
kx.prototype = {
    setOnCompleteHandler: function(e) {
        jt.assert(this.handler == null),
        this.handler = e
    },
    onComplete: function(e) {
        this.handler != null && (this.handler.onComplete(e),
        this.handler = null)
    }
};
var Ta = m.getLoggerProxy(G.MPN)
  , Ax = function(e) {
    this.mpnManager = e,
    this.state = w3,
    this.expectedSubIds = new oo.MySet
};
Ax.prototype = {
    reset: function() {
        this.next(w3, "reset"),
        this.expectedSubIds.clear()
    },
    onNewServerSubscription: function(e) {
        switch (Ta.isDebugLogEnabled() && Ta.debug("Server subscription added subId=" + e),
        this.state) {
        case w3:
            this.expectedSubIds.add(e),
            this.next(y3, "ADD");
            break;
        case y3:
            this.expectedSubIds.add(e);
            break;
        case Kd:
        case b3:
            break;
        default:
            this.throwError("onNewServerSubscription (subId=" + e + ")")
        }
    },
    onEndOfSnapshot: function() {
        switch (this.state) {
        case w3:
            this.fireOnSubscriptionsUpdated("empty EOS"),
            this.next(b3, "EOS");
            break;
        case y3:
            this.expectedSubIds.isEmpty() ? (this.next(Kd, "EOS"),
            this.onEmpty()) : this.next(Kd, "EOS");
            break;
        default:
            this.throwError("onEndOfSnapshot")
        }
    },
    onSeverSubscriptionOK: function(e) {
        switch (Ta.isDebugLogEnabled() && Ta.debug("Server subscription subscribed subId=" + e),
        this.state) {
        case y3:
            this.expectedSubIds.remove(e);
            break;
        case Kd:
            this.expectedSubIds.remove(e),
            this.expectedSubIds.isEmpty() && this.onEmpty();
            break;
        case b3:
            this.fireOnSubscriptionsUpdated("UPD");
            break;
        default:
            this.throwError("onSeverSubscriptionOK (subId=" + e + ")")
        }
    },
    onEmpty: function() {
        switch (this.state) {
        case Kd:
            this.fireOnSubscriptionsUpdated("EOS"),
            this.next(b3, "EMPTY");
            break;
        default:
            this.throwError("onEmpty")
        }
    },
    fireOnSubscriptionsUpdated: function(e) {
        Ta.isDebugLogEnabled() && Ta.debug("onSubscriptionsUpdated (" + this.mpnManager.getDeviceId() + ") fired event=" + e),
        this.mpnManager.mpnDevice != null && this.mpnManager.mpnDevice.eventManager.onSubscriptionsUpdated()
    },
    next: function(e, t) {
        Ta.isDebugLogEnabled() && Ta.debug("OnSubscriptionsUpdated state change (" + this.mpnManager.getDeviceId() + ") on '" + t + "': " + this.state.name + " -> " + e.name),
        this.state = e
    },
    throwError: function(e) {
        var t = "Unexpected event '" + e + "' in state " + this.state.name + " (" + this.mpnManager.getDeviceId() + ")";
        throw Ta.logError(t),
        new Error(t)
    }
};
function H3(e) {
    this.name = e
}
var w3 = new H3("INIT")
  , y3 = new H3("NOT_EMPTY")
  , Kd = new H3("EOS")
  , b3 = new H3("DONE")
  , xu = m.getLoggerProxy(G.MPN)
  , Ix = function(e) {
    this.mpnManager = e,
    this.pendings = new Mx,
    this.waitings = new oo.MyList,
    this.onSubUpdEventManager = new Ax(e)
};
Ix.prototype = {
    reset: function() {
        this.mpnManager.subscriptions.clear(),
        this.pendings.clear(),
        this.waitings.clear(),
        this.onSubUpdEventManager.reset()
    },
    addWaiting: function(e) {
        this.waitings.add(e)
    },
    removeWaiting: function(e) {
        return this.waitings.remove(e)
    },
    subscribeWaitings: function() {
        for (var e = this.waitings.size(), t = 0; t < e; t++) {
            var n = this.waitings.get(t);
            this.subscribe(n)
        }
        this.waitings.clear()
    },
    getPendingRequest: function(e) {
        return this.pendings.getPendingRequest(e)
    },
    subscribe: function(e) {
        var t = Ke.nextSubscriptionId();
        this.pendings.put(t, e),
        this.mpnManager.requestManager.sendSubscribeRequest(0, t, e)
    },
    onEndOfSnapshot: function() {
        this.onSubUpdEventManager.onEndOfSnapshot()
    },
    onSubscribeError: function(e, t, n) {
        var i = this.pendings.remove(e);
        if (i == null) {
            xu.warn("Discarded unexpected subscription error subId=" + e);
            return
        }
        var r = i.subscription;
        r.eventManager.onSubscribeError(t, n),
        i.onComplete(!1)
    },
    onUserSubscribeOK: function(e, t) {
        var n = this.pendings.remove(e);
        if (n == null) {
            xu.warn("Discarded unexpected subscription: subId=" + e);
            return
        }
        var i = n.subscription;
        this.mpnManager.subscriptions.add(t, i),
        i.eventManager.onSubscribeOK(t),
        this.onSubUpdEventManager.fireOnSubscriptionsUpdated("MPNOK"),
        n.onComplete(!0)
    },
    onServerSubscribeOK: function(e, t) {
        this.mpnManager.subscriptions.add(e, t),
        this.onSubUpdEventManager.onSeverSubscriptionOK(e)
    },
    onAddedSubscription: function(e) {
        this.mpnManager.subscriptions.isSubscribed(e) || this.onSubUpdEventManager.onNewServerSubscription(e)
    },
    onUnsubscribeOK: function(e) {
        xu.isDebugLogEnabled() && xu.debug("MPNDEL subId=" + e),
        this.mpnManager.unsubscribeManager.onUnsubscribeOK(e)
    },
    onDelete: function(e) {
        var t = this;
        this.mpnManager.subscriptions.remove(e, {
            onEmpty: function() {
                xu.warn("MpnSubscription not found subId=" + e)
            },
            visit: function(n) {
                n.eventManager.simulateUnsubscribe()
            },
            afterVisit: function() {
                t.onSubUpdEventManager.fireOnSubscriptionsUpdated("DELETE")
            }
        })
    },
    onUnsubscribeError: function(e, t, n) {
        var i = this;
        this.mpnManager.subscriptions.remove(e, {
            onEmpty: function() {
                xu.warn("MPN subscription not found subId=" + e)
            },
            visit: function(r) {
                r.eventManager.onUnsubscribeError(t, n)
            },
            afterVisit: function() {
                i.onSubUpdEventManager.fireOnSubscriptionsUpdated("REQERR")
            }
        })
    },
    onSessionClose: function(e) {
        e ? (this.waitings.addAll(this.pendings.values()),
        this.pendings.clear()) : (this.waitings.clear(),
        this.pendings.clear(),
        this.mpnManager.subscriptions.clear(),
        this.onSubUpdEventManager.fireOnSubscriptionsUpdated("Session close")),
        this.onSubUpdEventManager.reset()
    }
};
var Rx = function() {
    this.subscriptions = new oo.MyMap
};
Rx.prototype = {
    getSubscriptions: function(e) {
        for (var t = new oo.MyList, n = e == null || e == "ALL", i = this.subscriptions.values(), r = 0, s = i.size(); r < s; r++) {
            var o = i.get(r)
              , a = o.getLast();
            (n || a.getStatus() == e) && t.add(a)
        }
        return t
    },
    findSubscription: function(e) {
        var t = this.subscriptions.get(e);
        return t == null ? null : t.getLast()
    },
    isSubscribed: function(e) {
        return this.subscriptions.containsKey(e)
    },
    add: function(e, t) {
        var n = this.subscriptions.get(e);
        n == null && (n = new oo.MyList,
        this.subscriptions.put(e, n)),
        n.add(t)
    },
    remove: function(e, t) {
        var n = this.subscriptions.remove(e);
        this.forEach(n, t)
    },
    clear: function() {
        this.subscriptions.clear()
    },
    forEachWithSubId: function(e, t) {
        var n = this.subscriptions.get(e);
        this.forEach(n, t)
    },
    forEach: function(e, t) {
        if (e != null && !e.isEmpty()) {
            if (t.visit != null)
                for (var n = 0, i = e.size(); n < i; n++) {
                    var r = e.get(n);
                    t.visit(r)
                }
            t.afterVisit != null && t.afterVisit()
        } else
            t.onEmpty != null && t.onEmpty()
    }
};
function Dx(e) {
    e != null && (e = e.toUpperCase()),
    e == null ? e = "ALL" : e == "SUBSCRIBED" && (e = "ACTIVE"),
    this.filter = e
}
var Nx = function(e) {
    this.mpnManager = e,
    this.pendings = new oo.MyList,
    this.waitings = new oo.MyList
};
Nx.prototype = {
    reset: function() {
        this.pendings.clear(),
        this.waitings.clear()
    },
    addWaiting: function(e) {
        this.waitings.add(new Dx(e))
    },
    unsubscribeWaitings: function() {
        for (var e = 0, t = this.waitings.size(); e < t; e++) {
            var n = this.waitings.get(e);
            this.unsubscribe(n)
        }
        this.waitings.clear()
    },
    unsubscribe: function(e) {
        jt.assert(!this.pendings.contains(e)),
        this.pendings.add(e),
        this.mpnManager.requestManager.sendUnsubscribeFilteredRequest(0, e)
    },
    onUnsubscribeRepsone: function(e) {
        var t = this.pendings.remove(e);
        jt.assert(t)
    },
    onSessionClose: function(e) {
        e ? (this.waitings.addAll(this.pendings),
        this.pendings.clear()) : (this.waitings.clear(),
        this.pendings.clear())
    }
};
var eL = m.getLoggerProxy(G.MPN)
  , Fx = function(e) {
    this.mpnManager = e,
    this.pendings = new oo.MyMap,
    this.waitings = new oo.MyList
};
Fx.prototype = {
    reset: function() {
        this.pendings.clear(),
        this.waitings.clear()
    },
    addWaiting: function(e) {
        this.waitings.add(e)
    },
    unsubscribeWaitings: function() {
        for (var e = 0, t = this.waitings.size(); e < t; e++) {
            var n = this.waitings.get(e);
            this.unsubscribe(n)
        }
        this.waitings.clear()
    },
    unsubscribe: function(e) {
        var t = e.getSubscriptionId();
        jt.assert(t != null),
        jt.assert(!this.pendings.containsKey(t)),
        this.pendings.put(t, e),
        this.mpnManager.requestManager.sendUnsubscribeRequest(0, e)
    },
    onUnsubscribeOK: function(e) {
        this.pendings.remove(e)
    },
    onUnsubscribeError: function(e, t, n) {
        var i = this.pendings.remove(e);
        if (i == null) {
            eL.warn("Discarded unexpected unsubscription error subId=" + e);
            return
        }
        this.mpnManager.subscribeManager.onUnsubscribeError(e, t, n)
    },
    onSessionClose: function(e) {
        e ? (this.waitings.addAll(this.pendings.values()),
        this.pendings.clear()) : (this.waitings.clear(),
        this.pendings.clear())
    }
};
var Bg = m.getLoggerProxy(G.MPN);
function Lx(e) {
    this.lsClient = e,
    this.stateMachine = new rt(this),
    this.requestManager = new Cx(this),
    this.eventManager = new xx(this),
    this.dev_manager = new Ex(this),
    this.subs_manager = new Tx(this),
    this.subscribeManager = new Ix(this),
    this.subscriptions = new Rx,
    this.unsubscribeManager = new Fx(this),
    this.unsubscribeFilterManager = new Nx(this)
}
Lx.prototype = {
    registerForMpn: function(e) {
        this.stateMachine.register(e)
    },
    subscribe: function(e, t) {
        try {
            e.eventManager.onSubscribe(t),
            this.stateMachine.subscribe(e)
        } catch (n) {
            this.onFatalError(n)
        }
    },
    unsubscribe: function(e) {
        e.throwErrorIfInactiveOrUnsubscribing();
        try {
            e.eventManager.onUnsubscribe(),
            this.stateMachine.unsubscribe(e)
        } catch (t) {
            this.onFatalError(t)
        }
    },
    unsubscribeFilter: function(e) {
        this.stateMachine.unsubscribeFilter(e)
    },
    getSubscriptions: function(e) {
        return this.subscriptions.getSubscriptions(e)
    },
    findSubscription: function(e) {
        return this.subscriptions.findSubscription(e)
    },
    getDeviceId: function() {
        return this.mpnDevice == null ? null : this.mpnDevice.deviceId
    },
    onFatalError: function(e) {
        this.lsClient.getLsEngine().then(function(t) {
            t.onFatalError(e)
        })
    }
};
var rt = function(e) {
    this.mpnManager = e,
    this.state = 0
};
rt.NO_SESSION = 0;
rt.SESSION_OK = 1;
rt.READY = 2;
rt.REGISTERING = 3;
rt.REGISTERED = 4;
rt.NAMES = [];
rt.NAMES[rt.NO_SESSION] = "NO_SESSION";
rt.NAMES[rt.SESSION_OK] = "SESSION_OK";
rt.NAMES[rt.READY] = "READY";
rt.NAMES[rt.REGISTERING] = "REGISTERING";
rt.NAMES[rt.REGISTERED] = "REGISTERED";
rt.prototype = {
    onSessionStart: function() {
        var e = "onSessionStart";
        switch (this.state) {
        case rt.NO_SESSION:
            this.next(rt.SESSION_OK, e);
            break;
        case rt.READY:
            this.mpnManager.requestManager.sendRegisterRequest(0),
            this.next(rt.REGISTERING, e);
            break;
        default:
            this.throwError(e)
        }
    },
    onSessionClose: function(e) {
        var t = "onSessionClose";
        switch (this.mpnManager.dev_manager.unsubscribeFromDEVAdapter(),
        this.mpnManager.subs_manager.unsubscribeFromSUBSAdapter(),
        this.mpnManager.requestManager.createTutorContext(),
        this.mpnManager.subscribeManager.onSessionClose(e),
        this.mpnManager.unsubscribeManager.onSessionClose(e),
        this.mpnManager.unsubscribeFilterManager.onSessionClose(e),
        this.mpnManager.mpnDevice != null && this.mpnManager.mpnDevice.eventManager.onSessionClose(e),
        this.state) {
        case rt.NO_SESSION:
            this.next(rt.NO_SESSION, t);
            break;
        case rt.SESSION_OK:
            this.next(rt.NO_SESSION, t);
            break;
        case rt.READY:
            this.next(rt.READY, t);
            break;
        case rt.REGISTERING:
            this.next(rt.READY, t);
            break;
        case rt.REGISTERED:
            this.next(rt.READY, t);
            break
        }
    },
    register: function(e) {
        var t = "register";
        switch (this.state) {
        case rt.NO_SESSION:
            this.resetDevice(e),
            this.next(rt.READY, t);
            break;
        case rt.SESSION_OK:
            this.resetDevice(e),
            this.mpnManager.requestManager.sendRegisterRequest(0),
            this.next(rt.REGISTERING, t);
            break;
        case rt.READY:
            this.resetDevice(e),
            this.next(rt.READY, t);
            break;
        case rt.REGISTERING:
            this.resetDevice(e),
            this.mpnManager.requestManager.sendRegisterRequest(0),
            this.next(rt.REGISTERING, t);
            break;
        case rt.REGISTERED:
            this.resetDevice(e),
            this.mpnManager.requestManager.sendRegisterRequest(0),
            this.next(rt.REGISTERING, t);
            break
        }
    },
    onRegisterOK: function(e, t) {
        var n = "onRegisterOK";
        switch (this.state) {
        case rt.REGISTERING:
            this.mpnManager.mpnDevice.eventManager.onRegisterOK(e, t),
            this.mpnManager.requestManager.sendWaitings(),
            this.mpnManager.dev_manager.subscribeToDEVAdapter(),
            this.mpnManager.subs_manager.subscribeToSUBSAdapter(),
            this.next(rt.REGISTERED, n);
            break;
        case rt.REGISTERED:
            break;
        default:
            this.throwError(n)
        }
    },
    onRegisterError: function(e, t) {
        var n = "onRegisterError";
        switch (this.state) {
        case rt.REGISTERING:
            this.mpnManager.mpnDevice.eventManager.onRegisterError(e, t),
            this.next(rt.SESSION_OK, n);
            break;
        default:
            this.throwError(n)
        }
    },
    subscribe: function(e) {
        switch (this.state) {
        case rt.REGISTERED:
            this.mpnManager.subscribeManager.subscribe(e);
            break;
        default:
            this.mpnManager.subscribeManager.addWaiting(e)
        }
    },
    unsubscribe: function(e) {
        switch (this.state) {
        case rt.REGISTERED:
            var t = this.mpnManager.subscribeManager.getPendingRequest(e);
            if (t == null)
                this.mpnManager.unsubscribeManager.unsubscribe(e);
            else {
                var n = this;
                t.setOnCompleteHandler({
                    onComplete: function(r) {
                        r && n.mpnManager.unsubscribeManager.unsubscribe(e)
                    }
                })
            }
            break;
        default:
            var i = this.mpnManager.subscribeManager.removeWaiting(e);
            i ? e.eventManager.cancelSubscription() : this.mpnManager.unsubscribeManager.addWaiting(e)
        }
    },
    unsubscribeFilter: function(e) {
        switch (this.state) {
        case rt.REGISTERED:
            this.mpnManager.unsubscribeFilterManager.unsubscribe(new Dx(e));
            break;
        default:
            this.mpnManager.unsubscribeFilterManager.addWaiting(e)
        }
    },
    resetDevice: function(e) {
        this.mpnManager.dev_manager.unsubscribeFromDEVAdapter(),
        this.mpnManager.subs_manager.unsubscribeFromSUBSAdapter(),
        this.mpnManager.requestManager.createTutorContext(),
        this.mpnManager.subscribeManager.reset(),
        this.mpnManager.unsubscribeManager.reset(),
        this.mpnManager.unsubscribeFilterManager.reset(),
        this.mpnManager.mpnDevice = e
    },
    next: function(e, t) {
        if (Bg.isDebugLogEnabled()) {
            var n = rt.NAMES[this.state]
              , i = rt.NAMES[e];
            Bg.logDebug(m.resolve(925), this.mpnManager.getDeviceId(), "on '" + t + "': " + n + " -> " + i)
        }
        this.state = e
    },
    throwError: function(e) {
        var t = "Unexpected event '" + e + "' in state " + rt.NAMES[this.state] + " (" + this.mpnManager.getDeviceId() + ")";
        throw Bg.logError(t),
        new Error(t)
    }
};
var G3 = function() {
    var e = m.getLoggerProxy(G.ACTIONS)
      , t = m.getLoggerProxy(G.SHARING)
      , n = 0
      , i = new RegExp("^[a-zA-Z0-9_]*$")
      , r = "The given sequence name is not valid, use only alphanumeric characters plus underscore, or null"
      , s = "Configure the server address before trying to connect"
      , o = function(a, c) {
        this.C = o,
        this._callSuperConstructor(o),
        this.connectionOptions = new ae,
        this.connectionDetails = new ln,
        this.connectionOptions = this.connectionOptions,
        this.connectionDetails = this.connectionDetails,
        this.connectionSharing = zF(this),
        this._configuration = new o1,
        this._policy = this.connectionOptions,
        this._connection = this.connectionDetails,
        a && this._connection.setServerAddress(a),
        c && this._connection.setAdapterSet(c),
        this._configuration.setBroadcaster(this),
        this._policy.setBroadcaster(this),
        this._connection.setBroadcaster(this),
        this.tables = new jS(this._policy),
        this.engineHandler = null,
        this.sharing = null,
        this.sharingPhase = 0,
        this.enableSharingPhase = 0,
        this.uID = ++n,
        this.messages = new $S,
        this.lastEngineStatus = G.DISCONNECTED,
        this.checkEngineTask = null,
        this.usedEngines = {},
        Bt.addUnloadHandler(this),
        this.mpnManager = new Lx(this)
    };
    return o.addCookies = function(a, c) {
        vt.isNodeJS() && En.addGlobalCookiesForNode(a, c)
    }
    ,
    o.getCookies = function(a) {
        if (vt.isNodeJS()) {
            var c = En.getGlobalCookiesForNode(a)
              , l = [];
            return c.forEach(function(u, h, d) {
                l.push(u.toString())
            }),
            l
        }
    }
    ,
    o.setLoggerProvider = function(a) {
        m.setLoggerProvider(a)
    }
    ,
    o.LIB_NAME = G.LIBRARY_TAG,
    o.LIB_VERSION = G.LIBRARY_VERSION + " build " + G.BUILD,
    o.simulateSilence = function(a) {
        k3.simulateSilence(a)
    }
    ,
    o.prototype = {
        toString: function() {
            return ["[", "LightstreamerClient", this.uID, this.statusPhase, this.initPhase, "]"].join("|")
        },
        getTablesHandler: function() {
            return this.tables
        },
        getMessageProxy: function() {
            return this.messages
        },
        getEngineHandler: function() {
            return this.engineHandler
        },
        setEngineHandler: function(a) {
            this.engineHandler = a,
            this.tables.switchEngineHandler(a),
            this.messages.switchEngineHandler(a),
            this.setEnginePhase = this.enableSharingPhase,
            this.checkEngineTask = Se.addRepetitiveTask(a.checkDeath, 5e3, a)
        },
        clearEngineHandler: function() {
            this.engineHandler && (this.usedEngines[this.engineHandler.getEngineId()] = !0,
            this.tables.switchEngineHandler(null),
            this.messages.switchEngineHandler(null),
            this.checkEngineTask && (Se.stopRepetitiveTask(this.checkEngineTask),
            this.checkEngineTask = null),
            this.engineHandler.dispose(),
            this.engineHandler = null,
            this.master && (this.master.dispose(),
            this.master = null),
            this._configuration.connectionRequested ? this.cacheEngineStatus(G.WILL_RETRY) : this.cacheEngineStatus(G.DISCONNECTED)),
            this.search && (this.search.stop(),
            this.search = null)
        },
        broadcastSetting: function(a, c, l) {
            return this.engineHandler && this.engineHandler.onClientConfigurationChange(a, c, l),
            !0
        },
        notifyOptionChange: function(a, c) {
            c != this._configuration && this.dispatchEvent("onPropertyChange", [a])
        },
        enableSharing: function(a) {
            if (this.mpnRequested)
                throw new St("Sharing is not available when MPN is enabled");
            var c = vt.isBrowser() ? navigator.userAgent.toLowerCase() : null;
            if (c != null && (c.indexOf("ucbrowser") != -1 || c.indexOf("ubrowser") != -1)) {
                t.logInfo(m.resolve(926));
                return
            }
            this.enableSharingPhase++,
            Se.addTimedTask(this.enableSharingExec, 0, this, [a, this.enableSharingPhase]),
            this.sharingRequested = a != null
        },
        enableSharingExec: function(a, c) {
            if (c == this.enableSharingPhase)
                if (this.sharingPhase++,
                this.clearEngineHandler(),
                this.sharing = a,
                a && !a.isPossible() && t.logInfo(m.resolve(927)),
                a && a.isPossible()) {
                    var c = this.sharingPhase
                      , l = this
                      , u = a.findEngine(this);
                    this.search = u,
                    this.search.find(this.usedEngines).then(function(d) {
                        c == l.sharingPhase && (l.search.noHope == !0 && l.sharing.noHope(),
                        d === null ? l.setupOwnEngine(c, u.getCheckedEngineList()) : l.setEngineHandler(d))
                    }, function() {
                        c == l.sharingPhase && l.dispatchEvent("onShareAbort")
                    })
                } else
                    a == null && this._configuration.connectionRequested && this.setupOwnEngine()
        },
        engineMourningRoom: function(a, c) {
            if (this.setEnginePhase == this.enableSharingPhase) {
                if (this.clearEngineHandler(),
                Bt.isUnloading() || Bt.isUnloaded()) {
                    e.logInfo(m.resolve(928));
                    return
                }
                if (!this.sharing) {
                    ut.fail(),
                    e.logError(m.resolve(929));
                    return
                }
                e.logInfo(m.resolve(930));
                var l = null;
                this._configuration.clientsCount <= 2 || (a ? l = 1e4 : (l = 200 + Et.randomG(this._configuration.clientsCount) * 500,
                l > 5e3 && (l = 5e3)));
                var u = this.sharing.convertToElectionVersion(l, c);
                this.enableSharingExec(u, this.setEnginePhase)
            }
        },
        unloadEvent: function() {
            this.disconnect(),
            this.engineHandler && this.engineHandler.clientDeath()
        },
        setupOwnEngine: function(a, c) {
            if (!(a && a != this.sharingPhase))
                return this.setEngineHandler(new zl(this)),
                this.master = new ax(this._configuration,this._policy,this._connection,this.sharing,this.engineHandler,c,this.mpnManager),
                this.engineHandler.setEngineId(this.master.getEngineId()),
                this.engineHandler.setSessionPhase(this.master.getSessionPhase()),
                this.engineHandler
        },
        isMaster: function() {
            return this.master != null
        },
        connect: function() {
            if (!this._connection.serverAddress)
                throw new St(s);
            e.logInfo(m.resolve(931)),
            Se.addTimedTask(this.asynchConnect, 0, this)
        },
        asynchConnect: function() {
            if (!(this.lastEngineStatus && this.lastEngineStatus != G.DISCONNECTED)) {
                (this.sharing == null || !this.sharing.isPossible()) && !this.master && this.setupOwnEngine(),
                e.logDebug(m.resolve(932)),
                this._configuration.simpleSetter("connectionRequested", !0);
                var a = this.getEngineHandler();
                a && a.callConnect()
            }
        },
        disconnect: function() {
            e.logInfo(m.resolve(933)),
            Se.addTimedTask(this.asynchDisconnect, 0, this)
        },
        asynchDisconnect: function() {
            e.logDebug(m.resolve(934)),
            this._configuration.simpleSetter("connectionRequested", !1);
            var a = this.getEngineHandler();
            a && a.callDisconnect()
        },
        getStatus: function() {
            return this.lastEngineStatus
        },
        sendMessage: function(a, c, l, u, h) {
            if (!c)
                c = G._UNORDERED_MESSAGES;
            else if (!i.test(c))
                throw new ct(r);
            l || l == 0 ? l = this.checkPositiveNumber(l, !0) : l = null,
            h = this.checkBool(h, !0),
            Se.addTimedTask(this.asyncSendMessage, 0, this, [a, c, u, l, h])
        },
        asyncSendMessage: function(a, c, l, u, h) {
            this.engineHandler && this.engineHandler.isSessionAlive() ? this.messages.forwardMessage(a, c, l, u) : h ? this.messages.enqueueMessage(a, c, l, u) : l && this.messages.fireEvent("onAbort", l, [a, !1])
        },
        serverError: function(a, c) {
            this.dispatchEvent("onServerError", [a, c])
        },
        sessionEnd: function() {
            this.getTablesHandler().pauseAllTables(),
            this.getMessageProxy().cleanMessageListeners()
        },
        sessionStart: function() {
            this.getTablesHandler().handleAllWaitingTables(),
            this.getMessageProxy().handleAllWaitingMessages(),
            this.getLsEngine().resolve(this.master)
        },
        cacheEngineStatus: function(a) {
            a != this.lastEngineStatus && (this.lastEngineStatus = a,
            this.dispatchEvent("onStatusChange", [a]))
        },
        sendLog: function(a) {
            return this.engineHandler && this.engineHandler.isSessionAlive() ? (this.engineHandler.forwardLog(a),
            !0) : !1
        },
        onServerKeepalive: function() {
            this.dispatchEvent("onServerKeepalive")
        },
        getSubscriptions: function() {
            var a = []
              , c = this.tables.getAllTables();
            for (var l in c)
                c[l].isSubTable() || a.push(c[l]);
            return a
        },
        subscribe: function(a) {
            this.tables.addATable(a)
        },
        unsubscribe: function(a) {
            this.tables.removeATable(a)
        },
        addListener: function(a) {
            this._callSuperMethod(o, "addListener", [a])
        },
        removeListener: function(a) {
            this._callSuperMethod(o, "removeListener", [a])
        },
        getListeners: function() {
            return this._callSuperMethod(o, "getListeners")
        },
        getLsEngine: function() {
            return this.lsEnginePromise == null && (this.lsEnginePromise = Ke.defer()),
            this.lsEnginePromise
        },
        registerForMpn: function(a) {
            if (this.sharingRequested)
                throw new St("MPN is not available when sharing is enabled");
            if (a == null)
                throw new ct("Device cannot be null");
            this.mpnDevice = a,
            this.mpnManager.registerForMpn(a),
            this.mpnRequested = !0
        },
        subscribeMpn: function(a, c) {
            if (a == null)
                throw new ct("MpnSubscription is null");
            if (a.fields == null)
                throw new ct("Invalid MpnSubscription, please specify a field list or field schema");
            if (a.items == null)
                throw new ct("Invalid MpnSubscription, please specify an item list or item group");
            if (a.getNotificationFormat() == null)
                throw new ct("Invalid MpnSubscription, please specify a notification format");
            if (a.isActive())
                throw new St("MpnSubscription is already active");
            if (this.mpnDevice == null)
                throw new St("No MPN device registered");
            c = !!c,
            this.mpnManager.subscribe(a, c)
        },
        unsubscribeMpn: function(a) {
            if (!a.isActive())
                throw new St("MpnSubscription is not active");
            if (this.mpnDevice == null)
                throw new St("No MPN device registered");
            this.mpnManager.unsubscribe(a)
        },
        unsubscribeMpnSubscriptions: function(a) {
            if (!(a == null || a == "ALL" || a == "SUBSCRIBED" || a == "TRIGGERED"))
                throw new ct("The given value is not valid for this setting. Use null, ALL, TRIGGERED or SUBSCRIBED instead");
            if (this.mpnDevice == null)
                throw new St("No MPN device registered");
            this.mpnManager.unsubscribeFilter(a)
        },
        getMpnSubscriptions: function(a) {
            if (!(a == null || a == "ALL" || a == "SUBSCRIBED" || a == "TRIGGERED"))
                throw new ct("The given value is not valid for this setting. Use null, ALL, TRIGGERED or SUBSCRIBED instead");
            if (this.mpnDevice == null)
                throw new St("No MPN device registered");
            var c = this.mpnManager.getSubscriptions(a);
            return c.toArray()
        },
        findMpnSubscription: function(a) {
            if (a == null)
                throw new ct("Subscription id must be not null");
            return this.mpnManager.findSubscription(a)
        },
        handleRemoteAdapterStatus: function(a, c, l, u) {
            this.connectionOptions.installRemoteAdapterStatusObserver(a, c, l, u);
            var h = new Bc("MERGE",l,["status"]);
            h.setDataAdapter(c),
            h.setRequestedSnapshot("yes");
            var d = this;
            h.addListener({
                onItemUpdate: function(f) {
                    var g = f.getValue("status");
                    if (console.log("STATUS", g),
                    g && g != "connected") {
                        var p = d.getEngineHandler();
                        p && p.callDisconnectAndReconnect()
                    }
                }
            }),
            Se.addTimedTask(this.subscribe, 0, this, [h])
        }
    },
    o.__restoreWs = qn.restoreClass,
    o.__disableWs = qn.disableClass,
    o.__handleError5 = G.handleError5,
    o.addCookies = o.addCookies,
    o.getCookies = o.getCookies,
    o.setLoggerProvider = o.setLoggerProvider,
    o.LIB_NAME = o.LIB_NAME,
    o.LIB_VERSION = o.LIB_VERSION,
    o.prototype.connect = o.prototype.connect,
    o.prototype.disconnect = o.prototype.disconnect,
    o.prototype.getStatus = o.prototype.getStatus,
    o.prototype.sendMessage = o.prototype.sendMessage,
    o.prototype.getSubscriptions = o.prototype.getSubscriptions,
    o.prototype.subscribe = o.prototype.subscribe,
    o.prototype.unsubscribe = o.prototype.unsubscribe,
    o.prototype.addListener = o.prototype.addListener,
    o.prototype.removeListener = o.prototype.removeListener,
    o.prototype.getListeners = o.prototype.getListeners,
    o.prototype.registerForMpn = o.prototype.registerForMpn,
    o.prototype.subscribeMpn = o.prototype.subscribeMpn,
    o.prototype.unsubscribeMpn = o.prototype.unsubscribeMpn,
    o.prototype.unsubscribeMpnSubscriptions = o.prototype.unsubscribeMpnSubscriptions,
    o.prototype.findMpnSubscription = o.prototype.findMpnSubscription,
    o.prototype.getMpnSubscriptions = o.prototype.getMpnSubscriptions,
    o.prototype.handleRemoteAdapterStatus = o.prototype.handleRemoteAdapterStatus,
    o.prototype.enableSharing = o.prototype.enableSharing,
    o.prototype.isMaster = o.prototype.isMaster,
    o.prototype.unloadEvent = o.prototype.unloadEvent,
    o.prototype.preUnloadEvent = o.prototype.unloadEvent,
    ot(o, Ru, !1, !0),
    ot(o, O3, !0, !0),
    o
}();
var tL = function(e) {
    this.device = e
};
tL.prototype = {
    onSessionClose: function(e) {
        e || (this.device.stateMachine.onSessionClose(),
        this.device.deviceId = null,
        this.device.adapterName = null,
        this.device.statusTimestamp = 0)
    },
    onRegisterOK: function(e, t) {
        this.device.deviceId = e,
        this.device.adapterName = t
    },
    onRegisterError: function(e, t) {
        this.device.stateMachine.error(e, t)
    },
    onStatusChange: function(e, t) {
        switch (e) {
        case "ACTIVE":
            this.device.stateMachine.activate(t);
            break;
        case "SUSPENDED":
            this.device.stateMachine.suspend(t);
            break
        }
    },
    onSubscriptionsUpdated: function() {
        this.device.dispatchEvent("onSubscriptionsUpdated")
    }
};
var ao = function(e) {
    this._descriptor = e || {}
};
ao.prototype = {
    putAll: function(e, t) {
        var n = this.getMap(e);
        for (var i in t)
            n[i] = t[i]
    },
    setValue: function(e, t, n) {
        return n != null ? this.getMap(e)[t] = n : delete this.getMap(e)[t],
        this
    },
    getValue: function(e, t) {
        return this.getMap(e)[t]
    },
    getMap: function(e) {
        for (var t = this._descriptor, n = e.split("."), i = 0, r = n.length; i < r; i++) {
            var s = n[i]
              , o = t[s];
            o == null && (o = {},
            t[s] = o),
            t = o
        }
        return t
    },
    build: function() {
        return this._descriptor
    }
};
ao.prototype.putAll = ao.prototype.putAll;
ao.prototype.setValue = ao.prototype.setValue;
ao.prototype.getValue = ao.prototype.getValue;
ao.prototype.getMap = ao.prototype.getMap;
ao.prototype.build = ao.prototype.build;
var Bx = [];
Bx = ["New value for setting received from internal settings", "New value for setting received from API", "Broadcasting setting to shared LightstreamerClient instances", "Setting changed, firing notification", "Wong length!", "Missing from first array", "Missing from second array", "Wrong  element", "Not expecting a NULL", "Expecting a different value", "Expecting 2 different values", "Expecting a valid value", "Expecting a not valid value", "ASSERT failed", "Unexpected", "Unexpectedly missing session id", "Bind request generated", "Create request generated", "Recovery request generated", "Destroy request generated", "Force rebind request generated", "New engine created", "Engine", "Subscribing subscription", "Unsubscribing subscription", "Enqueueing subscription update", "Resuming subscription update", "Executing subscription update", "sending Subscription to the engine", "Overriding old promise for table ", "Delaying subscription completion", "Resuming subscription completion", "Ignored old promise triggered for table ", "Ignored old promise failed for table ", "Restoring all pending Subscriptions", "Pausing active Subscription", "Pausing all active Subscriptions", "Delaying subscription action", "Resuming subscription action", "Executing subscription action", "Delaying subscription action", "Resuming subscription action", "Subscription action had to be delayed on multiple instances", "An error occurred while executing an event on a listener", "Dispatching event on listeners", "Changing reference session", "Command phase check", "Adding notification", "Unexpected progressive", "Skipping replicated progressive", "Unexpected progressive", "Received event prog higher than expected", "Received event prog different than expected", "Received event prog different than actual", "Unexpected message outcome sequence", "Unexpected command received, ignoring", "There is probably another web application connected to the same Lightstreamer Server within this browser instance. That could prevent the current application from connecting to the Server. Please close the other application to unblock the current one", "New client attached to engine", "Dismissing client", "Can't find subscription anymore", "Can't find page anymore", "Client or session unexpectedly disappeared while handling subscription", "Notify back to the client that the subscription was handled", "It has been detected that the JavaScript engine of this browser is not respecting the timeouts in setTimeout method calls. The Client has been disconnected from the Server in order to avoid reconnection loops. To try again, just refresh the page.", "New WS connection oid=", "Closing WebSocket connection", "Error closing WebSocket connection", "Unexpected openSocket call", "Error opening WebSocket connection", "Timeout event [currentConnectTimeoutWS]", "error on closing a timed out WS", "Unexpected WebSocket _load call", "Preparing to bind on WebSocket connection", "Open path is disappeared", "WebSocket transport sending oid=", "Error sending data over WebSocket", "Unexpected send outcome while websocket is ready-to-send", "WebSocket transport receiving oid=", "Error on WebSocket connection oid=", "WebSocket connection ready", "WebSocket connection close event received", "New sessionId", "New session", "Copying prog ", "Resetting session oid=", "Session state change", "Mad timeouts? Avoid connection", "Opening on server, send destroy", "Opening new session", "Unexpected phase during binding of session", "Binding session", "Binding session", "Switch requested", "Unexpected creation of a session while another one is still creating", "Slow requested", "Unexpected phase during slow handling", "Closing session", "Session shutdown", "Make pause before next bind", "Timeout event", "Start session recovery. Cause: no response timeLeft=", "Start new session. Cause: no response", "Timeout: switch transport", "Timeout: recover session", "Timeout: new session", "Unexpected timeout event while session is _OFF", "Error event", "Start session recovery. Cause: socket failure while receiving", "Start new session. Cause: socket failure while receiving", "Start session recovery. Cause: socket failure while recovering", "Switching transport", "Start new session. Cause: ", "Unexpected loop event while session is an non-active status", "Unexpected push event while session is an non-active status", "Unexpected phase after create request sent", "Unexpected phase after bind request sent", "Status timeout in ", "Unexpected phase during OK execution", "Unexpected empty start time", "Synch event received", "Available bandwidth event received", "Error41 event received", "Keepalive event received", "OK event received", "Initializing session", "Unexpected session id received on bind OK", "Sync event received", "Loop event received", "Ignore error", "End event received", "Sending request to the server to force a rebind on the current connection", "force_rebind request caused the error: ", "Sending request to the server to destroy the current session", "destroy request caused the error: ", "constrain request ", "New CORS-XHR connection oid=", "CORS-XHR connection closed oid=", "Error non closing connection opened using CORS-XHR", "CORS-XHR transport sending oid=", "Error opening CORS-XHR connection oid=", "CORS-XHR transport receiving oid=", "CORS-XHR connection error oid=", "CORS-XHR request completed oid=", "Error reading CORS-XHR status oid=", "Closing connection opened using IEXSXHR", "Error non closing connection opened using IEXSXHR", "IEXSXHR transport sending", "Error opening connection using IEXSXHR", "Error on connection opened using IEXSXHR", "IEXSXHR transport receiving", "Connection opened using IEXSXHR completed", "Closing connection opened using html form; actually doing nothing", "Html form transport sending", "Error while sending request using html form", "Closing connection opened using replace on forever-frame", "Replace on forever-frame transport sending", "Replace on forever-frame not available", "Error while sending request using  replace on forever-frame", "Loading XHR frame to perform non-cross-origin requests", "Client is offline, will retry later to load XHR frame", "XHR frame loaded", "XHR frame loading timeout expired, try to reload", "XHR frame loading timeout expired again, will not try again", "Passing request to the XHR frame", "Error passing request to the XHR frame", "XHR transport sending", "Closing connection opened using XHR", "Error closing connection opened using XHR", "Error reading XHR status", "XHR transport receiving", "Error on connection opened using XHR", "Error on disposing XHR's callback", "Error on disposing XHR", "Streaming enabled on XHR", "XHR transport receiving", "XHR transport receiving", "Verify connection class", "This class is not available on the current environment", "Cross-origin request is needed, this class is not able to make cross-origin requests", "Cookies on request are required, this class can't guarantee that cookies will be actually sent", "Cross-protocol request is needed, this class is not able to make cross-protocol requests", "Extra headers are given, this class is not able to send requests containing extra headers", "This class can't be used in the current context", "Connection class is good", "Searching for an appropriate connection class", "Restart connection selector", "Client is offline, delaying connection to server", "Unable to use available connections to connect to server", "Unable to use available connections to connect to server", "Connection request generated", "Connection currently unavailable, delaying connection", "Connection open to the server", "Unexpected ws phase while opening connection", "Open WebSocket to server", "A control link was received while earlyWSOpenEnabled is set to true, a WebSocket was wasted.", "Unexpected ws phase during binding", "WebSockets currently unavailable, delaying connection", "Unexpected WebSocket failure", "Connection to server bound upon WebSocket", "Connection to server open upon WebSocket", "Unexpected phase for an clean end of a WS", "Unexpected connection error on a connection that was not yet open", "WebSocket was broken before it was used", "WebSocket was broken while we were waiting the first bind", "can't be unable-to-open since the connection is already open", "WebSocket was broken while we were waiting", "Sync message received while session wasn't in receiving status", "First sync message, check not performed", "Huge delay detected by sync signals. Restored from standby/hibernation?", "No delay detected by sync signals", "Delay detected by sync signals", "No delay detected by sync signals", "Duplicated message", "Unexpected request type was given to this batch", "Unexpected request type was given to this batch; expecting ADD REMOVE DESTROY CONSTRAIN or MPN", "Storing request", "Substituting CONSTRAINT/FORCE_REBIND/MPN request", "Replacing 'second' ADD request with a REMOVE request for the same subscription", "REMOVE request already stored, skipping", "ADD request for the involved subscription was not yet sent; there is no need to send the related REMOVE request or the original ADD one, removing both", "ADD after REMOVE?", "Same session id on different servers, store two different DESTROY requests", "Verified duplicated DESTROY request, skipping", "Duplicated ADD or CHANGE_SUB request, substitute the old one with the new one", "Storing confirmed", "Trying to remove by index non-existent request", "Trying to remove by key non-existent request", "Batch length limit changed", "Start sending reverse heartbeat to the server", "Start sending reverse heartbeat to the server", "Keep sending reverse heartbeat to the server", "Preparing reverse heartbeat", "Stop sending reverse heartbeat to the server", "Stop sending reverse heartbeat to the server", "Keep sending reverse heartbeat to the server", "Close current connection if any and applicable", "ControlConnectionHandler state change '", "Reset Controls handler status", "Batch handler unexpectedly idle; a batch was waiting", "Batch handler unexpectedly not idle; nothing ready to be sent was found", "Batch object not null", "Enabling control requests over WebSocket now", "Disabling control requests over WebSocket now", "New request to be sent", "Still waiting previous batch", "Ready to dequeue", "Waiting for dequeue", "starting dequeuing", "Send previous batch", "Send new batch", "Some requests don't need to be sent anymore, keep on dequeing", "Delaying requests; waiting for a connection", "Can't find a connection to send batch", "Request sent through HTTP connection", "Request sent through WebSocket, keep on dequeuing", "Request queue is now empty", "Duplicated message", "Empty batch, exit", "Ready to send batch, choosing connection", "WebSocket should be available, try to send through it", "Empty request was generated, exit", "Unable to find a connection for control requests, will try again later", "Connection for control batch chosen", "Empty request for HTTP was generated, exit", "Connection failed, will try a different connection", "Connection temporarily unavailable, will try later", "Unexpected sending outcome", "Control request got answer", "Control request got answer", "Error from network", "A single request size exceeds the <request_limit> configuration setting for the Server. Trying to send it anyway although it will be refused", "Closing message handler", "Activating message handler", "Preparing message request", "Forward prepared message to control handler", "No ack was received for a message; forwarding it again to the control handler", "Ack received for message", "Ack received, stopping automatic retransmissions", "Ack received, no outcome expected, clean structures", "Not waiting for ack, purging", "Message handled, clean structures", "Message on the net notification", "OK outcome received", "DISCARDED outcome received", "DENIED outcome received", "ERROR outcome received", "Enqueuing received data", "Dequeuing received data", "Data can't be handled", "Unexpected error occurred while executing server-sent commands!", "Malformed message: ", "Unexpected update", "New session handler oid=", "SessionManager state change:", "Session recovery", "Session recovery: cancelled", "Can't initiate session, giving up, disabling automatic reconnections", "Unable to establish session of the current type. Switching session type", "Unexpected fallback type; switching because the current session type cannot be established", "Slow session detected. Switching session type", "Unexpected fallback type; switching because of a slow connection was detected", "Setting up new session type", "Unexpected fallback type switching with new session", "Switching current session type", "Unexpected fallback type switching with a force rebind", "Slow session switching", "Failed to switch session type. Starting new session", "Unexpected fallback type switching because of a failed force rebind", "Session started", "Session closed", "Discarding update for dismissed page", "Received new update", "Discarding lost updates notification for dismissed page", "Received lost updates event", "Discarding end of snapshot notification for dismissed page", "Received end of snapshot event", "Discarding snapshot clearing notification for dismissed page", "Received snapshot clearing event", "Received server error event", "Received subscription error event", "Discarding subscription error notification for dismissed page", "Received unsubscription event", "Discarding unsubscription notification for dismissed page", "Received reconfiguration OK event", "Table of reconfiguration not found", "Discarding subscription notification for dismissed page", "Received subscription event", "Received message ack", "Received message-ok notification", "Received message-deny notification", "Received message-discarded notification", "Received message-error notification", "New control link received", "unsubscription request ", "configuration request [", "Fatal error: ", "Dismissing current session and stopping automatic reconnections.", "Transport change requested", "Opening a new session and starting automatic reconnections.", "RUNNING EXECUTOR AT ", "Shared worker is broken", "RESUMED TO ", "DELAYED TO ", "SharedWorker receiving error", "SharedWorker sending error", "Unexpected sharing error", "Unexpected dispatching error", "Unexpected error on dispatching", "SharedStatus remote sharing is ready", "SharedStatus local sharing is ready", "Started refresh thread", "Address already removed?", "Removing wrong address?", "Engine is probably dying, skip one cookie refresh", "Checking status", "No engines", "Checking shared status to verify if there are similar engines alive", "Engine found, no values though", "Engine found, not compatible though", "Write engine shared status", "Found engine", "There is a concurrent engine. Close engine ", "Stopped refresh thread", "Remote engine", "Trying to attach to a cross-page engine", "Exception while trying to attach to a cross-page engine", `You have Norton Internet Security or Norton
Personal Firewall installed on this computer.
If no real-time data show up, then you need
to disable Ad Blocking in Norton Internet
Security and then refresh this page`, "Cross-page engine not found", "Probably blocked popup detected: firefox-safari case", "Cross-page engine attached", "Verify if the found cross-page engine can be used", "can't use found cross-page engine: page is now closed", "can't use found cross-page engine: uneffective popup detected, chrome case", "problem closing the generated popup", "Probably blocked popup detected: opera common case", "can't use found cross-page engine: Lightstreamer singleton not available", "can't use found cross-page engine: Lightstreamer singleton content unavailable", "Ready to use found cross-page engine: looks ok", "can't use found cross-page engine: exception throw while accessing it", "Skipping already-used cookie", "Stop search for an engine", "No sharing was found, a new sharing will be created", "No sharing was found, will keep on searching after a pause", "No sharing was found, no sharing will be created, this client will fail", "A sharing was found but attaching is disabled, this client will fail", "A sharing was found, this will attach to", "Engine", "A sharing was found, but accordingly with the configuration it will be ignored", "Searching for available sharing", "Local engine found", "Local engine not found. Can't search on other pages because of the current sharing configuration", "Search remote engine in other page", "RemoteEngine =", "Can't access reference ", "Search remote engine in shared storage", "Storage inspection complete", "No valid engine found", "Valid engine found: ", "Engine ", "Engine ", "invalid values", "Unexpected missing values in sharing cookie", "Skipping not compatible engine", "Found a likely dead engine", "Valid engine values found. Wait for popup-protection timeout", "No compatible sharing detected", "No valid engine values found. Check again in ", "Forcing preventCrossWindowShare because page is on file:///", "New connection sharing", "A new sharing will be immediately created", "No way to obtain a sharing, this client will fail immediately", "A sharing will now be searched", "An exception was thrown while executing the Function passed to the forEachChangedField method", "An exception was thrown while executing the Function passed to the forEachField method", "Subscription reset", "Subscription entered the active state", "Subscription waiting to be sent to server", "Subscription queued to be sent to server", "Subscription is now on hold", "Subscription exits the active status; it can now be modified", "Subscription is now subscribed to", "Subscription is not subscribed to anymore", "Subscription request generated", "Received position of COMMAND and KEY fields from server", "Adapter Set assigned", "Selector assigned", "Requested Max Frequency assigned", "Requested Buffer Size assigned", "Snapshot Required assigned", "Second level Data Adapter Set assigned", "key and/or command position not correctly configured", "MpnSubscription state change", "MpnManager state change", "Sharing is not available on UCBrowser", "Connection sharing is not available", "Page is closing, won't search a new engine", "no sharing on mourning room?", "Sharing lost, trying to obtain a new one", "Connect requested", "Executing connect", "Disconnect requested", "Executing disconnect", "MpnDevice state change", "Can't remove row that does not exist", "Removing row", "Postpone new update until the current update/remove is completed", "Postpone new remove until the current update/remove is completed", "Inserting new row", "Updating row", "Cleaning the model", "New ChartLine", "Clearing ChartLine", "Repainting ChartLine", "ChartLine re-painted", "Calculated Y unit", "Y labels generated", "Y labels cleared", "Y labels now configured", "Line style configured", "Y axis is now positioned", "Painter configured", "Chart is now ready to be used", "A DOM element must be provided as an anchor for the chart", "Creating a new label for the chart", "Drawing line on the chart", "New line coordinates", "New line was drawn", "Repaint All", "Calculated X unit", "X labels generated", "X labels cleared", "Got double nulls, clear line", "Got a null, ignore point", "Cannot create line. Please declare the Y axis", "Line removed", "Cleaned all", "Parse html for Chart", "X axis is now configured on field", "Configuring multiple Y axis", "Y axis is now configured on field", "removing multiple Y axis", "Y axis is now removed", "X axis is now positioned", "X labels now configured", "Merging this update values with the values of the current update", "Filling formatted values in cell", "Scroll direction is ignored if sort is enabled", "Exception thrown while executing the iterator Function", "Cannot find the scroll element", "Perform auto-scroll", "Can't find value for sort key field", "Calculate number of pages", "Unexpected position of row to be wiped", "New value for setting received from internal settings", "New value for setting received from API", "Broadcasting setting to shared LightstreamerClient instances", "Setting changed, firing notification", "Wong length!", "Missing from first array", "Missing from second array", "Wrong  element", "Not expecting a NULL", "Expecting a different value", "Expecting 2 different values", "Expecting a valid value", "Expecting a not valid value", "ASSERT failed", "Unexpected", "Unexpectedly missing session id", "Bind request generated", "Create request generated", "Recovery request generated", "Destroy request generated", "Force rebind request generated", "New engine created", "Engine", "Subscribing subscription", "Unsubscribing subscription", "Enqueueing subscription update", "Resuming subscription update", "Executing subscription update", "sending Subscription to the engine", "Overriding old promise for table ", "Delaying subscription completion", "Resuming subscription completion", "Ignored old promise triggered for table ", "Ignored old promise failed for table ", "Restoring all pending Subscriptions", "Pausing active Subscription", "Pausing all active Subscriptions", "Delaying subscription action", "Resuming subscription action", "Executing subscription action", "Delaying subscription action", "Resuming subscription action", "Subscription action had to be delayed on multiple instances", "An error occurred while executing an event on a listener", "Dispatching event on listeners", "Changing reference session", "Command phase check", "Adding notification", "Unexpected progressive", "Skipping replicated progressive", "Unexpected progressive", "Received event prog higher than expected", "Received event prog different than expected", "Received event prog different than actual", "Unexpected message outcome sequence", "Unexpected command received, ignoring", "There is probably another web application connected to the same Lightstreamer Server within this browser instance. That could prevent the current application from connecting to the Server. Please close the other application to unblock the current one", "New client attached to engine", "Dismissing client", "Can't find subscription anymore", "Can't find page anymore", "Client or session unexpectedly disappeared while handling subscription", "Notify back to the client that the subscription was handled", "It has been detected that the JavaScript engine of this browser is not respecting the timeouts in setTimeout method calls. The Client has been disconnected from the Server in order to avoid reconnection loops. To try again, just refresh the page.", "New WS connection oid=", "Closing WebSocket connection", "Error closing WebSocket connection", "Unexpected openSocket call", "Error opening WebSocket connection", "Timeout event [currentConnectTimeoutWS]", "error on closing a timed out WS", "Unexpected WebSocket _load call", "Preparing to bind on WebSocket connection", "Open path is disappeared", "WebSocket transport sending oid=", "Error sending data over WebSocket", "Unexpected send outcome while websocket is ready-to-send", "WebSocket transport receiving oid=", "Error on WebSocket connection oid=", "WebSocket connection ready", "WebSocket connection close event received", "New sessionId", "New session", "Copying prog ", "Resetting session oid=", "Session state change", "Mad timeouts? Avoid connection", "Opening on server, send destroy", "Opening new session", "Unexpected phase during binding of session", "Binding session", "Binding session", "Switch requested", "Unexpected creation of a session while another one is still creating", "Slow requested", "Unexpected phase during slow handling", "Closing session", "Session shutdown", "Make pause before next bind", "Timeout event", "Start session recovery. Cause: no response timeLeft=", "Start new session. Cause: no response", "Timeout: switch transport", "Timeout: recover session", "Timeout: new session", "Unexpected timeout event while session is _OFF", "Error event", "Start session recovery. Cause: socket failure while receiving", "Start new session. Cause: socket failure while receiving", "Start session recovery. Cause: socket failure while recovering", "Switching transport", "Start new session. Cause: ", "Unexpected loop event while session is an non-active status", "Unexpected push event while session is an non-active status", "Unexpected phase after create request sent", "Unexpected phase after bind request sent", "Status timeout in ", "Unexpected phase during OK execution", "Unexpected empty start time", "Synch event received", "Available bandwidth event received", "Error41 event received", "Keepalive event received", "OK event received", "Initializing session", "Unexpected session id received on bind OK", "Sync event received", "Loop event received", "Ignore error", "End event received", "Sending request to the server to force a rebind on the current connection", "force_rebind request caused the error: ", "Sending request to the server to destroy the current session", "destroy request caused the error: ", "constrain request ", "New CORS-XHR connection oid=", "CORS-XHR connection closed oid=", "Error non closing connection opened using CORS-XHR", "CORS-XHR transport sending oid=", "Error opening CORS-XHR connection oid=", "CORS-XHR transport receiving oid=", "CORS-XHR connection error oid=", "CORS-XHR request completed oid=", "Error reading CORS-XHR status oid=", "Closing connection opened using IEXSXHR", "Error non closing connection opened using IEXSXHR", "IEXSXHR transport sending", "Error opening connection using IEXSXHR", "Error on connection opened using IEXSXHR", "IEXSXHR transport receiving", "Connection opened using IEXSXHR completed", "Closing connection opened using html form; actually doing nothing", "Html form transport sending", "Error while sending request using html form", "Closing connection opened using replace on forever-frame", "Replace on forever-frame transport sending", "Replace on forever-frame not available", "Error while sending request using  replace on forever-frame", "Loading XHR frame to perform non-cross-origin requests", "Client is offline, will retry later to load XHR frame", "XHR frame loaded", "XHR frame loading timeout expired, try to reload", "XHR frame loading timeout expired again, will not try again", "Passing request to the XHR frame", "Error passing request to the XHR frame", "XHR transport sending", "Closing connection opened using XHR", "Error closing connection opened using XHR", "Error reading XHR status", "XHR transport receiving", "Error on connection opened using XHR", "Error on disposing XHR's callback", "Error on disposing XHR", "Streaming enabled on XHR", "XHR transport receiving", "XHR transport receiving", "Verify connection class", "This class is not available on the current environment", "Cross-origin request is needed, this class is not able to make cross-origin requests", "Cookies on request are required, this class can't guarantee that cookies will be actually sent", "Cross-protocol request is needed, this class is not able to make cross-protocol requests", "Extra headers are given, this class is not able to send requests containing extra headers", "This class can't be used in the current context", "Connection class is good", "Searching for an appropriate connection class", "Restart connection selector", "Client is offline, delaying connection to server", "Unable to use available connections to connect to server", "Unable to use available connections to connect to server", "Connection request generated", "Connection currently unavailable, delaying connection", "Connection open to the server", "Unexpected ws phase while opening connection", "Open WebSocket to server", "A control link was received while earlyWSOpenEnabled is set to true, a WebSocket was wasted.", "Unexpected ws phase during binding", "WebSockets currently unavailable, delaying connection", "Unexpected WebSocket failure", "Connection to server bound upon WebSocket", "Connection to server open upon WebSocket", "Unexpected phase for an clean end of a WS", "Unexpected connection error on a connection that was not yet open", "WebSocket was broken before it was used", "WebSocket was broken while we were waiting the first bind", "can't be unable-to-open since the connection is already open", "WebSocket was broken while we were waiting", "Sync message received while session wasn't in receiving status", "First sync message, check not performed", "Huge delay detected by sync signals. Restored from standby/hibernation?", "No delay detected by sync signals", "Delay detected by sync signals", "No delay detected by sync signals", "Duplicated message", "Unexpected request type was given to this batch", "Unexpected request type was given to this batch; expecting ADD REMOVE DESTROY CONSTRAIN or MPN", "Storing request", "Substituting CONSTRAINT/FORCE_REBIND/MPN request", "Replacing 'second' ADD request with a REMOVE request for the same subscription", "REMOVE request already stored, skipping", "ADD request for the involved subscription was not yet sent; there is no need to send the related REMOVE request or the original ADD one, removing both", "ADD after REMOVE?", "Same session id on different servers, store two different DESTROY requests", "Verified duplicated DESTROY request, skipping", "Duplicated ADD or CHANGE_SUB request, substitute the old one with the new one", "Storing confirmed", "Trying to remove by index non-existent request", "Trying to remove by key non-existent request", "Batch length limit changed", "Start sending reverse heartbeat to the server", "Start sending reverse heartbeat to the server", "Keep sending reverse heartbeat to the server", "Preparing reverse heartbeat", "Stop sending reverse heartbeat to the server", "Stop sending reverse heartbeat to the server", "Keep sending reverse heartbeat to the server", "Close current connection if any and applicable", "ControlConnectionHandler state change '", "Reset Controls handler status", "Batch handler unexpectedly idle; a batch was waiting", "Batch handler unexpectedly not idle; nothing ready to be sent was found", "Batch object not null", "Enabling control requests over WebSocket now", "Disabling control requests over WebSocket now", "New request to be sent", "Still waiting previous batch", "Ready to dequeue", "Waiting for dequeue", "starting dequeuing", "Send previous batch", "Send new batch", "Some requests don't need to be sent anymore, keep on dequeing", "Delaying requests; waiting for a connection", "Can't find a connection to send batch", "Request sent through HTTP connection", "Request sent through WebSocket, keep on dequeuing", "Request queue is now empty", "Duplicated message", "Empty batch, exit", "Ready to send batch, choosing connection", "WebSocket should be available, try to send through it", "Empty request was generated, exit", "Unable to find a connection for control requests, will try again later", "Connection for control batch chosen", "Empty request for HTTP was generated, exit", "Connection failed, will try a different connection", "Connection temporarily unavailable, will try later", "Unexpected sending outcome", "Control request got answer", "Control request got answer", "Error from network", "A single request size exceeds the <request_limit> configuration setting for the Server. Trying to send it anyway although it will be refused", "Closing message handler", "Activating message handler", "Preparing message request", "Forward prepared message to control handler", "No ack was received for a message; forwarding it again to the control handler", "Ack received for message", "Ack received, stopping automatic retransmissions", "Ack received, no outcome expected, clean structures", "Not waiting for ack, purging", "Message handled, clean structures", "Message on the net notification", "OK outcome received", "DISCARDED outcome received", "DENIED outcome received", "ERROR outcome received", "Enqueuing received data", "Dequeuing received data", "Data can't be handled", "Unexpected error occurred while executing server-sent commands!", "Malformed message: ", "Unexpected update", "New session handler oid=", "SessionManager state change:", "Session recovery", "Session recovery: cancelled", "Can't initiate session, giving up, disabling automatic reconnections", "Unable to establish session of the current type. Switching session type", "Unexpected fallback type; switching because the current session type cannot be established", "Slow session detected. Switching session type", "Unexpected fallback type; switching because of a slow connection was detected", "Setting up new session type", "Unexpected fallback type switching with new session", "Switching current session type", "Unexpected fallback type switching with a force rebind", "Slow session switching", "Failed to switch session type. Starting new session", "Unexpected fallback type switching because of a failed force rebind", "Session started", "Session closed", "Discarding update for dismissed page", "Received new update", "Discarding lost updates notification for dismissed page", "Received lost updates event", "Discarding end of snapshot notification for dismissed page", "Received end of snapshot event", "Discarding snapshot clearing notification for dismissed page", "Received snapshot clearing event", "Received server error event", "Received subscription error event", "Discarding subscription error notification for dismissed page", "Received unsubscription event", "Discarding unsubscription notification for dismissed page", "Received reconfiguration OK event", "Table of reconfiguration not found", "Discarding subscription notification for dismissed page", "Received subscription event", "Received message ack", "Received message-ok notification", "Received message-deny notification", "Received message-discarded notification", "Received message-error notification", "New control link received", "unsubscription request ", "configuration request [", "Fatal error: ", "Dismissing current session and stopping automatic reconnections.", "Transport change requested", "Opening a new session and starting automatic reconnections.", "RUNNING EXECUTOR AT ", "Shared worker is broken", "RESUMED TO ", "DELAYED TO ", "SharedWorker receiving error", "SharedWorker sending error", "Unexpected sharing error", "Unexpected dispatching error", "Unexpected error on dispatching", "SharedStatus remote sharing is ready", "SharedStatus local sharing is ready", "Started refresh thread", "Address already removed?", "Removing wrong address?", "Engine is probably dying, skip one cookie refresh", "Checking status", "No engines", "Checking shared status to verify if there are similar engines alive", "Engine found, no values though", "Engine found, not compatible though", "Write engine shared status", "Found engine", "There is a concurrent engine. Close engine ", "Stopped refresh thread", "Remote engine", "Trying to attach to a cross-page engine", "Exception while trying to attach to a cross-page engine", `You have Norton Internet Security or Norton
Personal Firewall installed on this computer.
If no real-time data show up, then you need
to disable Ad Blocking in Norton Internet
Security and then refresh this page`, "Cross-page engine not found", "Probably blocked popup detected: firefox-safari case", "Cross-page engine attached", "Verify if the found cross-page engine can be used", "can't use found cross-page engine: page is now closed", "can't use found cross-page engine: uneffective popup detected, chrome case", "problem closing the generated popup", "Probably blocked popup detected: opera common case", "can't use found cross-page engine: Lightstreamer singleton not available", "can't use found cross-page engine: Lightstreamer singleton content unavailable", "Ready to use found cross-page engine: looks ok", "can't use found cross-page engine: exception throw while accessing it", "Skipping already-used cookie", "Stop search for an engine", "No sharing was found, a new sharing will be created", "No sharing was found, will keep on searching after a pause", "No sharing was found, no sharing will be created, this client will fail", "A sharing was found but attaching is disabled, this client will fail", "A sharing was found, this will attach to", "Engine", "A sharing was found, but accordingly with the configuration it will be ignored", "Searching for available sharing", "Local engine found", "Local engine not found. Can't search on other pages because of the current sharing configuration", "Search remote engine in other page", "RemoteEngine =", "Can't access reference ", "Search remote engine in shared storage", "Storage inspection complete", "No valid engine found", "Valid engine found: ", "Engine ", "Engine ", "invalid values", "Unexpected missing values in sharing cookie", "Skipping not compatible engine", "Found a likely dead engine", "Valid engine values found. Wait for popup-protection timeout", "No compatible sharing detected", "No valid engine values found. Check again in ", "Forcing preventCrossWindowShare because page is on file:///", "New connection sharing", "A new sharing will be immediately created", "No way to obtain a sharing, this client will fail immediately", "A sharing will now be searched", "An exception was thrown while executing the Function passed to the forEachChangedField method", "An exception was thrown while executing the Function passed to the forEachField method", "Subscription reset", "Subscription entered the active state", "Subscription waiting to be sent to server", "Subscription queued to be sent to server", "Subscription is now on hold", "Subscription exits the active status; it can now be modified", "Subscription is now subscribed to", "Subscription is not subscribed to anymore", "Subscription request generated", "Received position of COMMAND and KEY fields from server", "Adapter Set assigned", "Selector assigned", "Requested Max Frequency assigned", "Requested Buffer Size assigned", "Snapshot Required assigned", "Second level Data Adapter Set assigned", "key and/or command position not correctly configured", "MpnSubscription state change", "MpnManager state change", "Sharing is not available on UCBrowser", "Connection sharing is not available", "Page is closing, won't search a new engine", "no sharing on mourning room?", "Sharing lost, trying to obtain a new one", "Connect requested", "Executing connect", "Disconnect requested", "Executing disconnect", "MpnDevice state change", "Can't remove row that does not exist", "Removing row", "Postpone new update until the current update/remove is completed", "Postpone new remove until the current update/remove is completed", "Inserting new row", "Updating row", "Cleaning the model", "New ChartLine", "Clearing ChartLine", "Repainting ChartLine", "ChartLine re-painted", "Calculated Y unit", "Y labels generated", "Y labels cleared", "Y labels now configured", "Line style configured", "Y axis is now positioned", "Painter configured", "Chart is now ready to be used", "A DOM element must be provided as an anchor for the chart", "Creating a new label for the chart", "Drawing line on the chart", "New line coordinates", "New line was drawn", "Repaint All", "Calculated X unit", "X labels generated", "X labels cleared", "Got double nulls, clear line", "Got a null, ignore point", "Cannot create line. Please declare the Y axis", "Line removed", "Cleaned all", "Parse html for Chart", "X axis is now configured on field", "Configuring multiple Y axis", "Y axis is now configured on field", "removing multiple Y axis", "Y axis is now removed", "X axis is now positioned", "X labels now configured", "Merging this update values with the values of the current update", "Filling formatted values in cell", "Scroll direction is ignored if sort is enabled", "Exception thrown while executing the iterator Function", "Cannot find the scroll element", "Perform auto-scroll", "Can't find value for sort key field", "Calculate number of pages", "Unexpected position of row to be wiped"];
m.resolve = function(e) {
    return e + "] " + Bx[e]
}
;
var Qg = function() {};
Qg.getMessage = function(e) {
    return m.resolve(e)
}
;
m.resolve = m.resolve;
Qg.getMessage = Qg.getMessage;
var nL = 0
  , Ql = class {
    constructor(t, n, i) {
        this.pScope = t,
        this.pId = nL++,
        this.command = n,
        this.listenUntil = i
    }
}
;
var Jl = ( () => {
    let t = class t {
        get webWorkerEnabled() {
            return this.webWorkerFeatureToggle && this.easyWorker?.isWebWorkerSupported
        }
        constructor() {
            this.subs = [],
            this.listenUntilSubjects = {},
            this.webWorkerFeatureToggle = null,
            this.connectionState = Rt.Disconnected,
            this.connectionStateSubject = new Ne(this.connectionState),
            this.connectionState$ = this.connectionStateSubject.asObservable(),
            this.lsStableState$ = this.connectionState$.pipe(Jn(i => i === Rt.Connected)),
            this.resetLsManuallySubject = new Ne(!1),
            this.resetLsManually$ = this.resetLsManuallySubject.asObservable(),
            this.lsConnectedSubject = new Ne(!1),
            this.lsConnected$ = this.lsConnectedSubject.asObservable(),
            this.customerIsin = "",
            this.lsUrl = "",
            this.EASY_WORKER_NOT_PROVIDED = "Easy web worker not provided!",
            this.connectionFinalState$ = this.connectionState$.pipe(mt(i => [Rt.Connected, Rt.Disconnected].includes(i)), D0())
        }
        setConfig(i) {
            this.lsUrl = i.lsUrl,
            this.customerIsin = i.customerIsin ?? "",
            this.webWorkerFeatureToggle = i.webWorkerFeatureToggle === !0,
            this.easyWorker = i.workerService
        }
        start() {
            let i = {
                onServerError: () => {
                    this.changeConnectionState(Rt.NotConnected)
                }
                ,
                onStatusChange: s => {
                    try {
                        let o = s.split(":");
                        o.length > 0 && (o[0] === "CONNECTED" ? this.changeConnectionState(Rt.Connected) : o[0] === "CONNECTING" ? this.changeConnectionState(Rt.Connecting) : o[0] === "DISCONNECTED" ? this.changeConnectionState(Rt.Disconnected) : this.changeConnectionState(Rt.Unknown))
                    } catch {
                        this.changeConnectionState(Rt.Unknown)
                    }
                }
            }
              , r = "lsadapter-conf";
            if (!this.webWorkerEnabled)
                this.lsClient = new G3(this.lsUrl,r),
                this.lsClient.connectionDetails.setUser(this.customerIsin),
                this.lsClient.connectionOptions.setCookieHandlingRequired(!0),
                this.lsClient.connectionOptions.setEarlyWSOpenEnabled(!1),
                this.lsClient.connect(),
                this.lsClient.addListener(i);
            else {
                if (!this.easyWorker)
                    throw new Error(this.EASY_WORKER_NOT_PROVIDED);
                this.easyWorker.isWorkerAvailable("ls-worker") || this.easyWorker.initializeWorker("ls-worker", new Worker(new URL("worker-4VVFA4CG.js",import.meta.url),{
                    type: "module"
                }));
                let s = new Ql("ls-worker",new Pl("init",{
                    lsUrl: this.lsUrl,
                    lsAdapterSet: r,
                    customerIsin: this.customerIsin
                }, ({lsEventType: o, eventData: a}) => {
                    typeof i[o] == "function" && i[o](a)
                }
                ));
                this.easyWorker.startProcess(s)
            }
        }
        changeConnectionState(i) {
            this.connectionState = i,
            this.connectionStateSubject.next(i),
            i === Rt.Connected ? this.lsConnectedSubject.next(!0) : this.lsConnectedSubject.next(!1)
        }
        onDestroy() {
            this.disconnect()
        }
        unsubscribeAllAndDisconnect() {
            try {
                this.unsubscribeAll(),
                this.disconnect()
            } catch {}
        }
        disconnect() {
            this.lsConnectedSubject.next(!1),
            this.resetLsManuallySubject.next(!0),
            this.webWorkerEnabled ? this.easyWorker?.startProcess(new Ql("ls-worker",new Pl("disconnect"))) : this.lsClient?.disconnect()
        }
        resetLsConnection() {
            this.disconnect(),
            this.start()
        }
        subscribeToLsBySchema(i) {
            let r = this.getSubscriptionModelBySchema({
                schemaType: i.schemaType,
                elementId: i.elementId,
                schema: i.schema,
                needSnapShot: i.needSnapShot
            });
            return this.subscriptionToItems(r, i.elementId, i.schemaType)
        }
        getSubscriptionModelBySchema(i) {
            let r = ti.LsSchemasTopic.find(o => o.schema === i.schemaType)?.topic
              , s = {
                mode: ti.RawModeSchemas.indexOf(i.schemaType) > -1 ? Ol.Raw : Ol.Merge,
                adapterName: ti.LsAdapterName.find(o => o.topic === ti.LsSchemasTopic.find(a => a.schema === i.schemaType)?.topic)?.value,
                schema: i.schema || this.getSchema(ti.LsSchemas.find(o => o.type === i.schemaType)?.schema),
                isSnapshot: ti.SnapshotSchemas.indexOf(i.schemaType) > -1 ? xa.Yes : xa.No,
                items: [r + (i.elementId ? ":" + i.elementId : "")],
                changeType: ti.FullModeChangeSchemas.indexOf(i.schemaType) > -1 ? Sa.Full : Sa.Field
            };
            return i.needSnapShot !== null && i.needSnapShot !== void 0 && (s.isSnapshot = i.needSnapShot ? xa.Yes : xa.No),
            s
        }
        getSchema(i) {
            return Object.keys(i).map(r => i[r])
        }
        unsubscribeAll() {
            try {
                this.subs.forEach(i => {
                    this.lsClient?.unsubscribe(i.subscription)
                }
                ),
                this.subs = []
            } catch {}
        }
        subscriptionToItems(i, r, s) {
            if (!i.mode || !i.adapterName || !i.isSnapshot)
                throw new Error("wrong subscription model!");
            let o = new Bc(i.mode,i.items,i.schema);
            o.setDataAdapter(i.adapterName),
            o.setRequestedSnapshot(i.isSnapshot);
            let a = new lt
              , c = a.asObservable()
              , l = Ml();
            if (o.addListener({
                onItemUpdate: u => {
                    try {
                        if (i.changeType === Sa.Field)
                            u.forEachChangedField( (h, d, f) => {
                                let g = {
                                    inst: r ?? "",
                                    name: h,
                                    pos: d,
                                    val: f,
                                    subId: l
                                };
                                (g.val || g.val == 0) && a.next(g)
                            }
                            );
                        else {
                            let h = {};
                            i.schema?.forEach(f => {
                                h[f] = u.getValue(f)
                            }
                            );
                            let d = {
                                inst: r ?? "",
                                name: "",
                                pos: 0,
                                val: h,
                                subId: l
                            };
                            a.next(d)
                        }
                    } catch {}
                }
            }),
            !this.webWorkerEnabled)
                this.lsClient?.subscribe(o);
            else {
                let u = new lt;
                this.listenUntilSubjects[l] = u;
                let h = new Ql("ls-worker",new Pl("subscribe",{
                    subscriptionModel: i,
                    subId: l,
                    elementId: r ?? ""
                }, ({eventData: d}) => {
                    a.next(d)
                }
                ),u);
                this.easyWorker?.startProcess(h)
            }
            return this.subs.push({
                elementId: r,
                schemaType: s,
                subscription: o,
                subId: l
            }),
            c
        }
        getListOfSubscriptions() {
            let i = this.lsClient?.getSubscriptions()
        }
        unsubscribeFromWebWorkerLs(i) {
            this.listenUntilSubjects[i.subId] && (this.listenUntilSubjects[i.subId].next(),
            delete this.listenUntilSubjects[i.subId]),
            this.easyWorker?.startProcess(new Ql("ls-worker",new Pl("unSubscribe",{
                subId: i.subId
            })))
        }
        unsubscribeSchema(i, r) {
            let s = this.subs.filter(o => o.schemaType === i && o.elementId === (r ?? o.elementId));
            s && (s.forEach(o => {
                this.webWorkerEnabled ? this.unsubscribeFromWebWorkerLs(o) : this.lsClient?.unsubscribe(o.subscription)
            }
            ),
            this.subs = this.subs.filter(o => !(o.schemaType === i && o.elementId === (r ?? o.elementId))))
        }
        isSubscriptionAvailable(i, r) {
            return this.subs.some(s => s.schemaType === i && s.elementId === (r ?? s.elementId))
        }
        unsubscribeSchemaTypeExceptSelectedItems(i, r) {
            let s = this.subs.filter(o => o.schemaType === i && !r.includes(o.elementId ?? ""));
            s?.length && (s.forEach(o => {
                this.webWorkerEnabled ? this.unsubscribeFromWebWorkerLs(o) : this.lsClient?.unsubscribe(o.subscription)
            }
            ),
            this.subs = this.subs.filter(o => !s.map(a => a.subId).includes(o.subId)))
        }
        unsubscribeSchemaTypeAndIds(i, r) {
            let s = this.subs.filter(o => o.schemaType === i && r.includes(o.elementId ?? ""));
            s?.length && (s.forEach(o => {
                this.webWorkerEnabled ? this.unsubscribeFromWebWorkerLs(o) : this.lsClient?.unsubscribe(o.subscription)
            }
            ),
            this.subs = this.subs.filter(o => !s.map(a => a.subId).includes(o.subId)))
        }
        unsubscribeSchemaById(i) {
            let r = this.subs.find(s => s.subId === i);
            r && (this.webWorkerEnabled ? this.unsubscribeFromWebWorkerLs(r) : this.lsClient?.unsubscribe(r.subscription),
            this.subs = this.subs.filter(s => s.subId !== i))
        }
        unsubscribeSchemaByIds(i) {
            i?.forEach(r => this.unsubscribeSchemaById(r))
        }
        waitForStableConnection() {
            return this.lsConnectedSubject.pipe(Jn(i => i))
        }
        subscribeToLs(i, r, s=null) {
            return this.lsConnectedSubject.pipe(Jn(o => o), ui( () => this.subscribeToLsBySchema({
                schemaType: i,
                elementId: r,
                needSnapShot: s
            })))
        }
        subscribeToLsIfNotAvailable(i, r, s) {
            r.forEach(o => {
                this.isSubscriptionAvailable(i, o) || this.subscribeToLs(i, o).subscribe(a => {
                    s(a)
                }
                )
            }
            )
        }
        subscribeToLsWithDynamicSchema(i, r, s) {
            return this.lsConnectedSubject.pipe(Jn(o => o), ui( () => this.subscribeToLsBySchema({
                schemaType: i,
                elementId: s,
                schema: r
            })))
        }
        createDynamicSchema(...i) {
            return [...i]
        }
        subscribeToLs2(i, r, s, o) {
            this.getObservableWithCondition(r, s, o).subscribe(c => i(c)),
            this.resetLsManually$.pipe(mt(c => c)).subscribe( () => {
                this.getObservableWithCondition(r, s, o).subscribe(l => i(l))
            }
            )
        }
        getObservableWithCondition(i, r, s) {
            let o = this.subscribeToLs(i, r);
            return s && (o = o.pipe(g5.apply(s))),
            o
        }
        testLS() {
            wc( () => {
                this.changeConnectionState(Rt.Disconnected)
            }
            , 1e4),
            wc( () => {
                this.changeConnectionState(Rt.Connected)
            }
            , 25e3),
            wc( () => {
                this.changeConnectionState(Rt.Disconnected)
            }
            , 3e4),
            wc( () => {
                this.changeConnectionState(Rt.Connected)
            }
            , 4e4)
        }
        callFunctionUntilDestroy(i) {
            let {func: r, startDue: s, intervalDuration: o, count: a} = new h1(i)
              , c = a ? Lt(a) : Ge();
            return li(s, o).pipe(c, Ge( () => r && r()))
        }
        callFunctionUntilLsDataReceived(i) {
            let {func: r, startDue: s, intervalDuration: o, count: a} = new h1(i)
              , c = a ? Lt(a) : Ge();
            return li(s, o).pipe(c, Ge( () => r && r()))
        }
        callFunctionWhenLsIsNotConnected(i, r) {
            let {func: s, startDue: o, intervalDuration: a, count: c} = new h1(r ?? {})
              , l = c ? Lt(c) : In(this.lsStableState$)
              , u = Vt( () => i ? i() : Ur);
            return this.lsConnected$.pipe(D0(), mt(h => !h), Vt( () => li(o, a).pipe(l, Ge( () => typeof s == "function" && s()), u)))
        }
    }
    ;
    t.\u0275fac = function(r) {
        return new (r || t)
    }
    ,
    t.\u0275prov = re({
        token: t,
        factory: t.\u0275fac,
        providedIn: "root"
    });
    let e = t;
    return e
}
)()
  , h1 = class {
    constructor(t) {
        typeof t.func == "function" && (this.func = t.func),
        this.startDue = t?.startDue ?? 0,
        this.intervalDuration = t?.intervalDuration ?? 7e3,
        this.count = t.count ?? 0
    }
}
;
var Ux = ["symbolIsin", "stateCode", "lastTradedPrice", "closingPrice", "totalTradeValue", "totalNumberOfTrades", "feeOfPreviousDaysClosingPrice"]
  , iL = ["totalNumberOfSharesTraded", "priceVar", "stateCode", "lastTradedPrice", "symbolIsin"]
  , rL = ["symbolIsin", "stateCode", "closingPrice", "lastTradedPrice", "feeOfPreviousDaysClosingPrice", "totalNumberOfSharesTraded", "priceVar"]
  , sL = ["symbolIsin", "stateCode", "bestBuyPrice", "bestBuyQuantity", "bestSellPrice", "bestSellQuantity", "closingPrice", "feeOfPreviousDaysClosingPrice", "firstTradedPrice", "highAllowedPrice", "lastTradedPrice", "lowAllowedPrice", "priceVar", "symbolName", "totalNumberOfSharesTraded", "totalNumberOfTrades", "totalTradeValue", "lowPrice", "highPrice"]
  , oL = ["symbolIsin", "totalTradeValue", "totalNumberOfSharesTraded", "closingPrice", "feeOfPreviousDaysClosingPrice", "lastTradedPrice", "bestBuyQuantity", "bestSellQuantity", "bestBuyPrice", "bestSellPrice", "priceVar"]
  , aL = ["bestBuyPrice", "bestBuyQuantity", "bestSellPrice", "bestSellQuantity", "closingPrice", "feeOfPreviousDaysClosingPrice", "firstTradedPrice", "highAllowedPrice", "lastTradedPrice", "lowAllowedPrice", "priceVar", "stateCode", "symbolIsin", "symbolName", "totalNumberOfSharesTraded", "totalNumberOfTrades", "totalTradeValue", "lowPrice", "highPrice"]
  , cL = ["priceVar", "totalTradeValue", "lastTradedPrice", "symbolIsin", "totalNumberOfSharesTraded", "closingPrice"]
  , lL = ["symbolIsin", "stateCode", "lastTradedPrice", "priceVar", "closingPrice", "totalNumberOfSharesTraded", "feeOfPreviousDaysClosingPrice", "lowAllowedPrice", "highAllowedPrice"]
  , uL = ["minValidBuyVolume", "maxValidBuyVolume", "minValidSellVolume", "maxValidSellVolume", "lowAllowedPrice", "highAllowedPrice", "bidPrice", "askPrice", "priceTickSize"]
  , hL = ["symbolIsin", "stateCode", "bestBuyPrice", "bestBuyQuantity", "bestSellPrice", "bestSellQuantity", "closingPrice", "feeOfPreviousDaysClosingPrice", "firstTradedPrice", "highAllowedPrice", "lastTradedPrice", "lowAllowedPrice", "priceVar", "symbolName", "totalNumberOfSharesTraded", "totalNumberOfTrades", "totalTradeValue", "lowPrice", "highPrice"]
  , dL = [...Ux, "priceVar", "buyRatio", "sellRatio", "highPrice", "lowPrice", "bestBuyPrice", "bestBuyQuantity", "bestSellPrice", "bestSellQuantity", "firstTradedPrice", "lowAllowedPrice", "highAllowedPrice", "totalNumberOfSharesTraded"]
  , Hx = {
    0: dL,
    1: Ux,
    2: iL,
    3: cL,
    4: rL,
    5: aL,
    6: sL,
    7: oL,
    8: uL,
    9: lL,
    10: hL
};
var Qle = e => e.slice(-1) === "1" ? e.slice(0, -1) : e
  , Jle = e => {
    let t = e;
    return t = t.replace(/ /g, ""),
    t = t.replace(//g, ""),
    t = t.replace(//g, "\u0627"),
    t = t.replace(new RegExp("\u064A","g"), "\u06CC"),
    t = t.replace(new RegExp("\u0643","g"), "\u06A9"),
    t = t.replace(new RegExp("\u0637","g"), "\u062A"),
    t = t.replace(new RegExp("\u0647","g"), "\u062D"),
    t = t.replace(new RegExp("\u0630","g"), "\u0632"),
    t = t.replace(new RegExp("\u0638","g"), "\u0632"),
    t = t.replace(new RegExp("\u0636","g"), "\u0632"),
    t = t.replace(new RegExp("\u0635","g"), "\u0633"),
    t = t.replace(new RegExp("\u062B","g"), "\u0633"),
    t = t.replace(new RegExp("\u063A","g"), "\u0642"),
    t = t.replace(new RegExp("\u0621","g"), "\u0639"),
    t = t.replace(new RegExp("\u0626","g"), "\u0639"),
    t
}
  , Zle = e => {
    let t = e;
    return t = t.replace(//g, "\u0627"),
    t = t.replace(new RegExp("\u064A","g"), "\u06CC"),
    t = t.replace(new RegExp("\u0643","g"), "\u06A9"),
    t = t.replace(new RegExp("\u0637","g"), "\u062A"),
    t = t.replace(new RegExp("\u0647","g"), "\u062D"),
    t = t.replace(new RegExp("\u0630","g"), "\u0632"),
    t = t.replace(new RegExp("\u0638","g"), "\u0632"),
    t = t.replace(new RegExp("\u0636","g"), "\u0632"),
    t = t.replace(new RegExp("\u0635","g"), "\u0633"),
    t = t.replace(new RegExp("\u062B","g"), "\u0633"),
    t = t.replace(new RegExp("\u063A","g"), "\u0642"),
    t = t.replace(new RegExp("\u0621","g"), "\u0639"),
    t = t.replace(new RegExp("\u0626","g"), "\u0639"),
    t
}
;
var b1 = {};
b1.version = "0.18.5";
var e0 = 1200
  , zu = 1252
  , fL = [874, 932, 936, 949, 950, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1e4]
  , pL = {
    0: 1252,
    1: 65001,
    2: 65001,
    77: 1e4,
    128: 932,
    129: 949,
    130: 1361,
    134: 936,
    136: 950,
    161: 1253,
    162: 1254,
    163: 1258,
    177: 1255,
    178: 1256,
    186: 1257,
    204: 1251,
    222: 874,
    238: 1250,
    255: 1252,
    69: 6969
}
  , Ow = function(e) {
    fL.indexOf(e) != -1 && (zu = pL[0] = e)
};
function gL() {
    Ow(1252)
}
var S1 = function(e) {
    e0 = e,
    Ow(e)
};
function mL() {
    S1(1200),
    gL()
}
function vL(e) {
    for (var t = [], n = 0; n < e.length >> 1; ++n)
        t[n] = String.fromCharCode(e.charCodeAt(2 * n + 1) + (e.charCodeAt(2 * n) << 8));
    return t.join("")
}
var V3 = function(t) {
    return String.fromCharCode(t)
}, Gx = function(t) {
    return String.fromCharCode(t)
}, un;
var Jo = null
  , d1 = !0
  , Hc = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function x1(e) {
    for (var t = "", n = 0, i = 0, r = 0, s = 0, o = 0, a = 0, c = 0, l = 0; l < e.length; )
        n = e.charCodeAt(l++),
        s = n >> 2,
        i = e.charCodeAt(l++),
        o = (n & 3) << 4 | i >> 4,
        r = e.charCodeAt(l++),
        a = (i & 15) << 2 | r >> 6,
        c = r & 63,
        isNaN(i) ? a = c = 64 : isNaN(r) && (c = 64),
        t += Hc.charAt(s) + Hc.charAt(o) + Hc.charAt(a) + Hc.charAt(c);
    return t
}
function Ba(e) {
    var t = ""
      , n = 0
      , i = 0
      , r = 0
      , s = 0
      , o = 0
      , a = 0
      , c = 0;
    e = e.replace(/[^\w\+\/\=]/g, "");
    for (var l = 0; l < e.length; )
        s = Hc.indexOf(e.charAt(l++)),
        o = Hc.indexOf(e.charAt(l++)),
        n = s << 2 | o >> 4,
        t += String.fromCharCode(n),
        a = Hc.indexOf(e.charAt(l++)),
        i = (o & 15) << 4 | a >> 2,
        a !== 64 && (t += String.fromCharCode(i)),
        c = Hc.indexOf(e.charAt(l++)),
        r = (a & 3) << 6 | c,
        c !== 64 && (t += String.fromCharCode(r));
    return t
}
var zt = function() {
    return typeof Buffer < "u" && typeof process < "u" && typeof process.versions < "u" && !!process.versions.node
}()
  , Ha = function() {
    if (typeof Buffer < "u") {
        var e = !Buffer.from;
        if (!e)
            try {
                Buffer.from("foo", "utf8")
            } catch {
                e = !0
            }
        return e ? function(t, n) {
            return n ? new Buffer(t,n) : new Buffer(t)
        }
        : Buffer.from.bind(Buffer)
    }
    return function() {}
}();
function n0(e) {
    return zt ? Buffer.alloc ? Buffer.alloc(e) : new Buffer(e) : typeof Uint8Array < "u" ? new Uint8Array(e) : new Array(e)
}
function Vx(e) {
    return zt ? Buffer.allocUnsafe ? Buffer.allocUnsafe(e) : new Buffer(e) : typeof Uint8Array < "u" ? new Uint8Array(e) : new Array(e)
}
var uo = function(t) {
    return zt ? Ha(t, "binary") : t.split("").map(function(n) {
        return n.charCodeAt(0) & 255
    })
};
function u2(e) {
    if (typeof ArrayBuffer > "u")
        return uo(e);
    for (var t = new ArrayBuffer(e.length), n = new Uint8Array(t), i = 0; i != e.length; ++i)
        n[i] = e.charCodeAt(i) & 255;
    return t
}
function O1(e) {
    if (Array.isArray(e))
        return e.map(function(i) {
            return String.fromCharCode(i)
        }).join("");
    for (var t = [], n = 0; n < e.length; ++n)
        t[n] = String.fromCharCode(e[n]);
    return t.join("")
}
function _L(e) {
    if (typeof Uint8Array > "u")
        throw new Error("Unsupported");
    return new Uint8Array(e)
}
var $i = zt ? function(e) {
    return Buffer.concat(e.map(function(t) {
        return Buffer.isBuffer(t) ? t : Ha(t)
    }))
}
: function(e) {
    if (typeof Uint8Array < "u") {
        var t = 0
          , n = 0;
        for (t = 0; t < e.length; ++t)
            n += e[t].length;
        var i = new Uint8Array(n)
          , r = 0;
        for (t = 0,
        n = 0; t < e.length; n += r,
        ++t)
            if (r = e[t].length,
            e[t]instanceof Uint8Array)
                i.set(e[t], n);
            else {
                if (typeof e[t] == "string")
                    throw "wtf";
                i.set(new Uint8Array(e[t]), n)
            }
        return i
    }
    return [].concat.apply([], e.map(function(s) {
        return Array.isArray(s) ? s : [].slice.call(s)
    }))
}
;
function yL(e) {
    for (var t = [], n = 0, i = e.length + 250, r = n0(e.length + 255), s = 0; s < e.length; ++s) {
        var o = e.charCodeAt(s);
        if (o < 128)
            r[n++] = o;
        else if (o < 2048)
            r[n++] = 192 | o >> 6 & 31,
            r[n++] = 128 | o & 63;
        else if (o >= 55296 && o < 57344) {
            o = (o & 1023) + 64;
            var a = e.charCodeAt(++s) & 1023;
            r[n++] = 240 | o >> 8 & 7,
            r[n++] = 128 | o >> 2 & 63,
            r[n++] = 128 | a >> 6 & 15 | (o & 3) << 4,
            r[n++] = 128 | a & 63
        } else
            r[n++] = 224 | o >> 12 & 15,
            r[n++] = 128 | o >> 6 & 63,
            r[n++] = 128 | o & 63;
        n > i && (t.push(r.slice(0, n)),
        n = 0,
        r = n0(65535),
        i = 65530)
    }
    return t.push(r.slice(0, n)),
    $i(t)
}
var Vu = /\u0000/g
  , W3 = /[\u0001-\u0006]/g;
function Wu(e) {
    for (var t = "", n = e.length - 1; n >= 0; )
        t += e.charAt(n--);
    return t
}
function ho(e, t) {
    var n = "" + e;
    return n.length >= t ? n : Ln("0", t - n.length) + n
}
function S7(e, t) {
    var n = "" + e;
    return n.length >= t ? n : Ln(" ", t - n.length) + n
}
function Q3(e, t) {
    var n = "" + e;
    return n.length >= t ? n : n + Ln(" ", t - n.length)
}
function bL(e, t) {
    var n = "" + Math.round(e);
    return n.length >= t ? n : Ln("0", t - n.length) + n
}
function SL(e, t) {
    var n = "" + e;
    return n.length >= t ? n : Ln("0", t - n.length) + n
}
var Wx = Math.pow(2, 32);
function Lu(e, t) {
    if (e > Wx || e < -Wx)
        return bL(e, t);
    var n = Math.round(e);
    return SL(n, t)
}
function J3(e, t) {
    return t = t || 0,
    e.length >= 7 + t && (e.charCodeAt(t) | 32) === 103 && (e.charCodeAt(t + 1) | 32) === 101 && (e.charCodeAt(t + 2) | 32) === 110 && (e.charCodeAt(t + 3) | 32) === 101 && (e.charCodeAt(t + 4) | 32) === 114 && (e.charCodeAt(t + 5) | 32) === 97 && (e.charCodeAt(t + 6) | 32) === 108
}
var $x = [["Sun", "Sunday"], ["Mon", "Monday"], ["Tue", "Tuesday"], ["Wed", "Wednesday"], ["Thu", "Thursday"], ["Fri", "Friday"], ["Sat", "Saturday"]]
  , l7 = [["J", "Jan", "January"], ["F", "Feb", "February"], ["M", "Mar", "March"], ["A", "Apr", "April"], ["M", "May", "May"], ["J", "Jun", "June"], ["J", "Jul", "July"], ["A", "Aug", "August"], ["S", "Sep", "September"], ["O", "Oct", "October"], ["N", "Nov", "November"], ["D", "Dec", "December"]];
function xL(e) {
    return e || (e = {}),
    e[0] = "General",
    e[1] = "0",
    e[2] = "0.00",
    e[3] = "#,##0",
    e[4] = "#,##0.00",
    e[9] = "0%",
    e[10] = "0.00%",
    e[11] = "0.00E+00",
    e[12] = "# ?/?",
    e[13] = "# ??/??",
    e[14] = "m/d/yy",
    e[15] = "d-mmm-yy",
    e[16] = "d-mmm",
    e[17] = "mmm-yy",
    e[18] = "h:mm AM/PM",
    e[19] = "h:mm:ss AM/PM",
    e[20] = "h:mm",
    e[21] = "h:mm:ss",
    e[22] = "m/d/yy h:mm",
    e[37] = "#,##0 ;(#,##0)",
    e[38] = "#,##0 ;[Red](#,##0)",
    e[39] = "#,##0.00;(#,##0.00)",
    e[40] = "#,##0.00;[Red](#,##0.00)",
    e[45] = "mm:ss",
    e[46] = "[h]:mm:ss",
    e[47] = "mmss.0",
    e[48] = "##0.0E+0",
    e[49] = "@",
    e[56] = '"\u4E0A\u5348/\u4E0B\u5348 "hh"\u6642"mm"\u5206"ss"\u79D2 "',
    e
}
var Bn = {
    0: "General",
    1: "0",
    2: "0.00",
    3: "#,##0",
    4: "#,##0.00",
    9: "0%",
    10: "0.00%",
    11: "0.00E+00",
    12: "# ?/?",
    13: "# ??/??",
    14: "m/d/yy",
    15: "d-mmm-yy",
    16: "d-mmm",
    17: "mmm-yy",
    18: "h:mm AM/PM",
    19: "h:mm:ss AM/PM",
    20: "h:mm",
    21: "h:mm:ss",
    22: "m/d/yy h:mm",
    37: "#,##0 ;(#,##0)",
    38: "#,##0 ;[Red](#,##0)",
    39: "#,##0.00;(#,##0.00)",
    40: "#,##0.00;[Red](#,##0.00)",
    45: "mm:ss",
    46: "[h]:mm:ss",
    47: "mmss.0",
    48: "##0.0E+0",
    49: "@",
    56: '"\u4E0A\u5348/\u4E0B\u5348 "hh"\u6642"mm"\u5206"ss"\u79D2 "'
}
  , jx = {
    5: 37,
    6: 38,
    7: 39,
    8: 40,
    23: 0,
    24: 0,
    25: 0,
    26: 0,
    27: 14,
    28: 14,
    29: 14,
    30: 14,
    31: 14,
    50: 14,
    51: 14,
    52: 14,
    53: 14,
    54: 14,
    55: 14,
    56: 14,
    57: 14,
    58: 14,
    59: 1,
    60: 2,
    61: 3,
    62: 4,
    67: 9,
    68: 10,
    69: 12,
    70: 13,
    71: 14,
    72: 14,
    73: 15,
    74: 16,
    75: 17,
    76: 20,
    77: 21,
    78: 22,
    79: 45,
    80: 46,
    81: 47,
    82: 0
}
  , wL = {
    5: '"$"#,##0_);\\("$"#,##0\\)',
    63: '"$"#,##0_);\\("$"#,##0\\)',
    6: '"$"#,##0_);[Red]\\("$"#,##0\\)',
    64: '"$"#,##0_);[Red]\\("$"#,##0\\)',
    7: '"$"#,##0.00_);\\("$"#,##0.00\\)',
    65: '"$"#,##0.00_);\\("$"#,##0.00\\)',
    8: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
    66: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
    41: '_(* #,##0_);_(* \\(#,##0\\);_(* "-"_);_(@_)',
    42: '_("$"* #,##0_);_("$"* \\(#,##0\\);_("$"* "-"_);_(@_)',
    43: '_(* #,##0.00_);_(* \\(#,##0.00\\);_(* "-"??_);_(@_)',
    44: '_("$"* #,##0.00_);_("$"* \\(#,##0.00\\);_("$"* "-"??_);_(@_)'
};
function Z3(e, t, n) {
    for (var i = e < 0 ? -1 : 1, r = e * i, s = 0, o = 1, a = 0, c = 1, l = 0, u = 0, h = Math.floor(r); l < t && (h = Math.floor(r),
    a = h * o + s,
    u = h * l + c,
    !(r - h < 5e-8)); )
        r = 1 / (r - h),
        s = o,
        o = a,
        c = l,
        l = u;
    if (u > t && (l > t ? (u = c,
    a = s) : (u = l,
    a = o)),
    !n)
        return [0, i * a, u];
    var d = Math.floor(i * a / u);
    return [d, i * a - d * u, u]
}
function $3(e, t, n) {
    if (e > 2958465 || e < 0)
        return null;
    var i = e | 0
      , r = Math.floor(86400 * (e - i))
      , s = 0
      , o = []
      , a = {
        D: i,
        T: r,
        u: 86400 * (e - i) - r,
        y: 0,
        m: 0,
        d: 0,
        H: 0,
        M: 0,
        S: 0,
        q: 0
    };
    if (Math.abs(a.u) < 1e-6 && (a.u = 0),
    t && t.date1904 && (i += 1462),
    a.u > .9999 && (a.u = 0,
    ++r == 86400 && (a.T = r = 0,
    ++i,
    ++a.D)),
    i === 60)
        o = n ? [1317, 10, 29] : [1900, 2, 29],
        s = 3;
    else if (i === 0)
        o = n ? [1317, 8, 29] : [1900, 1, 0],
        s = 6;
    else {
        i > 60 && --i;
        var c = new Date(1900,0,1);
        c.setDate(c.getDate() + i - 1),
        o = [c.getFullYear(), c.getMonth() + 1, c.getDate()],
        s = c.getDay(),
        i < 60 && (s = (s + 6) % 7),
        n && (s = kL(c, o))
    }
    return a.y = o[0],
    a.m = o[1],
    a.d = o[2],
    a.S = r % 60,
    r = Math.floor(r / 60),
    a.M = r % 60,
    r = Math.floor(r / 60),
    a.H = r,
    a.q = s,
    a
}
var Pw = new Date(1899,11,31,0,0,0)
  , CL = Pw.getTime()
  , EL = new Date(1900,2,1,0,0,0);
function Mw(e, t) {
    var n = e.getTime();
    return t ? n -= 1461 * 24 * 60 * 60 * 1e3 : e >= EL && (n += 24 * 60 * 60 * 1e3),
    (n - (CL + (e.getTimezoneOffset() - Pw.getTimezoneOffset()) * 6e4)) / (24 * 60 * 60 * 1e3)
}
function x7(e) {
    return e.indexOf(".") == -1 ? e : e.replace(/(?:\.0*|(\.\d*[1-9])0+)$/, "$1")
}
function TL(e) {
    return e.indexOf("E") == -1 ? e : e.replace(/(?:\.0*|(\.\d*[1-9])0+)[Ee]/, "$1E").replace(/(E[+-])(\d)$/, "$10$2")
}
function OL(e) {
    var t = e < 0 ? 12 : 11
      , n = x7(e.toFixed(12));
    return n.length <= t || (n = e.toPrecision(10),
    n.length <= t) ? n : e.toExponential(5)
}
function PL(e) {
    var t = x7(e.toFixed(11));
    return t.length > (e < 0 ? 12 : 11) || t === "0" || t === "-0" ? e.toPrecision(6) : t
}
function ML(e) {
    var t = Math.floor(Math.log(Math.abs(e)) * Math.LOG10E), n;
    return t >= -4 && t <= -1 ? n = e.toPrecision(10 + t) : Math.abs(t) <= 9 ? n = OL(e) : t === 10 ? n = e.toFixed(10).substr(0, 12) : n = PL(e),
    x7(TL(n.toUpperCase()))
}
function v7(e, t) {
    switch (typeof e) {
    case "string":
        return e;
    case "boolean":
        return e ? "TRUE" : "FALSE";
    case "number":
        return (e | 0) === e ? e.toString(10) : ML(e);
    case "undefined":
        return "";
    case "object":
        if (e == null)
            return "";
        if (e instanceof Date)
            return Vc(14, Mw(e, t && t.date1904), t)
    }
    throw new Error("unsupported value in General format: " + e)
}
function kL(e, t) {
    t[0] -= 581;
    var n = e.getDay();
    return e < 60 && (n = (n + 6) % 7),
    n
}
function AL(e, t, n, i) {
    var r = "", s = 0, o = 0, a = n.y, c, l = 0;
    switch (e) {
    case 98:
        a = n.y + 543;
    case 121:
        switch (t.length) {
        case 1:
        case 2:
            c = a % 100,
            l = 2;
            break;
        default:
            c = a % 1e4,
            l = 4;
            break
        }
        break;
    case 109:
        switch (t.length) {
        case 1:
        case 2:
            c = n.m,
            l = t.length;
            break;
        case 3:
            return l7[n.m - 1][1];
        case 5:
            return l7[n.m - 1][0];
        default:
            return l7[n.m - 1][2]
        }
        break;
    case 100:
        switch (t.length) {
        case 1:
        case 2:
            c = n.d,
            l = t.length;
            break;
        case 3:
            return $x[n.q][0];
        default:
            return $x[n.q][1]
        }
        break;
    case 104:
        switch (t.length) {
        case 1:
        case 2:
            c = 1 + (n.H + 11) % 12,
            l = t.length;
            break;
        default:
            throw "bad hour format: " + t
        }
        break;
    case 72:
        switch (t.length) {
        case 1:
        case 2:
            c = n.H,
            l = t.length;
            break;
        default:
            throw "bad hour format: " + t
        }
        break;
    case 77:
        switch (t.length) {
        case 1:
        case 2:
            c = n.M,
            l = t.length;
            break;
        default:
            throw "bad minute format: " + t
        }
        break;
    case 115:
        if (t != "s" && t != "ss" && t != ".0" && t != ".00" && t != ".000")
            throw "bad second format: " + t;
        return n.u === 0 && (t == "s" || t == "ss") ? ho(n.S, t.length) : (i >= 2 ? o = i === 3 ? 1e3 : 100 : o = i === 1 ? 10 : 1,
        s = Math.round(o * (n.S + n.u)),
        s >= 60 * o && (s = 0),
        t === "s" ? s === 0 ? "0" : "" + s / o : (r = ho(s, 2 + i),
        t === "ss" ? r.substr(0, 2) : "." + r.substr(2, t.length - 1)));
    case 90:
        switch (t) {
        case "[h]":
        case "[hh]":
            c = n.D * 24 + n.H;
            break;
        case "[m]":
        case "[mm]":
            c = (n.D * 24 + n.H) * 60 + n.M;
            break;
        case "[s]":
        case "[ss]":
            c = ((n.D * 24 + n.H) * 60 + n.M) * 60 + Math.round(n.S + n.u);
            break;
        default:
            throw "bad abstime format: " + t
        }
        l = t.length === 3 ? 1 : 2;
        break;
    case 101:
        c = a,
        l = 1;
        break
    }
    var u = l > 0 ? ho(c, l) : "";
    return u
}
function Gc(e) {
    var t = 3;
    if (e.length <= t)
        return e;
    for (var n = e.length % t, i = e.substr(0, n); n != e.length; n += t)
        i += (i.length > 0 ? "," : "") + e.substr(n, t);
    return i
}
var kw = /%/g;
function IL(e, t, n) {
    var i = t.replace(kw, "")
      , r = t.length - i.length;
    return Na(e, i, n * Math.pow(10, 2 * r)) + Ln("%", r)
}
function RL(e, t, n) {
    for (var i = t.length - 1; t.charCodeAt(i - 1) === 44; )
        --i;
    return Na(e, t.substr(0, i), n / Math.pow(10, 3 * (t.length - i)))
}
function Aw(e, t) {
    var n, i = e.indexOf("E") - e.indexOf(".") - 1;
    if (e.match(/^#+0.0E\+0$/)) {
        if (t == 0)
            return "0.0E+0";
        if (t < 0)
            return "-" + Aw(e, -t);
        var r = e.indexOf(".");
        r === -1 && (r = e.indexOf("E"));
        var s = Math.floor(Math.log(t) * Math.LOG10E) % r;
        if (s < 0 && (s += r),
        n = (t / Math.pow(10, s)).toPrecision(i + 1 + (r + s) % r),
        n.indexOf("e") === -1) {
            var o = Math.floor(Math.log(t) * Math.LOG10E);
            for (n.indexOf(".") === -1 ? n = n.charAt(0) + "." + n.substr(1) + "E+" + (o - n.length + s) : n += "E+" + (o - s); n.substr(0, 2) === "0."; )
                n = n.charAt(0) + n.substr(2, r) + "." + n.substr(2 + r),
                n = n.replace(/^0+([1-9])/, "$1").replace(/^0+\./, "0.");
            n = n.replace(/\+-/, "-")
        }
        n = n.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function(a, c, l, u) {
            return c + l + u.substr(0, (r + s) % r) + "." + u.substr(s) + "E"
        })
    } else
        n = t.toExponential(i);
    return e.match(/E\+00$/) && n.match(/e[+-]\d$/) && (n = n.substr(0, n.length - 1) + "0" + n.charAt(n.length - 1)),
    e.match(/E\-/) && n.match(/e\+/) && (n = n.replace(/e\+/, "e")),
    n.replace("e", "E")
}
var Iw = /# (\?+)( ?)\/( ?)(\d+)/;
function DL(e, t, n) {
    var i = parseInt(e[4], 10)
      , r = Math.round(t * i)
      , s = Math.floor(r / i)
      , o = r - s * i
      , a = i;
    return n + (s === 0 ? "" : "" + s) + " " + (o === 0 ? Ln(" ", e[1].length + 1 + e[4].length) : S7(o, e[1].length) + e[2] + "/" + e[3] + ho(a, e[4].length))
}
function NL(e, t, n) {
    return n + (t === 0 ? "" : "" + t) + Ln(" ", e[1].length + 2 + e[4].length)
}
var Rw = /^#*0*\.([0#]+)/
  , Dw = /\).*[0#]/
  , Nw = /\(###\) ###\\?-####/;
function Pr(e) {
    for (var t = "", n, i = 0; i != e.length; ++i)
        switch (n = e.charCodeAt(i)) {
        case 35:
            break;
        case 63:
            t += " ";
            break;
        case 48:
            t += "0";
            break;
        default:
            t += String.fromCharCode(n)
        }
    return t
}
function qx(e, t) {
    var n = Math.pow(10, t);
    return "" + Math.round(e * n) / n
}
function zx(e, t) {
    var n = e - Math.floor(e)
      , i = Math.pow(10, t);
    return t < ("" + Math.round(n * i)).length ? 0 : Math.round(n * i)
}
function FL(e, t) {
    return t < ("" + Math.round((e - Math.floor(e)) * Math.pow(10, t))).length ? 1 : 0
}
function LL(e) {
    return e < 2147483647 && e > -2147483648 ? "" + (e >= 0 ? e | 0 : e - 1 | 0) : "" + Math.floor(e)
}
function Fs(e, t, n) {
    if (e.charCodeAt(0) === 40 && !t.match(Dw)) {
        var i = t.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
        return n >= 0 ? Fs("n", i, n) : "(" + Fs("n", i, -n) + ")"
    }
    if (t.charCodeAt(t.length - 1) === 44)
        return RL(e, t, n);
    if (t.indexOf("%") !== -1)
        return IL(e, t, n);
    if (t.indexOf("E") !== -1)
        return Aw(t, n);
    if (t.charCodeAt(0) === 36)
        return "$" + Fs(e, t.substr(t.charAt(1) == " " ? 2 : 1), n);
    var r, s, o, a, c = Math.abs(n), l = n < 0 ? "-" : "";
    if (t.match(/^00+$/))
        return l + Lu(c, t.length);
    if (t.match(/^[#?]+$/))
        return r = Lu(n, 0),
        r === "0" && (r = ""),
        r.length > t.length ? r : Pr(t.substr(0, t.length - r.length)) + r;
    if (s = t.match(Iw))
        return DL(s, c, l);
    if (t.match(/^#+0+$/))
        return l + Lu(c, t.length - t.indexOf("0"));
    if (s = t.match(Rw))
        return r = qx(n, s[1].length).replace(/^([^\.]+)$/, "$1." + Pr(s[1])).replace(/\.$/, "." + Pr(s[1])).replace(/\.(\d*)$/, function(g, p) {
            return "." + p + Ln("0", Pr(s[1]).length - p.length)
        }),
        t.indexOf("0.") !== -1 ? r : r.replace(/^0\./, ".");
    if (t = t.replace(/^#+([0.])/, "$1"),
    s = t.match(/^(0*)\.(#*)$/))
        return l + qx(c, s[2].length).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, s[1].length ? "0." : ".");
    if (s = t.match(/^#{1,3},##0(\.?)$/))
        return l + Gc(Lu(c, 0));
    if (s = t.match(/^#,##0\.([#0]*0)$/))
        return n < 0 ? "-" + Fs(e, t, -n) : Gc("" + (Math.floor(n) + FL(n, s[1].length))) + "." + ho(zx(n, s[1].length), s[1].length);
    if (s = t.match(/^#,#*,#0/))
        return Fs(e, t.replace(/^#,#*,/, ""), n);
    if (s = t.match(/^([0#]+)(\\?-([0#]+))+$/))
        return r = Wu(Fs(e, t.replace(/[\\-]/g, ""), n)),
        o = 0,
        Wu(Wu(t.replace(/\\/g, "")).replace(/[0#]/g, function(g) {
            return o < r.length ? r.charAt(o++) : g === "0" ? "0" : ""
        }));
    if (t.match(Nw))
        return r = Fs(e, "##########", n),
        "(" + r.substr(0, 3) + ") " + r.substr(3, 3) + "-" + r.substr(6);
    var u = "";
    if (s = t.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/))
        return o = Math.min(s[4].length, 7),
        a = Z3(c, Math.pow(10, o) - 1, !1),
        r = "" + l,
        u = Na("n", s[1], a[1]),
        u.charAt(u.length - 1) == " " && (u = u.substr(0, u.length - 1) + "0"),
        r += u + s[2] + "/" + s[3],
        u = Q3(a[2], o),
        u.length < s[4].length && (u = Pr(s[4].substr(s[4].length - u.length)) + u),
        r += u,
        r;
    if (s = t.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/))
        return o = Math.min(Math.max(s[1].length, s[4].length), 7),
        a = Z3(c, Math.pow(10, o) - 1, !0),
        l + (a[0] || (a[1] ? "" : "0")) + " " + (a[1] ? S7(a[1], o) + s[2] + "/" + s[3] + Q3(a[2], o) : Ln(" ", 2 * o + 1 + s[2].length + s[3].length));
    if (s = t.match(/^[#0?]+$/))
        return r = Lu(n, 0),
        t.length <= r.length ? r : Pr(t.substr(0, t.length - r.length)) + r;
    if (s = t.match(/^([#0?]+)\.([#0]+)$/)) {
        r = "" + n.toFixed(Math.min(s[2].length, 10)).replace(/([^0])0+$/, "$1"),
        o = r.indexOf(".");
        var h = t.indexOf(".") - o
          , d = t.length - r.length - h;
        return Pr(t.substr(0, h) + r + t.substr(t.length - d))
    }
    if (s = t.match(/^00,000\.([#0]*0)$/))
        return o = zx(n, s[1].length),
        n < 0 ? "-" + Fs(e, t, -n) : Gc(LL(n)).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function(g) {
            return "00," + (g.length < 3 ? ho(0, 3 - g.length) : "") + g
        }) + "." + ho(o, s[1].length);
    switch (t) {
    case "###,##0.00":
        return Fs(e, "#,##0.00", n);
    case "###,###":
    case "##,###":
    case "#,###":
        var f = Gc(Lu(c, 0));
        return f !== "0" ? l + f : "";
    case "###,###.00":
        return Fs(e, "###,##0.00", n).replace(/^0\./, ".");
    case "#,###.00":
        return Fs(e, "#,##0.00", n).replace(/^0\./, ".");
    default:
    }
    throw new Error("unsupported format |" + t + "|")
}
function BL(e, t, n) {
    for (var i = t.length - 1; t.charCodeAt(i - 1) === 44; )
        --i;
    return Na(e, t.substr(0, i), n / Math.pow(10, 3 * (t.length - i)))
}
function UL(e, t, n) {
    var i = t.replace(kw, "")
      , r = t.length - i.length;
    return Na(e, i, n * Math.pow(10, 2 * r)) + Ln("%", r)
}
function Fw(e, t) {
    var n, i = e.indexOf("E") - e.indexOf(".") - 1;
    if (e.match(/^#+0.0E\+0$/)) {
        if (t == 0)
            return "0.0E+0";
        if (t < 0)
            return "-" + Fw(e, -t);
        var r = e.indexOf(".");
        r === -1 && (r = e.indexOf("E"));
        var s = Math.floor(Math.log(t) * Math.LOG10E) % r;
        if (s < 0 && (s += r),
        n = (t / Math.pow(10, s)).toPrecision(i + 1 + (r + s) % r),
        !n.match(/[Ee]/)) {
            var o = Math.floor(Math.log(t) * Math.LOG10E);
            n.indexOf(".") === -1 ? n = n.charAt(0) + "." + n.substr(1) + "E+" + (o - n.length + s) : n += "E+" + (o - s),
            n = n.replace(/\+-/, "-")
        }
        n = n.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function(a, c, l, u) {
            return c + l + u.substr(0, (r + s) % r) + "." + u.substr(s) + "E"
        })
    } else
        n = t.toExponential(i);
    return e.match(/E\+00$/) && n.match(/e[+-]\d$/) && (n = n.substr(0, n.length - 1) + "0" + n.charAt(n.length - 1)),
    e.match(/E\-/) && n.match(/e\+/) && (n = n.replace(/e\+/, "e")),
    n.replace("e", "E")
}
function Yo(e, t, n) {
    if (e.charCodeAt(0) === 40 && !t.match(Dw)) {
        var i = t.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
        return n >= 0 ? Yo("n", i, n) : "(" + Yo("n", i, -n) + ")"
    }
    if (t.charCodeAt(t.length - 1) === 44)
        return BL(e, t, n);
    if (t.indexOf("%") !== -1)
        return UL(e, t, n);
    if (t.indexOf("E") !== -1)
        return Fw(t, n);
    if (t.charCodeAt(0) === 36)
        return "$" + Yo(e, t.substr(t.charAt(1) == " " ? 2 : 1), n);
    var r, s, o, a, c = Math.abs(n), l = n < 0 ? "-" : "";
    if (t.match(/^00+$/))
        return l + ho(c, t.length);
    if (t.match(/^[#?]+$/))
        return r = "" + n,
        n === 0 && (r = ""),
        r.length > t.length ? r : Pr(t.substr(0, t.length - r.length)) + r;
    if (s = t.match(Iw))
        return NL(s, c, l);
    if (t.match(/^#+0+$/))
        return l + ho(c, t.length - t.indexOf("0"));
    if (s = t.match(Rw))
        return r = ("" + n).replace(/^([^\.]+)$/, "$1." + Pr(s[1])).replace(/\.$/, "." + Pr(s[1])),
        r = r.replace(/\.(\d*)$/, function(g, p) {
            return "." + p + Ln("0", Pr(s[1]).length - p.length)
        }),
        t.indexOf("0.") !== -1 ? r : r.replace(/^0\./, ".");
    if (t = t.replace(/^#+([0.])/, "$1"),
    s = t.match(/^(0*)\.(#*)$/))
        return l + ("" + c).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, s[1].length ? "0." : ".");
    if (s = t.match(/^#{1,3},##0(\.?)$/))
        return l + Gc("" + c);
    if (s = t.match(/^#,##0\.([#0]*0)$/))
        return n < 0 ? "-" + Yo(e, t, -n) : Gc("" + n) + "." + Ln("0", s[1].length);
    if (s = t.match(/^#,#*,#0/))
        return Yo(e, t.replace(/^#,#*,/, ""), n);
    if (s = t.match(/^([0#]+)(\\?-([0#]+))+$/))
        return r = Wu(Yo(e, t.replace(/[\\-]/g, ""), n)),
        o = 0,
        Wu(Wu(t.replace(/\\/g, "")).replace(/[0#]/g, function(g) {
            return o < r.length ? r.charAt(o++) : g === "0" ? "0" : ""
        }));
    if (t.match(Nw))
        return r = Yo(e, "##########", n),
        "(" + r.substr(0, 3) + ") " + r.substr(3, 3) + "-" + r.substr(6);
    var u = "";
    if (s = t.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/))
        return o = Math.min(s[4].length, 7),
        a = Z3(c, Math.pow(10, o) - 1, !1),
        r = "" + l,
        u = Na("n", s[1], a[1]),
        u.charAt(u.length - 1) == " " && (u = u.substr(0, u.length - 1) + "0"),
        r += u + s[2] + "/" + s[3],
        u = Q3(a[2], o),
        u.length < s[4].length && (u = Pr(s[4].substr(s[4].length - u.length)) + u),
        r += u,
        r;
    if (s = t.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/))
        return o = Math.min(Math.max(s[1].length, s[4].length), 7),
        a = Z3(c, Math.pow(10, o) - 1, !0),
        l + (a[0] || (a[1] ? "" : "0")) + " " + (a[1] ? S7(a[1], o) + s[2] + "/" + s[3] + Q3(a[2], o) : Ln(" ", 2 * o + 1 + s[2].length + s[3].length));
    if (s = t.match(/^[#0?]+$/))
        return r = "" + n,
        t.length <= r.length ? r : Pr(t.substr(0, t.length - r.length)) + r;
    if (s = t.match(/^([#0]+)\.([#0]+)$/)) {
        r = "" + n.toFixed(Math.min(s[2].length, 10)).replace(/([^0])0+$/, "$1"),
        o = r.indexOf(".");
        var h = t.indexOf(".") - o
          , d = t.length - r.length - h;
        return Pr(t.substr(0, h) + r + t.substr(t.length - d))
    }
    if (s = t.match(/^00,000\.([#0]*0)$/))
        return n < 0 ? "-" + Yo(e, t, -n) : Gc("" + n).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function(g) {
            return "00," + (g.length < 3 ? ho(0, 3 - g.length) : "") + g
        }) + "." + ho(0, s[1].length);
    switch (t) {
    case "###,###":
    case "##,###":
    case "#,###":
        var f = Gc("" + c);
        return f !== "0" ? l + f : "";
    default:
        if (t.match(/\.[0#?]*$/))
            return Yo(e, t.slice(0, t.lastIndexOf(".")), n) + Pr(t.slice(t.lastIndexOf(".")))
    }
    throw new Error("unsupported format |" + t + "|")
}
function Na(e, t, n) {
    return (n | 0) === n ? Yo(e, t, n) : Fs(e, t, n)
}
function HL(e) {
    for (var t = [], n = !1, i = 0, r = 0; i < e.length; ++i)
        switch (e.charCodeAt(i)) {
        case 34:
            n = !n;
            break;
        case 95:
        case 42:
        case 92:
            ++i;
            break;
        case 59:
            t[t.length] = e.substr(r, i - r),
            r = i + 1
        }
    if (t[t.length] = e.substr(r),
    n === !0)
        throw new Error("Format |" + e + "| unterminated string ");
    return t
}
var Lw = /\[[HhMmSs\u0E0A\u0E19\u0E17]*\]/;
function Bw(e) {
    for (var t = 0, n = "", i = ""; t < e.length; )
        switch (n = e.charAt(t)) {
        case "G":
            J3(e, t) && (t += 6),
            t++;
            break;
        case '"':
            for (; e.charCodeAt(++t) !== 34 && t < e.length; )
                ;
            ++t;
            break;
        case "\\":
            t += 2;
            break;
        case "_":
            t += 2;
            break;
        case "@":
            ++t;
            break;
        case "B":
        case "b":
            if (e.charAt(t + 1) === "1" || e.charAt(t + 1) === "2")
                return !0;
        case "M":
        case "D":
        case "Y":
        case "H":
        case "S":
        case "E":
        case "m":
        case "d":
        case "y":
        case "h":
        case "s":
        case "e":
        case "g":
            return !0;
        case "A":
        case "a":
        case "\u4E0A":
            if (e.substr(t, 3).toUpperCase() === "A/P" || e.substr(t, 5).toUpperCase() === "AM/PM" || e.substr(t, 5).toUpperCase() === "\u4E0A\u5348/\u4E0B\u5348")
                return !0;
            ++t;
            break;
        case "[":
            for (i = n; e.charAt(t++) !== "]" && t < e.length; )
                i += e.charAt(t);
            if (i.match(Lw))
                return !0;
            break;
        case ".":
        case "0":
        case "#":
            for (; t < e.length && ("0#?.,E+-%".indexOf(n = e.charAt(++t)) > -1 || n == "\\" && e.charAt(t + 1) == "-" && "0#".indexOf(e.charAt(t + 2)) > -1); )
                ;
            break;
        case "?":
            for (; e.charAt(++t) === n; )
                ;
            break;
        case "*":
            ++t,
            (e.charAt(t) == " " || e.charAt(t) == "*") && ++t;
            break;
        case "(":
        case ")":
            ++t;
            break;
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
            for (; t < e.length && "0123456789".indexOf(e.charAt(++t)) > -1; )
                ;
            break;
        case " ":
            ++t;
            break;
        default:
            ++t;
            break
        }
    return !1
}
function GL(e, t, n, i) {
    for (var r = [], s = "", o = 0, a = "", c = "t", l, u, h, d = "H"; o < e.length; )
        switch (a = e.charAt(o)) {
        case "G":
            if (!J3(e, o))
                throw new Error("unrecognized character " + a + " in " + e);
            r[r.length] = {
                t: "G",
                v: "General"
            },
            o += 7;
            break;
        case '"':
            for (s = ""; (h = e.charCodeAt(++o)) !== 34 && o < e.length; )
                s += String.fromCharCode(h);
            r[r.length] = {
                t: "t",
                v: s
            },
            ++o;
            break;
        case "\\":
            var f = e.charAt(++o)
              , g = f === "(" || f === ")" ? f : "t";
            r[r.length] = {
                t: g,
                v: f
            },
            ++o;
            break;
        case "_":
            r[r.length] = {
                t: "t",
                v: " "
            },
            o += 2;
            break;
        case "@":
            r[r.length] = {
                t: "T",
                v: t
            },
            ++o;
            break;
        case "B":
        case "b":
            if (e.charAt(o + 1) === "1" || e.charAt(o + 1) === "2") {
                if (l == null && (l = $3(t, n, e.charAt(o + 1) === "2"),
                l == null))
                    return "";
                r[r.length] = {
                    t: "X",
                    v: e.substr(o, 2)
                },
                c = a,
                o += 2;
                break
            }
        case "M":
        case "D":
        case "Y":
        case "H":
        case "S":
        case "E":
            a = a.toLowerCase();
        case "m":
        case "d":
        case "y":
        case "h":
        case "s":
        case "e":
        case "g":
            if (t < 0 || l == null && (l = $3(t, n),
            l == null))
                return "";
            for (s = a; ++o < e.length && e.charAt(o).toLowerCase() === a; )
                s += a;
            a === "m" && c.toLowerCase() === "h" && (a = "M"),
            a === "h" && (a = d),
            r[r.length] = {
                t: a,
                v: s
            },
            c = a;
            break;
        case "A":
        case "a":
        case "\u4E0A":
            var p = {
                t: a,
                v: a
            };
            if (l == null && (l = $3(t, n)),
            e.substr(o, 3).toUpperCase() === "A/P" ? (l != null && (p.v = l.H >= 12 ? "P" : "A"),
            p.t = "T",
            d = "h",
            o += 3) : e.substr(o, 5).toUpperCase() === "AM/PM" ? (l != null && (p.v = l.H >= 12 ? "PM" : "AM"),
            p.t = "T",
            o += 5,
            d = "h") : e.substr(o, 5).toUpperCase() === "\u4E0A\u5348/\u4E0B\u5348" ? (l != null && (p.v = l.H >= 12 ? "\u4E0B\u5348" : "\u4E0A\u5348"),
            p.t = "T",
            o += 5,
            d = "h") : (p.t = "t",
            ++o),
            l == null && p.t === "T")
                return "";
            r[r.length] = p,
            c = a;
            break;
        case "[":
            for (s = a; e.charAt(o++) !== "]" && o < e.length; )
                s += e.charAt(o);
            if (s.slice(-1) !== "]")
                throw 'unterminated "[" block: |' + s + "|";
            if (s.match(Lw)) {
                if (l == null && (l = $3(t, n),
                l == null))
                    return "";
                r[r.length] = {
                    t: "Z",
                    v: s.toLowerCase()
                },
                c = s.charAt(1)
            } else
                s.indexOf("$") > -1 && (s = (s.match(/\$([^-\[\]]*)/) || [])[1] || "$",
                Bw(e) || (r[r.length] = {
                    t: "t",
                    v: s
                }));
            break;
        case ".":
            if (l != null) {
                for (s = a; ++o < e.length && (a = e.charAt(o)) === "0"; )
                    s += a;
                r[r.length] = {
                    t: "s",
                    v: s
                };
                break
            }
        case "0":
        case "#":
            for (s = a; ++o < e.length && "0#?.,E+-%".indexOf(a = e.charAt(o)) > -1; )
                s += a;
            r[r.length] = {
                t: "n",
                v: s
            };
            break;
        case "?":
            for (s = a; e.charAt(++o) === a; )
                s += a;
            r[r.length] = {
                t: a,
                v: s
            },
            c = a;
            break;
        case "*":
            ++o,
            (e.charAt(o) == " " || e.charAt(o) == "*") && ++o;
            break;
        case "(":
        case ")":
            r[r.length] = {
                t: i === 1 ? "t" : a,
                v: a
            },
            ++o;
            break;
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
            for (s = a; o < e.length && "0123456789".indexOf(e.charAt(++o)) > -1; )
                s += e.charAt(o);
            r[r.length] = {
                t: "D",
                v: s
            };
            break;
        case " ":
            r[r.length] = {
                t: a,
                v: a
            },
            ++o;
            break;
        case "$":
            r[r.length] = {
                t: "t",
                v: "$"
            },
            ++o;
            break;
        default:
            if (",$-+/():!^&'~{}<>=\u20ACacfijklopqrtuvwxzP".indexOf(a) === -1)
                throw new Error("unrecognized character " + a + " in " + e);
            r[r.length] = {
                t: "t",
                v: a
            },
            ++o;
            break
        }
    var v = 0, b = 0, S;
    for (o = r.length - 1,
    c = "t"; o >= 0; --o)
        switch (r[o].t) {
        case "h":
        case "H":
            r[o].t = d,
            c = "h",
            v < 1 && (v = 1);
            break;
        case "s":
            (S = r[o].v.match(/\.0+$/)) && (b = Math.max(b, S[0].length - 1)),
            v < 3 && (v = 3);
        case "d":
        case "y":
        case "M":
        case "e":
            c = r[o].t;
            break;
        case "m":
            c === "s" && (r[o].t = "M",
            v < 2 && (v = 2));
            break;
        case "X":
            break;
        case "Z":
            v < 1 && r[o].v.match(/[Hh]/) && (v = 1),
            v < 2 && r[o].v.match(/[Mm]/) && (v = 2),
            v < 3 && r[o].v.match(/[Ss]/) && (v = 3)
        }
    switch (v) {
    case 0:
        break;
    case 1:
        l.u >= .5 && (l.u = 0,
        ++l.S),
        l.S >= 60 && (l.S = 0,
        ++l.M),
        l.M >= 60 && (l.M = 0,
        ++l.H);
        break;
    case 2:
        l.u >= .5 && (l.u = 0,
        ++l.S),
        l.S >= 60 && (l.S = 0,
        ++l.M);
        break
    }
    var w = "", k;
    for (o = 0; o < r.length; ++o)
        switch (r[o].t) {
        case "t":
        case "T":
        case " ":
        case "D":
            break;
        case "X":
            r[o].v = "",
            r[o].t = ";";
            break;
        case "d":
        case "m":
        case "y":
        case "h":
        case "H":
        case "M":
        case "s":
        case "e":
        case "b":
        case "Z":
            r[o].v = AL(r[o].t.charCodeAt(0), r[o].v, l, b),
            r[o].t = "t";
            break;
        case "n":
        case "?":
            for (k = o + 1; r[k] != null && ((a = r[k].t) === "?" || a === "D" || (a === " " || a === "t") && r[k + 1] != null && (r[k + 1].t === "?" || r[k + 1].t === "t" && r[k + 1].v === "/") || r[o].t === "(" && (a === " " || a === "n" || a === ")") || a === "t" && (r[k].v === "/" || r[k].v === " " && r[k + 1] != null && r[k + 1].t == "?")); )
                r[o].v += r[k].v,
                r[k] = {
                    v: "",
                    t: ";"
                },
                ++k;
            w += r[o].v,
            o = k - 1;
            break;
        case "G":
            r[o].t = "t",
            r[o].v = v7(t, n);
            break
        }
    var B = "", N, E;
    if (w.length > 0) {
        w.charCodeAt(0) == 40 ? (N = t < 0 && w.charCodeAt(0) === 45 ? -t : t,
        E = Na("n", w, N)) : (N = t < 0 && i > 1 ? -t : t,
        E = Na("n", w, N),
        N < 0 && r[0] && r[0].t == "t" && (E = E.substr(1),
        r[0].v = "-" + r[0].v)),
        k = E.length - 1;
        var F = r.length;
        for (o = 0; o < r.length; ++o)
            if (r[o] != null && r[o].t != "t" && r[o].v.indexOf(".") > -1) {
                F = o;
                break
            }
        var O = r.length;
        if (F === r.length && E.indexOf("E") === -1) {
            for (o = r.length - 1; o >= 0; --o)
                r[o] == null || "n?".indexOf(r[o].t) === -1 || (k >= r[o].v.length - 1 ? (k -= r[o].v.length,
                r[o].v = E.substr(k + 1, r[o].v.length)) : k < 0 ? r[o].v = "" : (r[o].v = E.substr(0, k + 1),
                k = -1),
                r[o].t = "t",
                O = o);
            k >= 0 && O < r.length && (r[O].v = E.substr(0, k + 1) + r[O].v)
        } else if (F !== r.length && E.indexOf("E") === -1) {
            for (k = E.indexOf(".") - 1,
            o = F; o >= 0; --o)
                if (!(r[o] == null || "n?".indexOf(r[o].t) === -1)) {
                    for (u = r[o].v.indexOf(".") > -1 && o === F ? r[o].v.indexOf(".") - 1 : r[o].v.length - 1,
                    B = r[o].v.substr(u + 1); u >= 0; --u)
                        k >= 0 && (r[o].v.charAt(u) === "0" || r[o].v.charAt(u) === "#") && (B = E.charAt(k--) + B);
                    r[o].v = B,
                    r[o].t = "t",
                    O = o
                }
            for (k >= 0 && O < r.length && (r[O].v = E.substr(0, k + 1) + r[O].v),
            k = E.indexOf(".") + 1,
            o = F; o < r.length; ++o)
                if (!(r[o] == null || "n?(".indexOf(r[o].t) === -1 && o !== F)) {
                    for (u = r[o].v.indexOf(".") > -1 && o === F ? r[o].v.indexOf(".") + 1 : 0,
                    B = r[o].v.substr(0, u); u < r[o].v.length; ++u)
                        k < E.length && (B += E.charAt(k++));
                    r[o].v = B,
                    r[o].t = "t",
                    O = o
                }
        }
    }
    for (o = 0; o < r.length; ++o)
        r[o] != null && "n?".indexOf(r[o].t) > -1 && (N = i > 1 && t < 0 && o > 0 && r[o - 1].v === "-" ? -t : t,
        r[o].v = Na(r[o].t, r[o].v, N),
        r[o].t = "t");
    var V = "";
    for (o = 0; o !== r.length; ++o)
        r[o] != null && (V += r[o].v);
    return V
}
var Xx = /\[(=|>[=]?|<[>=]?)(-?\d+(?:\.\d*)?)\]/;
function Kx(e, t) {
    if (t == null)
        return !1;
    var n = parseFloat(t[2]);
    switch (t[1]) {
    case "=":
        if (e == n)
            return !0;
        break;
    case ">":
        if (e > n)
            return !0;
        break;
    case "<":
        if (e < n)
            return !0;
        break;
    case "<>":
        if (e != n)
            return !0;
        break;
    case ">=":
        if (e >= n)
            return !0;
        break;
    case "<=":
        if (e <= n)
            return !0;
        break
    }
    return !1
}
function VL(e, t) {
    var n = HL(e)
      , i = n.length
      , r = n[i - 1].indexOf("@");
    if (i < 4 && r > -1 && --i,
    n.length > 4)
        throw new Error("cannot find right format for |" + n.join("|") + "|");
    if (typeof t != "number")
        return [4, n.length === 4 || r > -1 ? n[n.length - 1] : "@"];
    switch (n.length) {
    case 1:
        n = r > -1 ? ["General", "General", "General", n[0]] : [n[0], n[0], n[0], "@"];
        break;
    case 2:
        n = r > -1 ? [n[0], n[0], n[0], n[1]] : [n[0], n[1], n[0], "@"];
        break;
    case 3:
        n = r > -1 ? [n[0], n[1], n[0], n[2]] : [n[0], n[1], n[2], "@"];
        break;
    case 4:
        break
    }
    var s = t > 0 ? n[0] : t < 0 ? n[1] : n[2];
    if (n[0].indexOf("[") === -1 && n[1].indexOf("[") === -1)
        return [i, s];
    if (n[0].match(/\[[=<>]/) != null || n[1].match(/\[[=<>]/) != null) {
        var o = n[0].match(Xx)
          , a = n[1].match(Xx);
        return Kx(t, o) ? [i, n[0]] : Kx(t, a) ? [i, n[1]] : [i, n[o != null && a != null ? 2 : 1]]
    }
    return [i, s]
}
function Vc(e, t, n) {
    n == null && (n = {});
    var i = "";
    switch (typeof e) {
    case "string":
        e == "m/d/yy" && n.dateNF ? i = n.dateNF : i = e;
        break;
    case "number":
        e == 14 && n.dateNF ? i = n.dateNF : i = (n.table != null ? n.table : Bn)[e],
        i == null && (i = n.table && n.table[jx[e]] || Bn[jx[e]]),
        i == null && (i = wL[e] || "General");
        break
    }
    if (J3(i, 0))
        return v7(t, n);
    t instanceof Date && (t = Mw(t, n.date1904));
    var r = VL(i, t);
    if (J3(r[1]))
        return v7(t, n);
    if (t === !0)
        t = "TRUE";
    else if (t === !1)
        t = "FALSE";
    else if (t === "" || t == null)
        return "";
    return GL(r[1], t, n, r[0])
}
function Uw(e, t) {
    if (typeof t != "number") {
        t = +t || -1;
        for (var n = 0; n < 392; ++n) {
            if (Bn[n] == null) {
                t < 0 && (t = n);
                continue
            }
            if (Bn[n] == e) {
                t = n;
                break
            }
        }
        t < 0 && (t = 391)
    }
    return Bn[t] = e,
    t
}
function h2(e) {
    for (var t = 0; t != 392; ++t)
        e[t] !== void 0 && Uw(e[t], t)
}
function d2() {
    Bn = xL()
}
var Hw = /[dD]+|[mM]+|[yYeE]+|[Hh]+|[Ss]+/g;
function WL(e) {
    var t = typeof e == "number" ? Bn[e] : e;
    return t = t.replace(Hw, "(\\d+)"),
    new RegExp("^" + t + "$")
}
function $L(e, t, n) {
    var i = -1
      , r = -1
      , s = -1
      , o = -1
      , a = -1
      , c = -1;
    (t.match(Hw) || []).forEach(function(h, d) {
        var f = parseInt(n[d + 1], 10);
        switch (h.toLowerCase().charAt(0)) {
        case "y":
            i = f;
            break;
        case "d":
            s = f;
            break;
        case "h":
            o = f;
            break;
        case "s":
            c = f;
            break;
        case "m":
            o >= 0 ? a = f : r = f;
            break
        }
    }),
    c >= 0 && a == -1 && r >= 0 && (a = r,
    r = -1);
    var l = ("" + (i >= 0 ? i : new Date().getFullYear())).slice(-4) + "-" + ("00" + (r >= 1 ? r : 1)).slice(-2) + "-" + ("00" + (s >= 1 ? s : 1)).slice(-2);
    l.length == 7 && (l = "0" + l),
    l.length == 8 && (l = "20" + l);
    var u = ("00" + (o >= 0 ? o : 0)).slice(-2) + ":" + ("00" + (a >= 0 ? a : 0)).slice(-2) + ":" + ("00" + (c >= 0 ? c : 0)).slice(-2);
    return o == -1 && a == -1 && c == -1 ? l : i == -1 && r == -1 && s == -1 ? u : l + "T" + u
}
var jL = function() {
    var e = {};
    e.version = "1.2.0";
    function t() {
        for (var E = 0, F = new Array(256), O = 0; O != 256; ++O)
            E = O,
            E = E & 1 ? -306674912 ^ E >>> 1 : E >>> 1,
            E = E & 1 ? -306674912 ^ E >>> 1 : E >>> 1,
            E = E & 1 ? -306674912 ^ E >>> 1 : E >>> 1,
            E = E & 1 ? -306674912 ^ E >>> 1 : E >>> 1,
            E = E & 1 ? -306674912 ^ E >>> 1 : E >>> 1,
            E = E & 1 ? -306674912 ^ E >>> 1 : E >>> 1,
            E = E & 1 ? -306674912 ^ E >>> 1 : E >>> 1,
            E = E & 1 ? -306674912 ^ E >>> 1 : E >>> 1,
            F[O] = E;
        return typeof Int32Array < "u" ? new Int32Array(F) : F
    }
    var n = t();
    function i(E) {
        var F = 0
          , O = 0
          , V = 0
          , X = typeof Int32Array < "u" ? new Int32Array(4096) : new Array(4096);
        for (V = 0; V != 256; ++V)
            X[V] = E[V];
        for (V = 0; V != 256; ++V)
            for (O = E[V],
            F = 256 + V; F < 4096; F += 256)
                O = X[F] = O >>> 8 ^ E[O & 255];
        var x = [];
        for (V = 1; V != 16; ++V)
            x[V - 1] = typeof Int32Array < "u" ? X.subarray(V * 256, V * 256 + 256) : X.slice(V * 256, V * 256 + 256);
        return x
    }
    var r = i(n)
      , s = r[0]
      , o = r[1]
      , a = r[2]
      , c = r[3]
      , l = r[4]
      , u = r[5]
      , h = r[6]
      , d = r[7]
      , f = r[8]
      , g = r[9]
      , p = r[10]
      , v = r[11]
      , b = r[12]
      , S = r[13]
      , w = r[14];
    function k(E, F) {
        for (var O = F ^ -1, V = 0, X = E.length; V < X; )
            O = O >>> 8 ^ n[(O ^ E.charCodeAt(V++)) & 255];
        return ~O
    }
    function B(E, F) {
        for (var O = F ^ -1, V = E.length - 15, X = 0; X < V; )
            O = w[E[X++] ^ O & 255] ^ S[E[X++] ^ O >> 8 & 255] ^ b[E[X++] ^ O >> 16 & 255] ^ v[E[X++] ^ O >>> 24] ^ p[E[X++]] ^ g[E[X++]] ^ f[E[X++]] ^ d[E[X++]] ^ h[E[X++]] ^ u[E[X++]] ^ l[E[X++]] ^ c[E[X++]] ^ a[E[X++]] ^ o[E[X++]] ^ s[E[X++]] ^ n[E[X++]];
        for (V += 15; X < V; )
            O = O >>> 8 ^ n[(O ^ E[X++]) & 255];
        return ~O
    }
    function N(E, F) {
        for (var O = F ^ -1, V = 0, X = E.length, x = 0, j = 0; V < X; )
            x = E.charCodeAt(V++),
            x < 128 ? O = O >>> 8 ^ n[(O ^ x) & 255] : x < 2048 ? (O = O >>> 8 ^ n[(O ^ (192 | x >> 6 & 31)) & 255],
            O = O >>> 8 ^ n[(O ^ (128 | x & 63)) & 255]) : x >= 55296 && x < 57344 ? (x = (x & 1023) + 64,
            j = E.charCodeAt(V++) & 1023,
            O = O >>> 8 ^ n[(O ^ (240 | x >> 8 & 7)) & 255],
            O = O >>> 8 ^ n[(O ^ (128 | x >> 2 & 63)) & 255],
            O = O >>> 8 ^ n[(O ^ (128 | j >> 6 & 15 | (x & 3) << 4)) & 255],
            O = O >>> 8 ^ n[(O ^ (128 | j & 63)) & 255]) : (O = O >>> 8 ^ n[(O ^ (224 | x >> 12 & 15)) & 255],
            O = O >>> 8 ^ n[(O ^ (128 | x >> 6 & 63)) & 255],
            O = O >>> 8 ^ n[(O ^ (128 | x & 63)) & 255]);
        return ~O
    }
    return e.table = n,
    e.bstr = k,
    e.buf = B,
    e.str = N,
    e
}(), nn = function() {
    var t = {};
    t.version = "1.2.1";
    function n(_, I) {
        for (var T = _.split("/"), P = I.split("/"), R = 0, D = 0, J = Math.min(T.length, P.length); R < J; ++R) {
            if (D = T[R].length - P[R].length)
                return D;
            if (T[R] != P[R])
                return T[R] < P[R] ? -1 : 1
        }
        return T.length - P.length
    }
    function i(_) {
        if (_.charAt(_.length - 1) == "/")
            return _.slice(0, -1).indexOf("/") === -1 ? _ : i(_.slice(0, -1));
        var I = _.lastIndexOf("/");
        return I === -1 ? _ : _.slice(0, I + 1)
    }
    function r(_) {
        if (_.charAt(_.length - 1) == "/")
            return r(_.slice(0, -1));
        var I = _.lastIndexOf("/");
        return I === -1 ? _ : _.slice(I + 1)
    }
    function s(_, I) {
        typeof I == "string" && (I = new Date(I));
        var T = I.getHours();
        T = T << 6 | I.getMinutes(),
        T = T << 5 | I.getSeconds() >>> 1,
        _.write_shift(2, T);
        var P = I.getFullYear() - 1980;
        P = P << 4 | I.getMonth() + 1,
        P = P << 5 | I.getDate(),
        _.write_shift(2, P)
    }
    function o(_) {
        var I = _.read_shift(2) & 65535
          , T = _.read_shift(2) & 65535
          , P = new Date
          , R = T & 31;
        T >>>= 5;
        var D = T & 15;
        T >>>= 4,
        P.setMilliseconds(0),
        P.setFullYear(T + 1980),
        P.setMonth(D - 1),
        P.setDate(R);
        var J = I & 31;
        I >>>= 5;
        var le = I & 63;
        return I >>>= 6,
        P.setHours(I),
        P.setMinutes(le),
        P.setSeconds(J << 1),
        P
    }
    function a(_) {
        bs(_, 0);
        for (var I = {}, T = 0; _.l <= _.length - 4; ) {
            var P = _.read_shift(2)
              , R = _.read_shift(2)
              , D = _.l + R
              , J = {};
            switch (P) {
            case 21589:
                T = _.read_shift(1),
                T & 1 && (J.mtime = _.read_shift(4)),
                R > 5 && (T & 2 && (J.atime = _.read_shift(4)),
                T & 4 && (J.ctime = _.read_shift(4))),
                J.mtime && (J.mt = new Date(J.mtime * 1e3));
                break
            }
            _.l = D,
            I[P] = J
        }
        return I
    }
    var c;
    function l() {
        return c || (c = {})
    }
    function u(_, I) {
        if (_[0] == 80 && _[1] == 75)
            return q8(_, I);
        if ((_[0] | 32) == 109 && (_[1] | 32) == 105)
            return NM(_, I);
        if (_.length < 512)
            throw new Error("CFB file size " + _.length + " < 512");
        var T = 3
          , P = 512
          , R = 0
          , D = 0
          , J = 0
          , le = 0
          , ee = 0
          , Z = []
          , ie = _.slice(0, 512);
        bs(ie, 0);
        var be = h(ie);
        switch (T = be[0],
        T) {
        case 3:
            P = 512;
            break;
        case 4:
            P = 4096;
            break;
        case 0:
            if (be[1] == 0)
                return q8(_, I);
        default:
            throw new Error("Major Version: Expected 3 or 4 saw " + T)
        }
        P !== 512 && (ie = _.slice(0, P),
        bs(ie, 28));
        var ke = _.slice(0, P);
        d(ie, T);
        var ze = ie.read_shift(4, "i");
        if (T === 3 && ze !== 0)
            throw new Error("# Directory Sectors: Expected 0 saw " + ze);
        ie.l += 4,
        J = ie.read_shift(4, "i"),
        ie.l += 4,
        ie.chk("00100000", "Mini Stream Cutoff Size: "),
        le = ie.read_shift(4, "i"),
        R = ie.read_shift(4, "i"),
        ee = ie.read_shift(4, "i"),
        D = ie.read_shift(4, "i");
        for (var Ae = -1, Le = 0; Le < 109 && (Ae = ie.read_shift(4, "i"),
        !(Ae < 0)); ++Le)
            Z[Le] = Ae;
        var gt = f(_, P);
        v(ee, D, gt, P, Z);
        var _n = S(gt, J, Z, P);
        _n[J].name = "!Directory",
        R > 0 && le !== j && (_n[le].name = "!MiniFAT"),
        _n[Z[0]].name = "!FAT",
        _n.fat_addrs = Z,
        _n.ssz = P;
        var Br = {}
          , Yn = []
          , rs = []
          , Ch = [];
        w(J, _n, gt, Yn, R, Br, rs, le),
        g(rs, Ch, Yn),
        Yn.shift();
        var Eh = {
            FileIndex: rs,
            FullPaths: Ch
        };
        return I && I.raw && (Eh.raw = {
            header: ke,
            sectors: gt
        }),
        Eh
    }
    function h(_) {
        if (_[_.l] == 80 && _[_.l + 1] == 75)
            return [0, 0];
        _.chk(fe, "Header Signature: "),
        _.l += 16;
        var I = _.read_shift(2, "u");
        return [_.read_shift(2, "u"), I]
    }
    function d(_, I) {
        var T = 9;
        switch (_.l += 2,
        T = _.read_shift(2)) {
        case 9:
            if (I != 3)
                throw new Error("Sector Shift: Expected 9 saw " + T);
            break;
        case 12:
            if (I != 4)
                throw new Error("Sector Shift: Expected 12 saw " + T);
            break;
        default:
            throw new Error("Sector Shift: Expected 9 or 12 saw " + T)
        }
        _.chk("0600", "Mini Sector Shift: "),
        _.chk("000000000000", "Reserved: ")
    }
    function f(_, I) {
        for (var T = Math.ceil(_.length / I) - 1, P = [], R = 1; R < T; ++R)
            P[R - 1] = _.slice(R * I, (R + 1) * I);
        return P[T - 1] = _.slice(T * I),
        P
    }
    function g(_, I, T) {
        for (var P = 0, R = 0, D = 0, J = 0, le = 0, ee = T.length, Z = [], ie = []; P < ee; ++P)
            Z[P] = ie[P] = P,
            I[P] = T[P];
        for (; le < ie.length; ++le)
            P = ie[le],
            R = _[P].L,
            D = _[P].R,
            J = _[P].C,
            Z[P] === P && (R !== -1 && Z[R] !== R && (Z[P] = Z[R]),
            D !== -1 && Z[D] !== D && (Z[P] = Z[D])),
            J !== -1 && (Z[J] = P),
            R !== -1 && P != Z[P] && (Z[R] = Z[P],
            ie.lastIndexOf(R) < le && ie.push(R)),
            D !== -1 && P != Z[P] && (Z[D] = Z[P],
            ie.lastIndexOf(D) < le && ie.push(D));
        for (P = 1; P < ee; ++P)
            Z[P] === P && (D !== -1 && Z[D] !== D ? Z[P] = Z[D] : R !== -1 && Z[R] !== R && (Z[P] = Z[R]));
        for (P = 1; P < ee; ++P)
            if (_[P].type !== 0) {
                if (le = P,
                le != Z[le])
                    do
                        le = Z[le],
                        I[P] = I[le] + "/" + I[P];
                    while (le !== 0 && Z[le] !== -1 && le != Z[le]);
                Z[P] = -1
            }
        for (I[0] += "/",
        P = 1; P < ee; ++P)
            _[P].type !== 2 && (I[P] += "/")
    }
    function p(_, I, T) {
        for (var P = _.start, R = _.size, D = [], J = P; T && R > 0 && J >= 0; )
            D.push(I.slice(J * x, J * x + x)),
            R -= x,
            J = Zl(T, J * 4);
        return D.length === 0 ? ce(0) : $i(D).slice(0, _.size)
    }
    function v(_, I, T, P, R) {
        var D = j;
        if (_ === j) {
            if (I !== 0)
                throw new Error("DIFAT chain shorter than expected")
        } else if (_ !== -1) {
            var J = T[_]
              , le = (P >>> 2) - 1;
            if (!J)
                return;
            for (var ee = 0; ee < le && (D = Zl(J, ee * 4)) !== j; ++ee)
                R.push(D);
            v(Zl(J, P - 4), I - 1, T, P, R)
        }
    }
    function b(_, I, T, P, R) {
        var D = []
          , J = [];
        R || (R = []);
        var le = P - 1
          , ee = 0
          , Z = 0;
        for (ee = I; ee >= 0; ) {
            R[ee] = !0,
            D[D.length] = ee,
            J.push(_[ee]);
            var ie = T[Math.floor(ee * 4 / P)];
            if (Z = ee * 4 & le,
            P < 4 + Z)
                throw new Error("FAT boundary crossed: " + ee + " 4 " + P);
            if (!_[ie])
                break;
            ee = Zl(_[ie], Z)
        }
        return {
            nodes: D,
            data: iw([J])
        }
    }
    function S(_, I, T, P) {
        var R = _.length
          , D = []
          , J = []
          , le = []
          , ee = []
          , Z = P - 1
          , ie = 0
          , be = 0
          , ke = 0
          , ze = 0;
        for (ie = 0; ie < R; ++ie)
            if (le = [],
            ke = ie + I,
            ke >= R && (ke -= R),
            !J[ke]) {
                ee = [];
                var Ae = [];
                for (be = ke; be >= 0; ) {
                    Ae[be] = !0,
                    J[be] = !0,
                    le[le.length] = be,
                    ee.push(_[be]);
                    var Le = T[Math.floor(be * 4 / P)];
                    if (ze = be * 4 & Z,
                    P < 4 + ze)
                        throw new Error("FAT boundary crossed: " + be + " 4 " + P);
                    if (!_[Le] || (be = Zl(_[Le], ze),
                    Ae[be]))
                        break
                }
                D[ke] = {
                    nodes: le,
                    data: iw([ee])
                }
            }
        return D
    }
    function w(_, I, T, P, R, D, J, le) {
        for (var ee = 0, Z = P.length ? 2 : 0, ie = I[_].data, be = 0, ke = 0, ze; be < ie.length; be += 128) {
            var Ae = ie.slice(be, be + 128);
            bs(Ae, 64),
            ke = Ae.read_shift(2),
            ze = g2(Ae, 0, ke - Z),
            P.push(ze);
            var Le = {
                name: ze,
                type: Ae.read_shift(1),
                color: Ae.read_shift(1),
                L: Ae.read_shift(4, "i"),
                R: Ae.read_shift(4, "i"),
                C: Ae.read_shift(4, "i"),
                clsid: Ae.read_shift(16),
                state: Ae.read_shift(4, "i"),
                start: 0,
                size: 0
            }
              , gt = Ae.read_shift(2) + Ae.read_shift(2) + Ae.read_shift(2) + Ae.read_shift(2);
            gt !== 0 && (Le.ct = k(Ae, Ae.l - 8));
            var _n = Ae.read_shift(2) + Ae.read_shift(2) + Ae.read_shift(2) + Ae.read_shift(2);
            _n !== 0 && (Le.mt = k(Ae, Ae.l - 8)),
            Le.start = Ae.read_shift(4, "i"),
            Le.size = Ae.read_shift(4, "i"),
            Le.size < 0 && Le.start < 0 && (Le.size = Le.type = 0,
            Le.start = j,
            Le.name = ""),
            Le.type === 5 ? (ee = Le.start,
            R > 0 && ee !== j && (I[ee].name = "!StreamData")) : Le.size >= 4096 ? (Le.storage = "fat",
            I[Le.start] === void 0 && (I[Le.start] = b(T, Le.start, I.fat_addrs, I.ssz)),
            I[Le.start].name = Le.name,
            Le.content = I[Le.start].data.slice(0, Le.size)) : (Le.storage = "minifat",
            Le.size < 0 ? Le.size = 0 : ee !== j && Le.start !== j && I[ee] && (Le.content = p(Le, I[ee].data, (I[le] || {}).data))),
            Le.content && bs(Le.content, 0),
            D[ze] = Le,
            J.push(Le)
        }
    }
    function k(_, I) {
        return new Date((ki(_, I + 4) / 1e7 * Math.pow(2, 32) + ki(_, I) / 1e7 - 11644473600) * 1e3)
    }
    function B(_, I) {
        return l(),
        u(c.readFileSync(_), I)
    }
    function N(_, I) {
        var T = I && I.type;
        switch (T || zt && Buffer.isBuffer(_) && (T = "buffer"),
        T || "base64") {
        case "file":
            return B(_, I);
        case "base64":
            return u(uo(Ba(_)), I);
        case "binary":
            return u(uo(_), I)
        }
        return u(_, I)
    }
    function E(_, I) {
        var T = I || {}
          , P = T.root || "Root Entry";
        if (_.FullPaths || (_.FullPaths = []),
        _.FileIndex || (_.FileIndex = []),
        _.FullPaths.length !== _.FileIndex.length)
            throw new Error("inconsistent CFB structure");
        _.FullPaths.length === 0 && (_.FullPaths[0] = P + "/",
        _.FileIndex[0] = {
            name: P,
            type: 5
        }),
        T.CLSID && (_.FileIndex[0].clsid = T.CLSID),
        F(_)
    }
    function F(_) {
        var I = "Sh33tJ5";
        if (!nn.find(_, "/" + I)) {
            var T = ce(4);
            T[0] = 55,
            T[1] = T[3] = 50,
            T[2] = 54,
            _.FileIndex.push({
                name: I,
                type: 2,
                content: T,
                size: 4,
                L: 69,
                R: 69,
                C: 69
            }),
            _.FullPaths.push(_.FullPaths[0] + I),
            O(_)
        }
    }
    function O(_, I) {
        E(_);
        for (var T = !1, P = !1, R = _.FullPaths.length - 1; R >= 0; --R) {
            var D = _.FileIndex[R];
            switch (D.type) {
            case 0:
                P ? T = !0 : (_.FileIndex.pop(),
                _.FullPaths.pop());
                break;
            case 1:
            case 2:
            case 5:
                P = !0,
                isNaN(D.R * D.L * D.C) && (T = !0),
                D.R > -1 && D.L > -1 && D.R == D.L && (T = !0);
                break;
            default:
                T = !0;
                break
            }
        }
        if (!(!T && !I)) {
            var J = new Date(1987,1,19)
              , le = 0
              , ee = Object.create ? Object.create(null) : {}
              , Z = [];
            for (R = 0; R < _.FullPaths.length; ++R)
                ee[_.FullPaths[R]] = !0,
                _.FileIndex[R].type !== 0 && Z.push([_.FullPaths[R], _.FileIndex[R]]);
            for (R = 0; R < Z.length; ++R) {
                var ie = i(Z[R][0]);
                P = ee[ie],
                P || (Z.push([ie, {
                    name: r(ie).replace("/", ""),
                    type: 1,
                    clsid: Re,
                    ct: J,
                    mt: J,
                    content: null
                }]),
                ee[ie] = !0)
            }
            for (Z.sort(function(ze, Ae) {
                return n(ze[0], Ae[0])
            }),
            _.FullPaths = [],
            _.FileIndex = [],
            R = 0; R < Z.length; ++R)
                _.FullPaths[R] = Z[R][0],
                _.FileIndex[R] = Z[R][1];
            for (R = 0; R < Z.length; ++R) {
                var be = _.FileIndex[R]
                  , ke = _.FullPaths[R];
                if (be.name = r(ke).replace("/", ""),
                be.L = be.R = be.C = -(be.color = 1),
                be.size = be.content ? be.content.length : 0,
                be.start = 0,
                be.clsid = be.clsid || Re,
                R === 0)
                    be.C = Z.length > 1 ? 1 : -1,
                    be.size = 0,
                    be.type = 5;
                else if (ke.slice(-1) == "/") {
                    for (le = R + 1; le < Z.length && i(_.FullPaths[le]) != ke; ++le)
                        ;
                    for (be.C = le >= Z.length ? -1 : le,
                    le = R + 1; le < Z.length && i(_.FullPaths[le]) != i(ke); ++le)
                        ;
                    be.R = le >= Z.length ? -1 : le,
                    be.type = 1
                } else
                    i(_.FullPaths[R + 1] || "") == i(ke) && (be.R = R + 1),
                    be.type = 2
            }
        }
    }
    function V(_, I) {
        var T = I || {};
        if (T.fileType == "mad")
            return FM(_, T);
        switch (O(_),
        T.fileType) {
        case "zip":
            return MM(_, T)
        }
        var P = function(ze) {
            for (var Ae = 0, Le = 0, gt = 0; gt < ze.FileIndex.length; ++gt) {
                var _n = ze.FileIndex[gt];
                if (_n.content) {
                    var Br = _n.content.length;
                    Br > 0 && (Br < 4096 ? Ae += Br + 63 >> 6 : Le += Br + 511 >> 9)
                }
            }
            for (var Yn = ze.FullPaths.length + 3 >> 2, rs = Ae + 7 >> 3, Ch = Ae + 127 >> 7, Eh = rs + Le + Yn + Ch, cl = Eh + 127 >> 7, Wp = cl <= 109 ? 0 : Math.ceil((cl - 109) / 127); Eh + cl + Wp + 127 >> 7 > cl; )
                Wp = ++cl <= 109 ? 0 : Math.ceil((cl - 109) / 127);
            var la = [1, Wp, cl, Ch, Yn, Le, Ae, 0];
            return ze.FileIndex[0].size = Ae << 6,
            la[7] = (ze.FileIndex[0].start = la[0] + la[1] + la[2] + la[3] + la[4] + la[5]) + (la[6] + 7 >> 3),
            la
        }(_)
          , R = ce(P[7] << 9)
          , D = 0
          , J = 0;
        {
            for (D = 0; D < 8; ++D)
                R.write_shift(1, he[D]);
            for (D = 0; D < 8; ++D)
                R.write_shift(2, 0);
            for (R.write_shift(2, 62),
            R.write_shift(2, 3),
            R.write_shift(2, 65534),
            R.write_shift(2, 9),
            R.write_shift(2, 6),
            D = 0; D < 3; ++D)
                R.write_shift(2, 0);
            for (R.write_shift(4, 0),
            R.write_shift(4, P[2]),
            R.write_shift(4, P[0] + P[1] + P[2] + P[3] - 1),
            R.write_shift(4, 0),
            R.write_shift(4, 4096),
            R.write_shift(4, P[3] ? P[0] + P[1] + P[2] - 1 : j),
            R.write_shift(4, P[3]),
            R.write_shift(-4, P[1] ? P[0] - 1 : j),
            R.write_shift(4, P[1]),
            D = 0; D < 109; ++D)
                R.write_shift(-4, D < P[2] ? P[1] + D : -1)
        }
        if (P[1])
            for (J = 0; J < P[1]; ++J) {
                for (; D < 236 + J * 127; ++D)
                    R.write_shift(-4, D < P[2] ? P[1] + D : -1);
                R.write_shift(-4, J === P[1] - 1 ? j : J + 1)
            }
        var le = function(ze) {
            for (J += ze; D < J - 1; ++D)
                R.write_shift(-4, D + 1);
            ze && (++D,
            R.write_shift(-4, j))
        };
        for (J = D = 0,
        J += P[1]; D < J; ++D)
            R.write_shift(-4, Xe.DIFSECT);
        for (J += P[2]; D < J; ++D)
            R.write_shift(-4, Xe.FATSECT);
        le(P[3]),
        le(P[4]);
        for (var ee = 0, Z = 0, ie = _.FileIndex[0]; ee < _.FileIndex.length; ++ee)
            ie = _.FileIndex[ee],
            ie.content && (Z = ie.content.length,
            !(Z < 4096) && (ie.start = J,
            le(Z + 511 >> 9)));
        for (le(P[6] + 7 >> 3); R.l & 511; )
            R.write_shift(-4, Xe.ENDOFCHAIN);
        for (J = D = 0,
        ee = 0; ee < _.FileIndex.length; ++ee)
            ie = _.FileIndex[ee],
            ie.content && (Z = ie.content.length,
            !(!Z || Z >= 4096) && (ie.start = J,
            le(Z + 63 >> 6)));
        for (; R.l & 511; )
            R.write_shift(-4, Xe.ENDOFCHAIN);
        for (D = 0; D < P[4] << 2; ++D) {
            var be = _.FullPaths[D];
            if (!be || be.length === 0) {
                for (ee = 0; ee < 17; ++ee)
                    R.write_shift(4, 0);
                for (ee = 0; ee < 3; ++ee)
                    R.write_shift(4, -1);
                for (ee = 0; ee < 12; ++ee)
                    R.write_shift(4, 0);
                continue
            }
            ie = _.FileIndex[D],
            D === 0 && (ie.start = ie.size ? ie.start - 1 : j);
            var ke = D === 0 && T.root || ie.name;
            if (Z = 2 * (ke.length + 1),
            R.write_shift(64, ke, "utf16le"),
            R.write_shift(2, Z),
            R.write_shift(1, ie.type),
            R.write_shift(1, ie.color),
            R.write_shift(-4, ie.L),
            R.write_shift(-4, ie.R),
            R.write_shift(-4, ie.C),
            ie.clsid)
                R.write_shift(16, ie.clsid, "hex");
            else
                for (ee = 0; ee < 4; ++ee)
                    R.write_shift(4, 0);
            R.write_shift(4, ie.state || 0),
            R.write_shift(4, 0),
            R.write_shift(4, 0),
            R.write_shift(4, 0),
            R.write_shift(4, 0),
            R.write_shift(4, ie.start),
            R.write_shift(4, ie.size),
            R.write_shift(4, 0)
        }
        for (D = 1; D < _.FileIndex.length; ++D)
            if (ie = _.FileIndex[D],
            ie.size >= 4096)
                if (R.l = ie.start + 1 << 9,
                zt && Buffer.isBuffer(ie.content))
                    ie.content.copy(R, R.l, 0, ie.size),
                    R.l += ie.size + 511 & -512;
                else {
                    for (ee = 0; ee < ie.size; ++ee)
                        R.write_shift(1, ie.content[ee]);
                    for (; ee & 511; ++ee)
                        R.write_shift(1, 0)
                }
        for (D = 1; D < _.FileIndex.length; ++D)
            if (ie = _.FileIndex[D],
            ie.size > 0 && ie.size < 4096)
                if (zt && Buffer.isBuffer(ie.content))
                    ie.content.copy(R, R.l, 0, ie.size),
                    R.l += ie.size + 63 & -64;
                else {
                    for (ee = 0; ee < ie.size; ++ee)
                        R.write_shift(1, ie.content[ee]);
                    for (; ee & 63; ++ee)
                        R.write_shift(1, 0)
                }
        if (zt)
            R.l = R.length;
        else
            for (; R.l < R.length; )
                R.write_shift(1, 0);
        return R
    }
    function X(_, I) {
        var T = _.FullPaths.map(function(ee) {
            return ee.toUpperCase()
        })
          , P = T.map(function(ee) {
            var Z = ee.split("/");
            return Z[Z.length - (ee.slice(-1) == "/" ? 2 : 1)]
        })
          , R = !1;
        I.charCodeAt(0) === 47 ? (R = !0,
        I = T[0].slice(0, -1) + I) : R = I.indexOf("/") !== -1;
        var D = I.toUpperCase()
          , J = R === !0 ? T.indexOf(D) : P.indexOf(D);
        if (J !== -1)
            return _.FileIndex[J];
        var le = !D.match(W3);
        for (D = D.replace(Vu, ""),
        le && (D = D.replace(W3, "!")),
        J = 0; J < T.length; ++J)
            if ((le ? T[J].replace(W3, "!") : T[J]).replace(Vu, "") == D || (le ? P[J].replace(W3, "!") : P[J]).replace(Vu, "") == D)
                return _.FileIndex[J];
        return null
    }
    var x = 64
      , j = -2
      , fe = "d0cf11e0a1b11ae1"
      , he = [208, 207, 17, 224, 161, 177, 26, 225]
      , Re = "00000000000000000000000000000000"
      , Xe = {
        MAXREGSECT: -6,
        DIFSECT: -4,
        FATSECT: -3,
        ENDOFCHAIN: j,
        FREESECT: -1,
        HEADER_SIGNATURE: fe,
        HEADER_MINOR_VERSION: "3e00",
        MAXREGSID: -6,
        NOSTREAM: -1,
        HEADER_CLSID: Re,
        EntryTypes: ["unknown", "storage", "stream", "lockbytes", "property", "root"]
    };
    function pt(_, I, T) {
        l();
        var P = V(_, T);
        c.writeFileSync(I, P)
    }
    function it(_) {
        for (var I = new Array(_.length), T = 0; T < _.length; ++T)
            I[T] = String.fromCharCode(_[T]);
        return I.join("")
    }
    function de(_, I) {
        var T = V(_, I);
        switch (I && I.type || "buffer") {
        case "file":
            return l(),
            c.writeFileSync(I.filename, T),
            T;
        case "binary":
            return typeof T == "string" ? T : it(T);
        case "base64":
            return x1(typeof T == "string" ? T : it(T));
        case "buffer":
            if (zt)
                return Buffer.isBuffer(T) ? T : Ha(T);
        case "array":
            return typeof T == "string" ? uo(T) : T
        }
        return T
    }
    var Ue;
    function A(_) {
        try {
            var I = _.InflateRaw
              , T = new I;
            if (T._processChunk(new Uint8Array([3, 0]), T._finishFlushFlag),
            T.bytesRead)
                Ue = _;
            else
                throw new Error("zlib does not expose bytesRead")
        } catch (P) {
            console.error("cannot use native zlib: " + (P.message || P))
        }
    }
    function q(_, I) {
        if (!Ue)
            return $8(_, I);
        var T = Ue.InflateRaw
          , P = new T
          , R = P._processChunk(_.slice(_.l), P._finishFlushFlag);
        return _.l += P.bytesRead,
        R
    }
    function L(_) {
        return Ue ? Ue.deflateRawSync(_) : ht(_)
    }
    var U = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
      , te = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258]
      , Ce = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
    function Ve(_) {
        var I = (_ << 1 | _ << 11) & 139536 | (_ << 5 | _ << 15) & 558144;
        return (I >> 16 | I >> 8 | I) & 255
    }
    for (var De = typeof Uint8Array < "u", ge = De ? new Uint8Array(256) : [], kt = 0; kt < 256; ++kt)
        ge[kt] = Ve(kt);
    function xt(_, I) {
        var T = ge[_ & 255];
        return I <= 8 ? T >>> 8 - I : (T = T << 8 | ge[_ >> 8 & 255],
        I <= 16 ? T >>> 16 - I : (T = T << 8 | ge[_ >> 16 & 255],
        T >>> 24 - I))
    }
    function fn(_, I) {
        var T = I & 7
          , P = I >>> 3;
        return (_[P] | (T <= 6 ? 0 : _[P + 1] << 8)) >>> T & 3
    }
    function Ot(_, I) {
        var T = I & 7
          , P = I >>> 3;
        return (_[P] | (T <= 5 ? 0 : _[P + 1] << 8)) >>> T & 7
    }
    function xi(_, I) {
        var T = I & 7
          , P = I >>> 3;
        return (_[P] | (T <= 4 ? 0 : _[P + 1] << 8)) >>> T & 15
    }
    function Xt(_, I) {
        var T = I & 7
          , P = I >>> 3;
        return (_[P] | (T <= 3 ? 0 : _[P + 1] << 8)) >>> T & 31
    }
    function He(_, I) {
        var T = I & 7
          , P = I >>> 3;
        return (_[P] | (T <= 1 ? 0 : _[P + 1] << 8)) >>> T & 127
    }
    function er(_, I, T) {
        var P = I & 7
          , R = I >>> 3
          , D = (1 << T) - 1
          , J = _[R] >>> P;
        return T < 8 - P || (J |= _[R + 1] << 8 - P,
        T < 16 - P) || (J |= _[R + 2] << 16 - P,
        T < 24 - P) || (J |= _[R + 3] << 24 - P),
        J & D
    }
    function ns(_, I, T) {
        var P = I & 7
          , R = I >>> 3;
        return P <= 5 ? _[R] |= (T & 7) << P : (_[R] |= T << P & 255,
        _[R + 1] = (T & 7) >> 8 - P),
        I + 3
    }
    function Bi(_, I, T) {
        var P = I & 7
          , R = I >>> 3;
        return T = (T & 1) << P,
        _[R] |= T,
        I + 1
    }
    function is(_, I, T) {
        var P = I & 7
          , R = I >>> 3;
        return T <<= P,
        _[R] |= T & 255,
        T >>>= 8,
        _[R + 1] = T,
        I + 8
    }
    function al(_, I, T) {
        var P = I & 7
          , R = I >>> 3;
        return T <<= P,
        _[R] |= T & 255,
        T >>>= 8,
        _[R + 1] = T & 255,
        _[R + 2] = T >>> 8,
        I + 16
    }
    function Kn(_, I) {
        var T = _.length
          , P = 2 * T > I ? 2 * T : I + 5
          , R = 0;
        if (T >= I)
            return _;
        if (zt) {
            var D = Vx(P);
            if (_.copy)
                _.copy(D);
            else
                for (; R < _.length; ++R)
                    D[R] = _[R];
            return D
        } else if (De) {
            var J = new Uint8Array(P);
            if (J.set)
                J.set(_);
            else
                for (; R < T; ++R)
                    J[R] = _[R];
            return J
        }
        return _.length = P,
        _
    }
    function pn(_) {
        for (var I = new Array(_), T = 0; T < _; ++T)
            I[T] = 0;
        return I
    }
    function ca(_, I, T) {
        var P = 1
          , R = 0
          , D = 0
          , J = 0
          , le = 0
          , ee = _.length
          , Z = De ? new Uint16Array(32) : pn(32);
        for (D = 0; D < 32; ++D)
            Z[D] = 0;
        for (D = ee; D < T; ++D)
            _[D] = 0;
        ee = _.length;
        var ie = De ? new Uint16Array(ee) : pn(ee);
        for (D = 0; D < ee; ++D)
            Z[R = _[D]]++,
            P < R && (P = R),
            ie[D] = 0;
        for (Z[0] = 0,
        D = 1; D <= P; ++D)
            Z[D + 16] = le = le + Z[D - 1] << 1;
        for (D = 0; D < ee; ++D)
            le = _[D],
            le != 0 && (ie[D] = Z[le + 16]++);
        var be = 0;
        for (D = 0; D < ee; ++D)
            if (be = _[D],
            be != 0)
                for (le = xt(ie[D], P) >> P - be,
                J = (1 << P + 4 - be) - 1; J >= 0; --J)
                    I[le | J << be] = be & 15 | D << 4;
        return P
    }
    var tc = De ? new Uint16Array(512) : pn(512)
      , ne = De ? new Uint16Array(32) : pn(32);
    if (!De) {
        for (var _e = 0; _e < 512; ++_e)
            tc[_e] = 0;
        for (_e = 0; _e < 32; ++_e)
            ne[_e] = 0
    }
    (function() {
        for (var _ = [], I = 0; I < 32; I++)
            _.push(5);
        ca(_, ne, 32);
        var T = [];
        for (I = 0; I <= 143; I++)
            T.push(8);
        for (; I <= 255; I++)
            T.push(9);
        for (; I <= 279; I++)
            T.push(7);
        for (; I <= 287; I++)
            T.push(8);
        ca(T, tc, 288)
    }
    )();
    var Oe = function() {
        for (var I = De ? new Uint8Array(32768) : [], T = 0, P = 0; T < Ce.length - 1; ++T)
            for (; P < Ce[T + 1]; ++P)
                I[P] = T;
        for (; P < 32768; ++P)
            I[P] = 29;
        var R = De ? new Uint8Array(259) : [];
        for (T = 0,
        P = 0; T < te.length - 1; ++T)
            for (; P < te[T + 1]; ++P)
                R[P] = T;
        function D(le, ee) {
            for (var Z = 0; Z < le.length; ) {
                var ie = Math.min(65535, le.length - Z)
                  , be = Z + ie == le.length;
                for (ee.write_shift(1, +be),
                ee.write_shift(2, ie),
                ee.write_shift(2, ~ie & 65535); ie-- > 0; )
                    ee[ee.l++] = le[Z++]
            }
            return ee.l
        }
        function J(le, ee) {
            for (var Z = 0, ie = 0, be = De ? new Uint16Array(32768) : []; ie < le.length; ) {
                var ke = Math.min(65535, le.length - ie);
                if (ke < 10) {
                    for (Z = ns(ee, Z, +(ie + ke == le.length)),
                    Z & 7 && (Z += 8 - (Z & 7)),
                    ee.l = Z / 8 | 0,
                    ee.write_shift(2, ke),
                    ee.write_shift(2, ~ke & 65535); ke-- > 0; )
                        ee[ee.l++] = le[ie++];
                    Z = ee.l * 8;
                    continue
                }
                Z = ns(ee, Z, +(ie + ke == le.length) + 2);
                for (var ze = 0; ke-- > 0; ) {
                    var Ae = le[ie];
                    ze = (ze << 5 ^ Ae) & 32767;
                    var Le = -1
                      , gt = 0;
                    if ((Le = be[ze]) && (Le |= ie & -32768,
                    Le > ie && (Le -= 32768),
                    Le < ie))
                        for (; le[Le + gt] == le[ie + gt] && gt < 250; )
                            ++gt;
                    if (gt > 2) {
                        Ae = R[gt],
                        Ae <= 22 ? Z = is(ee, Z, ge[Ae + 1] >> 1) - 1 : (is(ee, Z, 3),
                        Z += 5,
                        is(ee, Z, ge[Ae - 23] >> 5),
                        Z += 3);
                        var _n = Ae < 8 ? 0 : Ae - 4 >> 2;
                        _n > 0 && (al(ee, Z, gt - te[Ae]),
                        Z += _n),
                        Ae = I[ie - Le],
                        Z = is(ee, Z, ge[Ae] >> 3),
                        Z -= 3;
                        var Br = Ae < 4 ? 0 : Ae - 2 >> 1;
                        Br > 0 && (al(ee, Z, ie - Le - Ce[Ae]),
                        Z += Br);
                        for (var Yn = 0; Yn < gt; ++Yn)
                            be[ze] = ie & 32767,
                            ze = (ze << 5 ^ le[ie]) & 32767,
                            ++ie;
                        ke -= gt - 1
                    } else
                        Ae <= 143 ? Ae = Ae + 48 : Z = Bi(ee, Z, 1),
                        Z = is(ee, Z, ge[Ae]),
                        be[ze] = ie & 32767,
                        ++ie
                }
                Z = is(ee, Z, 0) - 1
            }
            return ee.l = (Z + 7) / 8 | 0,
            ee.l
        }
        return function(ee, Z) {
            return ee.length < 8 ? D(ee, Z) : J(ee, Z)
        }
    }();
    function ht(_) {
        var I = ce(50 + Math.floor(_.length * 1.1))
          , T = Oe(_, I);
        return I.slice(0, T)
    }
    var At = De ? new Uint16Array(32768) : pn(32768)
      , rn = De ? new Uint16Array(32768) : pn(32768)
      , An = De ? new Uint16Array(128) : pn(128)
      , yo = 1
      , wh = 1;
    function TM(_, I) {
        var T = Xt(_, I) + 257;
        I += 5;
        var P = Xt(_, I) + 1;
        I += 5;
        var R = xi(_, I) + 4;
        I += 4;
        for (var D = 0, J = De ? new Uint8Array(19) : pn(19), le = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], ee = 1, Z = De ? new Uint8Array(8) : pn(8), ie = De ? new Uint8Array(8) : pn(8), be = J.length, ke = 0; ke < R; ++ke)
            J[U[ke]] = D = Ot(_, I),
            ee < D && (ee = D),
            Z[D]++,
            I += 3;
        var ze = 0;
        for (Z[0] = 0,
        ke = 1; ke <= ee; ++ke)
            ie[ke] = ze = ze + Z[ke - 1] << 1;
        for (ke = 0; ke < be; ++ke)
            (ze = J[ke]) != 0 && (le[ke] = ie[ze]++);
        var Ae = 0;
        for (ke = 0; ke < be; ++ke)
            if (Ae = J[ke],
            Ae != 0) {
                ze = ge[le[ke]] >> 8 - Ae;
                for (var Le = (1 << 7 - Ae) - 1; Le >= 0; --Le)
                    An[ze | Le << Ae] = Ae & 7 | ke << 3
            }
        var gt = [];
        for (ee = 1; gt.length < T + P; )
            switch (ze = An[He(_, I)],
            I += ze & 7,
            ze >>>= 3) {
            case 16:
                for (D = 3 + fn(_, I),
                I += 2,
                ze = gt[gt.length - 1]; D-- > 0; )
                    gt.push(ze);
                break;
            case 17:
                for (D = 3 + Ot(_, I),
                I += 3; D-- > 0; )
                    gt.push(0);
                break;
            case 18:
                for (D = 11 + He(_, I),
                I += 7; D-- > 0; )
                    gt.push(0);
                break;
            default:
                gt.push(ze),
                ee < ze && (ee = ze);
                break
            }
        var _n = gt.slice(0, T)
          , Br = gt.slice(T);
        for (ke = T; ke < 286; ++ke)
            _n[ke] = 0;
        for (ke = P; ke < 30; ++ke)
            Br[ke] = 0;
        return yo = ca(_n, At, 286),
        wh = ca(Br, rn, 30),
        I
    }
    function OM(_, I) {
        if (_[0] == 3 && !(_[1] & 3))
            return [n0(I), 2];
        for (var T = 0, P = 0, R = Vx(I || 1 << 18), D = 0, J = R.length >>> 0, le = 0, ee = 0; !(P & 1); ) {
            if (P = Ot(_, T),
            T += 3,
            P >>> 1)
                P >> 1 == 1 ? (le = 9,
                ee = 5) : (T = TM(_, T),
                le = yo,
                ee = wh);
            else {
                T & 7 && (T += 8 - (T & 7));
                var Z = _[T >>> 3] | _[(T >>> 3) + 1] << 8;
                if (T += 32,
                Z > 0)
                    for (!I && J < D + Z && (R = Kn(R, D + Z),
                    J = R.length); Z-- > 0; )
                        R[D++] = _[T >>> 3],
                        T += 8;
                continue
            }
            for (; ; ) {
                !I && J < D + 32767 && (R = Kn(R, D + 32767),
                J = R.length);
                var ie = er(_, T, le)
                  , be = P >>> 1 == 1 ? tc[ie] : At[ie];
                if (T += be & 15,
                be >>>= 4,
                !(be >>> 8 & 255))
                    R[D++] = be;
                else {
                    if (be == 256)
                        break;
                    be -= 257;
                    var ke = be < 8 ? 0 : be - 4 >> 2;
                    ke > 5 && (ke = 0);
                    var ze = D + te[be];
                    ke > 0 && (ze += er(_, T, ke),
                    T += ke),
                    ie = er(_, T, ee),
                    be = P >>> 1 == 1 ? ne[ie] : rn[ie],
                    T += be & 15,
                    be >>>= 4;
                    var Ae = be < 4 ? 0 : be - 2 >> 1
                      , Le = Ce[be];
                    for (Ae > 0 && (Le += er(_, T, Ae),
                    T += Ae),
                    !I && J < ze && (R = Kn(R, ze + 100),
                    J = R.length); D < ze; )
                        R[D] = R[D - Le],
                        ++D
                }
            }
        }
        return I ? [R, T + 7 >>> 3] : [R.slice(0, D), T + 7 >>> 3]
    }
    function $8(_, I) {
        var T = _.slice(_.l || 0)
          , P = OM(T, I);
        return _.l += P[1],
        P[0]
    }
    function j8(_, I) {
        if (_)
            typeof console < "u" && console.error(I);
        else
            throw new Error(I)
    }
    function q8(_, I) {
        var T = _;
        bs(T, 0);
        var P = []
          , R = []
          , D = {
            FileIndex: P,
            FullPaths: R
        };
        E(D, {
            root: I.root
        });
        for (var J = T.length - 4; (T[J] != 80 || T[J + 1] != 75 || T[J + 2] != 5 || T[J + 3] != 6) && J >= 0; )
            --J;
        T.l = J + 4,
        T.l += 4;
        var le = T.read_shift(2);
        T.l += 6;
        var ee = T.read_shift(4);
        for (T.l = ee,
        J = 0; J < le; ++J) {
            T.l += 20;
            var Z = T.read_shift(4)
              , ie = T.read_shift(4)
              , be = T.read_shift(2)
              , ke = T.read_shift(2)
              , ze = T.read_shift(2);
            T.l += 8;
            var Ae = T.read_shift(4)
              , Le = a(T.slice(T.l + be, T.l + be + ke));
            T.l += be + ke + ze;
            var gt = T.l;
            T.l = Ae + 4,
            PM(T, Z, ie, D, Le),
            T.l = gt
        }
        return D
    }
    function PM(_, I, T, P, R) {
        _.l += 2;
        var D = _.read_shift(2)
          , J = _.read_shift(2)
          , le = o(_);
        if (D & 8257)
            throw new Error("Unsupported ZIP encryption");
        for (var ee = _.read_shift(4), Z = _.read_shift(4), ie = _.read_shift(4), be = _.read_shift(2), ke = _.read_shift(2), ze = "", Ae = 0; Ae < be; ++Ae)
            ze += String.fromCharCode(_[_.l++]);
        if (ke) {
            var Le = a(_.slice(_.l, _.l + ke));
            (Le[21589] || {}).mt && (le = Le[21589].mt),
            ((R || {})[21589] || {}).mt && (le = R[21589].mt)
        }
        _.l += ke;
        var gt = _.slice(_.l, _.l + Z);
        switch (J) {
        case 8:
            gt = q(_, ie);
            break;
        case 0:
            break;
        default:
            throw new Error("Unsupported ZIP Compression method " + J)
        }
        var _n = !1;
        D & 8 && (ee = _.read_shift(4),
        ee == 134695760 && (ee = _.read_shift(4),
        _n = !0),
        Z = _.read_shift(4),
        ie = _.read_shift(4)),
        Z != I && j8(_n, "Bad compressed size: " + I + " != " + Z),
        ie != T && j8(_n, "Bad uncompressed size: " + T + " != " + ie),
        Vp(P, ze, gt, {
            unsafe: !0,
            mt: le
        })
    }
    function MM(_, I) {
        var T = I || {}
          , P = []
          , R = []
          , D = ce(1)
          , J = T.compression ? 8 : 0
          , le = 0
          , ee = !1;
        ee && (le |= 8);
        var Z = 0
          , ie = 0
          , be = 0
          , ke = 0
          , ze = _.FullPaths[0]
          , Ae = ze
          , Le = _.FileIndex[0]
          , gt = []
          , _n = 0;
        for (Z = 1; Z < _.FullPaths.length; ++Z)
            if (Ae = _.FullPaths[Z].slice(ze.length),
            Le = _.FileIndex[Z],
            !(!Le.size || !Le.content || Ae == "Sh33tJ5")) {
                var Br = be
                  , Yn = ce(Ae.length);
                for (ie = 0; ie < Ae.length; ++ie)
                    Yn.write_shift(1, Ae.charCodeAt(ie) & 127);
                Yn = Yn.slice(0, Yn.l),
                gt[ke] = jL.buf(Le.content, 0);
                var rs = Le.content;
                J == 8 && (rs = L(rs)),
                D = ce(30),
                D.write_shift(4, 67324752),
                D.write_shift(2, 20),
                D.write_shift(2, le),
                D.write_shift(2, J),
                Le.mt ? s(D, Le.mt) : D.write_shift(4, 0),
                D.write_shift(-4, le & 8 ? 0 : gt[ke]),
                D.write_shift(4, le & 8 ? 0 : rs.length),
                D.write_shift(4, le & 8 ? 0 : Le.content.length),
                D.write_shift(2, Yn.length),
                D.write_shift(2, 0),
                be += D.length,
                P.push(D),
                be += Yn.length,
                P.push(Yn),
                be += rs.length,
                P.push(rs),
                le & 8 && (D = ce(12),
                D.write_shift(-4, gt[ke]),
                D.write_shift(4, rs.length),
                D.write_shift(4, Le.content.length),
                be += D.l,
                P.push(D)),
                D = ce(46),
                D.write_shift(4, 33639248),
                D.write_shift(2, 0),
                D.write_shift(2, 20),
                D.write_shift(2, le),
                D.write_shift(2, J),
                D.write_shift(4, 0),
                D.write_shift(-4, gt[ke]),
                D.write_shift(4, rs.length),
                D.write_shift(4, Le.content.length),
                D.write_shift(2, Yn.length),
                D.write_shift(2, 0),
                D.write_shift(2, 0),
                D.write_shift(2, 0),
                D.write_shift(2, 0),
                D.write_shift(4, 0),
                D.write_shift(4, Br),
                _n += D.l,
                R.push(D),
                _n += Yn.length,
                R.push(Yn),
                ++ke
            }
        return D = ce(22),
        D.write_shift(4, 101010256),
        D.write_shift(2, 0),
        D.write_shift(2, 0),
        D.write_shift(2, ke),
        D.write_shift(2, ke),
        D.write_shift(4, _n),
        D.write_shift(4, be),
        D.write_shift(2, 0),
        $i([$i(P), $i(R), D])
    }
    var f5 = {
        htm: "text/html",
        xml: "text/xml",
        gif: "image/gif",
        jpg: "image/jpeg",
        png: "image/png",
        mso: "application/x-mso",
        thmx: "application/vnd.ms-officetheme",
        sh33tj5: "application/octet-stream"
    };
    function kM(_, I) {
        if (_.ctype)
            return _.ctype;
        var T = _.name || ""
          , P = T.match(/\.([^\.]+)$/);
        return P && f5[P[1]] || I && (P = (T = I).match(/[\.\\]([^\.\\])+$/),
        P && f5[P[1]]) ? f5[P[1]] : "application/octet-stream"
    }
    function AM(_) {
        for (var I = x1(_), T = [], P = 0; P < I.length; P += 76)
            T.push(I.slice(P, P + 76));
        return T.join(`\r
`) + `\r
`
    }
    function IM(_) {
        var I = _.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF=]/g, function(Z) {
            var ie = Z.charCodeAt(0).toString(16).toUpperCase();
            return "=" + (ie.length == 1 ? "0" + ie : ie)
        });
        I = I.replace(/ $/mg, "=20").replace(/\t$/mg, "=09"),
        I.charAt(0) == `
` && (I = "=0D" + I.slice(1)),
        I = I.replace(/\r(?!\n)/mg, "=0D").replace(/\n\n/mg, `
=0A`).replace(/([^\r\n])\n/mg, "$1=0A");
        for (var T = [], P = I.split(`\r
`), R = 0; R < P.length; ++R) {
            var D = P[R];
            if (D.length == 0) {
                T.push("");
                continue
            }
            for (var J = 0; J < D.length; ) {
                var le = 76
                  , ee = D.slice(J, J + le);
                ee.charAt(le - 1) == "=" ? le-- : ee.charAt(le - 2) == "=" ? le -= 2 : ee.charAt(le - 3) == "=" && (le -= 3),
                ee = D.slice(J, J + le),
                J += le,
                J < D.length && (ee += "="),
                T.push(ee)
            }
        }
        return T.join(`\r
`)
    }
    function RM(_) {
        for (var I = [], T = 0; T < _.length; ++T) {
            for (var P = _[T]; T <= _.length && P.charAt(P.length - 1) == "="; )
                P = P.slice(0, P.length - 1) + _[++T];
            I.push(P)
        }
        for (var R = 0; R < I.length; ++R)
            I[R] = I[R].replace(/[=][0-9A-Fa-f]{2}/g, function(D) {
                return String.fromCharCode(parseInt(D.slice(1), 16))
            });
        return uo(I.join(`\r
`))
    }
    function DM(_, I, T) {
        for (var P = "", R = "", D = "", J, le = 0; le < 10; ++le) {
            var ee = I[le];
            if (!ee || ee.match(/^\s*$/))
                break;
            var Z = ee.match(/^(.*?):\s*([^\s].*)$/);
            if (Z)
                switch (Z[1].toLowerCase()) {
                case "content-location":
                    P = Z[2].trim();
                    break;
                case "content-type":
                    D = Z[2].trim();
                    break;
                case "content-transfer-encoding":
                    R = Z[2].trim();
                    break
                }
        }
        switch (++le,
        R.toLowerCase()) {
        case "base64":
            J = uo(Ba(I.slice(le).join("")));
            break;
        case "quoted-printable":
            J = RM(I.slice(le));
            break;
        default:
            throw new Error("Unsupported Content-Transfer-Encoding " + R)
        }
        var ie = Vp(_, P.slice(T.length), J, {
            unsafe: !0
        });
        D && (ie.ctype = D)
    }
    function NM(_, I) {
        if (it(_.slice(0, 13)).toLowerCase() != "mime-version:")
            throw new Error("Unsupported MAD header");
        var T = I && I.root || ""
          , P = (zt && Buffer.isBuffer(_) ? _.toString("binary") : it(_)).split(`\r
`)
          , R = 0
          , D = "";
        for (R = 0; R < P.length; ++R)
            if (D = P[R],
            !!/^Content-Location:/i.test(D) && (D = D.slice(D.indexOf("file")),
            T || (T = D.slice(0, D.lastIndexOf("/") + 1)),
            D.slice(0, T.length) != T))
                for (; T.length > 0 && (T = T.slice(0, T.length - 1),
                T = T.slice(0, T.lastIndexOf("/") + 1),
                D.slice(0, T.length) != T); )
                    ;
        var J = (P[1] || "").match(/boundary="(.*?)"/);
        if (!J)
            throw new Error("MAD cannot find boundary");
        var le = "--" + (J[1] || "")
          , ee = []
          , Z = []
          , ie = {
            FileIndex: ee,
            FullPaths: Z
        };
        E(ie);
        var be, ke = 0;
        for (R = 0; R < P.length; ++R) {
            var ze = P[R];
            ze !== le && ze !== le + "--" || (ke++ && DM(ie, P.slice(be, R), T),
            be = R)
        }
        return ie
    }
    function FM(_, I) {
        var T = I || {}
          , P = T.boundary || "SheetJS";
        P = "------=" + P;
        for (var R = ["MIME-Version: 1.0", 'Content-Type: multipart/related; boundary="' + P.slice(2) + '"', "", "", ""], D = _.FullPaths[0], J = D, le = _.FileIndex[0], ee = 1; ee < _.FullPaths.length; ++ee)
            if (J = _.FullPaths[ee].slice(D.length),
            le = _.FileIndex[ee],
            !(!le.size || !le.content || J == "Sh33tJ5")) {
                J = J.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF]/g, function(gt) {
                    return "_x" + gt.charCodeAt(0).toString(16) + "_"
                }).replace(/[\u0080-\uFFFF]/g, function(gt) {
                    return "_u" + gt.charCodeAt(0).toString(16) + "_"
                });
                for (var Z = le.content, ie = zt && Buffer.isBuffer(Z) ? Z.toString("binary") : it(Z), be = 0, ke = Math.min(1024, ie.length), ze = 0, Ae = 0; Ae <= ke; ++Ae)
                    (ze = ie.charCodeAt(Ae)) >= 32 && ze < 128 && ++be;
                var Le = be >= ke * 4 / 5;
                R.push(P),
                R.push("Content-Location: " + (T.root || "file:///C:/SheetJS/") + J),
                R.push("Content-Transfer-Encoding: " + (Le ? "quoted-printable" : "base64")),
                R.push("Content-Type: " + kM(le, J)),
                R.push(""),
                R.push(Le ? IM(ie) : AM(ie))
            }
        return R.push(P + `--\r
`),
        R.join(`\r
`)
    }
    function LM(_) {
        var I = {};
        return E(I, _),
        I
    }
    function Vp(_, I, T, P) {
        var R = P && P.unsafe;
        R || E(_);
        var D = !R && nn.find(_, I);
        if (!D) {
            var J = _.FullPaths[0];
            I.slice(0, J.length) == J ? J = I : (J.slice(-1) != "/" && (J += "/"),
            J = (J + I).replace("//", "/")),
            D = {
                name: r(I),
                type: 2
            },
            _.FileIndex.push(D),
            _.FullPaths.push(J),
            R || nn.utils.cfb_gc(_)
        }
        return D.content = T,
        D.size = T ? T.length : 0,
        P && (P.CLSID && (D.clsid = P.CLSID),
        P.mt && (D.mt = P.mt),
        P.ct && (D.ct = P.ct)),
        D
    }
    function BM(_, I) {
        E(_);
        var T = nn.find(_, I);
        if (T) {
            for (var P = 0; P < _.FileIndex.length; ++P)
                if (_.FileIndex[P] == T)
                    return _.FileIndex.splice(P, 1),
                    _.FullPaths.splice(P, 1),
                    !0
        }
        return !1
    }
    function UM(_, I, T) {
        E(_);
        var P = nn.find(_, I);
        if (P) {
            for (var R = 0; R < _.FileIndex.length; ++R)
                if (_.FileIndex[R] == P)
                    return _.FileIndex[R].name = r(T),
                    _.FullPaths[R] = T,
                    !0
        }
        return !1
    }
    function HM(_) {
        O(_, !0)
    }
    return t.find = X,
    t.read = N,
    t.parse = u,
    t.write = de,
    t.writeFile = pt,
    t.utils = {
        cfb_new: LM,
        cfb_add: Vp,
        cfb_del: BM,
        cfb_mov: UM,
        cfb_gc: HM,
        ReadShift: m1,
        CheckField: Zw,
        prep_blob: bs,
        bconcat: $i,
        use_zlib: A,
        _deflateRaw: ht,
        _inflateRaw: $8,
        consts: Xe
    },
    t
}(), j3;
function qL(e) {
    return typeof e == "string" ? u2(e) : Array.isArray(e) ? _L(e) : e
}
function P1(e, t, n) {
    if (typeof j3 < "u" && j3.writeFileSync)
        return n ? j3.writeFileSync(e, t, n) : j3.writeFileSync(e, t);
    if (typeof Deno < "u") {
        if (n && typeof t == "string")
            switch (n) {
            case "utf8":
                t = new TextEncoder(n).encode(t);
                break;
            case "binary":
                t = u2(t);
                break;
            default:
                throw new Error("Unsupported encoding " + n)
            }
        return Deno.writeFileSync(e, t)
    }
    var i = n == "utf8" ? Da(t) : t;
    if (typeof IE_SaveFile < "u")
        return IE_SaveFile(i, e);
    if (typeof Blob < "u") {
        var r = new Blob([qL(i)],{
            type: "application/octet-stream"
        });
        if (typeof navigator < "u" && navigator.msSaveBlob)
            return navigator.msSaveBlob(r, e);
        if (typeof saveAs < "u")
            return saveAs(r, e);
        if (typeof URL < "u" && typeof document < "u" && document.createElement && URL.createObjectURL) {
            var s = URL.createObjectURL(r);
            if (typeof chrome == "object" && typeof (chrome.downloads || {}).download == "function")
                return URL.revokeObjectURL && typeof setTimeout < "u" && setTimeout(function() {
                    URL.revokeObjectURL(s)
                }, 6e4),
                chrome.downloads.download({
                    url: s,
                    filename: e,
                    saveAs: !0
                });
            var o = document.createElement("a");
            if (o.download != null)
                return o.download = e,
                o.href = s,
                document.body.appendChild(o),
                o.click(),
                document.body.removeChild(o),
                URL.revokeObjectURL && typeof setTimeout < "u" && setTimeout(function() {
                    URL.revokeObjectURL(s)
                }, 6e4),
                s
        }
    }
    if (typeof $ < "u" && typeof File < "u" && typeof Folder < "u")
        try {
            var a = File(e);
            return a.open("w"),
            a.encoding = "binary",
            Array.isArray(t) && (t = O1(t)),
            a.write(t),
            a.close(),
            t
        } catch (c) {
            if (!c.message || !c.message.match(/onstruct/))
                throw c
        }
    throw new Error("cannot save file " + e)
}
function zi(e) {
    for (var t = Object.keys(e), n = [], i = 0; i < t.length; ++i)
        Object.prototype.hasOwnProperty.call(e, t[i]) && n.push(t[i]);
    return n
}
function Yx(e, t) {
    for (var n = [], i = zi(e), r = 0; r !== i.length; ++r)
        n[e[i[r]][t]] == null && (n[e[i[r]][t]] = i[r]);
    return n
}
function w7(e) {
    for (var t = [], n = zi(e), i = 0; i !== n.length; ++i)
        t[e[n[i]]] = n[i];
    return t
}
function f2(e) {
    for (var t = [], n = zi(e), i = 0; i !== n.length; ++i)
        t[e[n[i]]] = parseInt(n[i], 10);
    return t
}
function zL(e) {
    for (var t = [], n = zi(e), i = 0; i !== n.length; ++i)
        t[e[n[i]]] == null && (t[e[n[i]]] = []),
        t[e[n[i]]].push(n[i]);
    return t
}
var e2 = new Date(1899,11,30,0,0,0);
function Qr(e, t) {
    var n = e.getTime();
    t && (n -= 1462 * 24 * 60 * 60 * 1e3);
    var i = e2.getTime() + (e.getTimezoneOffset() - e2.getTimezoneOffset()) * 6e4;
    return (n - i) / (24 * 60 * 60 * 1e3)
}
var Gw = new Date
  , XL = e2.getTime() + (Gw.getTimezoneOffset() - e2.getTimezoneOffset()) * 6e4
  , Qx = Gw.getTimezoneOffset();
function Vw(e) {
    var t = new Date;
    return t.setTime(e * 24 * 60 * 60 * 1e3 + XL),
    t.getTimezoneOffset() !== Qx && t.setTime(t.getTime() + (t.getTimezoneOffset() - Qx) * 6e4),
    t
}
var Jx = new Date("2017-02-19T19:06:09.000Z")
  , Ww = isNaN(Jx.getFullYear()) ? new Date("2/19/17") : Jx
  , KL = Ww.getFullYear() == 2017;
function kr(e, t) {
    var n = new Date(e);
    if (KL)
        return t > 0 ? n.setTime(n.getTime() + n.getTimezoneOffset() * 60 * 1e3) : t < 0 && n.setTime(n.getTime() - n.getTimezoneOffset() * 60 * 1e3),
        n;
    if (e instanceof Date)
        return e;
    if (Ww.getFullYear() == 1917 && !isNaN(n.getFullYear())) {
        var i = n.getFullYear();
        return e.indexOf("" + i) > -1 || n.setFullYear(n.getFullYear() + 100),
        n
    }
    var r = e.match(/\d+/g) || ["2017", "2", "19", "0", "0", "0"]
      , s = new Date(+r[0],+r[1] - 1,+r[2],+r[3] || 0,+r[4] || 0,+r[5] || 0);
    return e.indexOf("Z") > -1 && (s = new Date(s.getTime() - s.getTimezoneOffset() * 60 * 1e3)),
    s
}
function p2(e, t) {
    if (zt && Buffer.isBuffer(e)) {
        if (t) {
            if (e[0] == 255 && e[1] == 254)
                return Da(e.slice(2).toString("utf16le"));
            if (e[1] == 254 && e[2] == 255)
                return Da(vL(e.slice(2).toString("binary")))
        }
        return e.toString("binary")
    }
    if (typeof TextDecoder < "u")
        try {
            if (t) {
                if (e[0] == 255 && e[1] == 254)
                    return Da(new TextDecoder("utf-16le").decode(e.slice(2)));
                if (e[0] == 254 && e[1] == 255)
                    return Da(new TextDecoder("utf-16be").decode(e.slice(2)))
            }
            var n = {
                "\u20AC": "\x80",
                "\u201A": "\x82",
                \u0192: "\x83",
                "\u201E": "\x84",
                "\u2026": "\x85",
                "\u2020": "\x86",
                "\u2021": "\x87",
                "\u02C6": "\x88",
                "\u2030": "\x89",
                \u0160: "\x8A",
                "\u2039": "\x8B",
                \u0152: "\x8C",
                \u017D: "\x8E",
                "\u2018": "\x91",
                "\u2019": "\x92",
                "\u201C": "\x93",
                "\u201D": "\x94",
                "\u2022": "\x95",
                "\u2013": "\x96",
                "\u2014": "\x97",
                "\u02DC": "\x98",
                "\u2122": "\x99",
                \u0161: "\x9A",
                "\u203A": "\x9B",
                \u0153: "\x9C",
                \u017E: "\x9E",
                \u0178: "\x9F"
            };
            return Array.isArray(e) && (e = new Uint8Array(e)),
            new TextDecoder("latin1").decode(e).replace(/[]/g, function(s) {
                return n[s] || s
            })
        } catch {}
    for (var i = [], r = 0; r != e.length; ++r)
        i.push(String.fromCharCode(e[r]));
    return i.join("")
}
function Jr(e) {
    if (typeof JSON < "u" && !Array.isArray(e))
        return JSON.parse(JSON.stringify(e));
    if (typeof e != "object" || e == null)
        return e;
    if (e instanceof Date)
        return new Date(e.getTime());
    var t = {};
    for (var n in e)
        Object.prototype.hasOwnProperty.call(e, n) && (t[n] = Jr(e[n]));
    return t
}
function Ln(e, t) {
    for (var n = ""; n.length < t; )
        n += e;
    return n
}
function Fa(e) {
    var t = Number(e);
    if (!isNaN(t))
        return isFinite(t) ? t : NaN;
    if (!/\d/.test(e))
        return t;
    var n = 1
      , i = e.replace(/([\d]),([\d])/g, "$1$2").replace(/[$]/g, "").replace(/[%]/g, function() {
        return n *= 100,
        ""
    });
    return !isNaN(t = Number(i)) || (i = i.replace(/[(](.*)[)]/, function(r, s) {
        return n = -n,
        s
    }),
    !isNaN(t = Number(i))) ? t / n : t
}
var YL = ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"];
function w1(e) {
    var t = new Date(e)
      , n = new Date(NaN)
      , i = t.getYear()
      , r = t.getMonth()
      , s = t.getDate();
    if (isNaN(s))
        return n;
    var o = e.toLowerCase();
    if (o.match(/jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/)) {
        if (o = o.replace(/[^a-z]/g, "").replace(/([^a-z]|^)[ap]m?([^a-z]|$)/, ""),
        o.length > 3 && YL.indexOf(o) == -1)
            return n
    } else if (o.match(/[a-z]/))
        return n;
    return i < 0 || i > 8099 ? n : (r > 0 || s > 1) && i != 101 ? t : e.match(/[^-0-9:,\/\\]/) ? n : t
}
function Tt(e, t, n) {
    if (e.FullPaths) {
        if (typeof n == "string") {
            var i;
            return zt ? i = Ha(n) : i = yL(n),
            nn.utils.cfb_add(e, t, i)
        }
        nn.utils.cfb_add(e, t, n)
    } else
        e.file(t, n)
}
function C7() {
    return nn.utils.cfb_new()
}
var oi = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\r
`;
var QL = {
    "&quot;": '"',
    "&apos;": "'",
    "&gt;": ">",
    "&lt;": "<",
    "&amp;": "&"
}
  , E7 = w7(QL);
var T7 = /[&<>'"]/g
  , JL = /[\u0000-\u0008\u000b-\u001f]/g;
function en(e) {
    var t = e + "";
    return t.replace(T7, function(n) {
        return E7[n]
    }).replace(JL, function(n) {
        return "_x" + ("000" + n.charCodeAt(0).toString(16)).slice(-4) + "_"
    })
}
function Zx(e) {
    return en(e).replace(/ /g, "_x0020_")
}
var $w = /[\u0000-\u001f]/g;
function ZL(e) {
    var t = e + "";
    return t.replace(T7, function(n) {
        return E7[n]
    }).replace(/\n/g, "<br/>").replace($w, function(n) {
        return "&#x" + ("000" + n.charCodeAt(0).toString(16)).slice(-4) + ";"
    })
}
function eB(e) {
    var t = e + "";
    return t.replace(T7, function(n) {
        return E7[n]
    }).replace($w, function(n) {
        return "&#x" + n.charCodeAt(0).toString(16).toUpperCase() + ";"
    })
}
function tB(e) {
    return e.replace(/(\r\n|[\r\n])/g, "&#10;")
}
function nB(e) {
    switch (e) {
    case 1:
    case !0:
    case "1":
    case "true":
    case "TRUE":
        return !0;
    default:
        return !1
    }
}
function u7(e) {
    for (var t = "", n = 0, i = 0, r = 0, s = 0, o = 0, a = 0; n < e.length; ) {
        if (i = e.charCodeAt(n++),
        i < 128) {
            t += String.fromCharCode(i);
            continue
        }
        if (r = e.charCodeAt(n++),
        i > 191 && i < 224) {
            o = (i & 31) << 6,
            o |= r & 63,
            t += String.fromCharCode(o);
            continue
        }
        if (s = e.charCodeAt(n++),
        i < 240) {
            t += String.fromCharCode((i & 15) << 12 | (r & 63) << 6 | s & 63);
            continue
        }
        o = e.charCodeAt(n++),
        a = ((i & 7) << 18 | (r & 63) << 12 | (s & 63) << 6 | o & 63) - 65536,
        t += String.fromCharCode(55296 + (a >>> 10 & 1023)),
        t += String.fromCharCode(56320 + (a & 1023))
    }
    return t
}
function ew(e) {
    var t = n0(2 * e.length), n, i, r = 1, s = 0, o = 0, a;
    for (i = 0; i < e.length; i += r)
        r = 1,
        (a = e.charCodeAt(i)) < 128 ? n = a : a < 224 ? (n = (a & 31) * 64 + (e.charCodeAt(i + 1) & 63),
        r = 2) : a < 240 ? (n = (a & 15) * 4096 + (e.charCodeAt(i + 1) & 63) * 64 + (e.charCodeAt(i + 2) & 63),
        r = 3) : (r = 4,
        n = (a & 7) * 262144 + (e.charCodeAt(i + 1) & 63) * 4096 + (e.charCodeAt(i + 2) & 63) * 64 + (e.charCodeAt(i + 3) & 63),
        n -= 65536,
        o = 55296 + (n >>> 10 & 1023),
        n = 56320 + (n & 1023)),
        o !== 0 && (t[s++] = o & 255,
        t[s++] = o >>> 8,
        o = 0),
        t[s++] = n % 256,
        t[s++] = n >>> 8;
    return t.slice(0, s).toString("ucs2")
}
function tw(e) {
    return Ha(e, "binary").toString("utf8")
}
var q3 = "foo bar baz\xE2\x98\x83\xF0\x9F\x8D\xA3"
  , g1 = zt && (tw(q3) == u7(q3) && tw || ew(q3) == u7(q3) && ew) || u7
  , Da = zt ? function(e) {
    return Ha(e, "utf8").toString("binary")
}
: function(e) {
    for (var t = [], n = 0, i = 0, r = 0; n < e.length; )
        switch (i = e.charCodeAt(n++),
        !0) {
        case i < 128:
            t.push(String.fromCharCode(i));
            break;
        case i < 2048:
            t.push(String.fromCharCode(192 + (i >> 6))),
            t.push(String.fromCharCode(128 + (i & 63)));
            break;
        case (i >= 55296 && i < 57344):
            i -= 55296,
            r = e.charCodeAt(n++) - 56320 + (i << 10),
            t.push(String.fromCharCode(240 + (r >> 18 & 7))),
            t.push(String.fromCharCode(144 + (r >> 12 & 63))),
            t.push(String.fromCharCode(128 + (r >> 6 & 63))),
            t.push(String.fromCharCode(128 + (r & 63)));
            break;
        default:
            t.push(String.fromCharCode(224 + (i >> 12))),
            t.push(String.fromCharCode(128 + (i >> 6 & 63))),
            t.push(String.fromCharCode(128 + (i & 63)))
        }
    return t.join("")
}
;
var iB = function() {
    var e = [["nbsp", " "], ["middot", "\xB7"], ["quot", '"'], ["apos", "'"], ["gt", ">"], ["lt", "<"], ["amp", "&"]].map(function(t) {
        return [new RegExp("&" + t[0] + ";","ig"), t[1]]
    });
    return function(n) {
        for (var i = n.replace(/^[\t\n\r ]+/, "").replace(/[\t\n\r ]+$/, "").replace(/>\s+/g, ">").replace(/\s+</g, "<").replace(/[\t\n\r ]+/g, " ").replace(/<\s*[bB][rR]\s*\/?>/g, `
`).replace(/<[^>]*>/g, ""), r = 0; r < e.length; ++r)
            i = i.replace(e[r][0], e[r][1]);
        return i
    }
}();
var jw = /(^\s|\s$|\n)/;
function ji(e, t) {
    return "<" + e + (t.match(jw) ? ' xml:space="preserve"' : "") + ">" + t + "</" + e + ">"
}
function C1(e) {
    return zi(e).map(function(t) {
        return " " + t + '="' + e[t] + '"'
    }).join("")
}
function Pe(e, t, n) {
    return "<" + e + (n != null ? C1(n) : "") + (t != null ? (t.match(jw) ? ' xml:space="preserve"' : "") + ">" + t + "</" + e : "/") + ">"
}
function _7(e, t) {
    try {
        return e.toISOString().replace(/\.\d*/, "")
    } catch (n) {
        if (t)
            throw n
    }
    return ""
}
function rB(e, t) {
    switch (typeof e) {
    case "string":
        var n = Pe("vt:lpwstr", en(e));
        return t && (n = n.replace(/&quot;/g, "_x0022_")),
        n;
    case "number":
        return Pe((e | 0) == e ? "vt:i4" : "vt:r8", en(String(e)));
    case "boolean":
        return Pe("vt:bool", e ? "true" : "false")
    }
    if (e instanceof Date)
        return Pe("vt:filetime", _7(e));
    throw new Error("Unable to serialize " + e)
}
var Ai = {
    CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/metadata/core-properties",
    CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/custom-properties",
    EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties",
    CT: "http://schemas.openxmlformats.org/package/2006/content-types",
    RELS: "http://schemas.openxmlformats.org/package/2006/relationships",
    TCMNT: "http://schemas.microsoft.com/office/spreadsheetml/2018/threadedcomments",
    dc: "http://purl.org/dc/elements/1.1/",
    dcterms: "http://purl.org/dc/terms/",
    dcmitype: "http://purl.org/dc/dcmitype/",
    mx: "http://schemas.microsoft.com/office/mac/excel/2008/main",
    r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
    sjs: "http://schemas.openxmlformats.org/package/2006/sheetjs/core-properties",
    vt: "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes",
    xsi: "http://www.w3.org/2001/XMLSchema-instance",
    xsd: "http://www.w3.org/2001/XMLSchema"
}
  , Ku = ["http://schemas.openxmlformats.org/spreadsheetml/2006/main", "http://purl.oclc.org/ooxml/spreadsheetml/main", "http://schemas.microsoft.com/office/excel/2006/main", "http://schemas.microsoft.com/office/excel/2006/2"]
  , Ss = {
    o: "urn:schemas-microsoft-com:office:office",
    x: "urn:schemas-microsoft-com:office:excel",
    ss: "urn:schemas-microsoft-com:office:spreadsheet",
    dt: "uuid:C2F41010-65B3-11d1-A29F-00AA00C14882",
    mv: "http://macVmlSchemaUri",
    v: "urn:schemas-microsoft-com:vml",
    html: "http://www.w3.org/TR/REC-html40"
};
function sB(e, t) {
    for (var n = 1 - 2 * (e[t + 7] >>> 7), i = ((e[t + 7] & 127) << 4) + (e[t + 6] >>> 4 & 15), r = e[t + 6] & 15, s = 5; s >= 0; --s)
        r = r * 256 + e[t + s];
    return i == 2047 ? r == 0 ? n * (1 / 0) : NaN : (i == 0 ? i = -1022 : (i -= 1023,
    r += Math.pow(2, 52)),
    n * Math.pow(2, i - 52) * r)
}
function oB(e, t, n) {
    var i = (t < 0 || 1 / t == -1 / 0 ? 1 : 0) << 7
      , r = 0
      , s = 0
      , o = i ? -t : t;
    isFinite(o) ? o == 0 ? r = s = 0 : (r = Math.floor(Math.log(o) / Math.LN2),
    s = o * Math.pow(2, 52 - r),
    r <= -1023 && (!isFinite(s) || s < Math.pow(2, 52)) ? r = -1022 : (s -= Math.pow(2, 52),
    r += 1023)) : (r = 2047,
    s = isNaN(t) ? 26985 : 0);
    for (var a = 0; a <= 5; ++a,
    s /= 256)
        e[n + a] = s & 255;
    e[n + 6] = (r & 15) << 4 | s & 15,
    e[n + 7] = r >> 4 | i
}
var nw = function(e) {
    for (var t = [], n = 10240, i = 0; i < e[0].length; ++i)
        if (e[0][i])
            for (var r = 0, s = e[0][i].length; r < s; r += n)
                t.push.apply(t, e[0][i].slice(r, r + n));
    return t
}
  , iw = zt ? function(e) {
    return e[0].length > 0 && Buffer.isBuffer(e[0][0]) ? Buffer.concat(e[0].map(function(t) {
        return Buffer.isBuffer(t) ? t : Ha(t)
    })) : nw(e)
}
: nw
  , rw = function(e, t, n) {
    for (var i = [], r = t; r < n; r += 2)
        i.push(String.fromCharCode(p1(e, r)));
    return i.join("").replace(Vu, "")
}
  , g2 = zt ? function(e, t, n) {
    return Buffer.isBuffer(e) ? e.toString("utf16le", t, n).replace(Vu, "") : rw(e, t, n)
}
: rw
  , sw = function(e, t, n) {
    for (var i = [], r = t; r < t + n; ++r)
        i.push(("0" + e[r].toString(16)).slice(-2));
    return i.join("")
}
  , qw = zt ? function(e, t, n) {
    return Buffer.isBuffer(e) ? e.toString("hex", t, t + n) : sw(e, t, n)
}
: sw
  , ow = function(e, t, n) {
    for (var i = [], r = t; r < n; r++)
        i.push(String.fromCharCode(Hu(e, r)));
    return i.join("")
}
  , Yu = zt ? function(t, n, i) {
    return Buffer.isBuffer(t) ? t.toString("utf8", n, i) : ow(t, n, i)
}
: ow
  , zw = function(e, t) {
    var n = ki(e, t);
    return n > 0 ? Yu(e, t + 4, t + 4 + n - 1) : ""
}
  , O7 = zw
  , Xw = function(e, t) {
    var n = ki(e, t);
    return n > 0 ? Yu(e, t + 4, t + 4 + n - 1) : ""
}
  , P7 = Xw
  , Kw = function(e, t) {
    var n = 2 * ki(e, t);
    return n > 0 ? Yu(e, t + 4, t + 4 + n - 1) : ""
}
  , M7 = Kw
  , Yw = function(t, n) {
    var i = ki(t, n);
    return i > 0 ? g2(t, n + 4, n + 4 + i) : ""
}
  , k7 = Yw
  , Qw = function(e, t) {
    var n = ki(e, t);
    return n > 0 ? Yu(e, t + 4, t + 4 + n) : ""
}
  , A7 = Qw
  , Jw = function(e, t) {
    return sB(e, t)
}
  , t2 = Jw
  , I7 = function(t) {
    return Array.isArray(t) || typeof Uint8Array < "u" && t instanceof Uint8Array
};
zt && (O7 = function(t, n) {
    if (!Buffer.isBuffer(t))
        return zw(t, n);
    var i = t.readUInt32LE(n);
    return i > 0 ? t.toString("utf8", n + 4, n + 4 + i - 1) : ""
}
,
P7 = function(t, n) {
    if (!Buffer.isBuffer(t))
        return Xw(t, n);
    var i = t.readUInt32LE(n);
    return i > 0 ? t.toString("utf8", n + 4, n + 4 + i - 1) : ""
}
,
M7 = function(t, n) {
    if (!Buffer.isBuffer(t))
        return Kw(t, n);
    var i = 2 * t.readUInt32LE(n);
    return t.toString("utf16le", n + 4, n + 4 + i - 1)
}
,
k7 = function(t, n) {
    if (!Buffer.isBuffer(t))
        return Yw(t, n);
    var i = t.readUInt32LE(n);
    return t.toString("utf16le", n + 4, n + 4 + i)
}
,
A7 = function(t, n) {
    if (!Buffer.isBuffer(t))
        return Qw(t, n);
    var i = t.readUInt32LE(n);
    return t.toString("utf8", n + 4, n + 4 + i)
}
,
t2 = function(t, n) {
    return Buffer.isBuffer(t) ? t.readDoubleLE(n) : Jw(t, n)
}
,
I7 = function(t) {
    return Buffer.isBuffer(t) || Array.isArray(t) || typeof Uint8Array < "u" && t instanceof Uint8Array
}
);
function aB() {
    g2 = function(e, t, n) {
        return un.utils.decode(1200, e.slice(t, n)).replace(Vu, "")
    }
    ,
    Yu = function(e, t, n) {
        return un.utils.decode(65001, e.slice(t, n))
    }
    ,
    O7 = function(e, t) {
        var n = ki(e, t);
        return n > 0 ? un.utils.decode(zu, e.slice(t + 4, t + 4 + n - 1)) : ""
    }
    ,
    P7 = function(e, t) {
        var n = ki(e, t);
        return n > 0 ? un.utils.decode(e0, e.slice(t + 4, t + 4 + n - 1)) : ""
    }
    ,
    M7 = function(e, t) {
        var n = 2 * ki(e, t);
        return n > 0 ? un.utils.decode(1200, e.slice(t + 4, t + 4 + n - 1)) : ""
    }
    ,
    k7 = function(e, t) {
        var n = ki(e, t);
        return n > 0 ? un.utils.decode(1200, e.slice(t + 4, t + 4 + n)) : ""
    }
    ,
    A7 = function(e, t) {
        var n = ki(e, t);
        return n > 0 ? un.utils.decode(65001, e.slice(t + 4, t + 4 + n)) : ""
    }
}
typeof un < "u" && aB();
var Hu = function(e, t) {
    return e[t]
}
  , p1 = function(e, t) {
    return e[t + 1] * 256 + e[t]
}
  , cB = function(e, t) {
    var n = e[t + 1] * 256 + e[t];
    return n < 32768 ? n : (65535 - n + 1) * -1
}
  , ki = function(e, t) {
    return e[t + 3] * (1 << 24) + (e[t + 2] << 16) + (e[t + 1] << 8) + e[t]
}
  , Zl = function(e, t) {
    return e[t + 3] << 24 | e[t + 2] << 16 | e[t + 1] << 8 | e[t]
}
  , lB = function(e, t) {
    return e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]
};
function m1(e, t) {
    var n = "", i, r, s = [], o, a, c, l;
    switch (t) {
    case "dbcs":
        if (l = this.l,
        zt && Buffer.isBuffer(this))
            n = this.slice(this.l, this.l + 2 * e).toString("utf16le");
        else
            for (c = 0; c < e; ++c)
                n += String.fromCharCode(p1(this, l)),
                l += 2;
        e *= 2;
        break;
    case "utf8":
        n = Yu(this, this.l, this.l + e);
        break;
    case "utf16le":
        e *= 2,
        n = g2(this, this.l, this.l + e);
        break;
    case "wstr":
        if (typeof un < "u")
            n = un.utils.decode(e0, this.slice(this.l, this.l + 2 * e));
        else
            return m1.call(this, e, "dbcs");
        e = 2 * e;
        break;
    case "lpstr-ansi":
        n = O7(this, this.l),
        e = 4 + ki(this, this.l);
        break;
    case "lpstr-cp":
        n = P7(this, this.l),
        e = 4 + ki(this, this.l);
        break;
    case "lpwstr":
        n = M7(this, this.l),
        e = 4 + 2 * ki(this, this.l);
        break;
    case "lpp4":
        e = 4 + ki(this, this.l),
        n = k7(this, this.l),
        e & 2 && (e += 2);
        break;
    case "8lpp4":
        e = 4 + ki(this, this.l),
        n = A7(this, this.l),
        e & 3 && (e += 4 - (e & 3));
        break;
    case "cstr":
        for (e = 0,
        n = ""; (o = Hu(this, this.l + e++)) !== 0; )
            s.push(V3(o));
        n = s.join("");
        break;
    case "_wstr":
        for (e = 0,
        n = ""; (o = p1(this, this.l + e)) !== 0; )
            s.push(V3(o)),
            e += 2;
        e += 2,
        n = s.join("");
        break;
    case "dbcs-cont":
        for (n = "",
        l = this.l,
        c = 0; c < e; ++c) {
            if (this.lens && this.lens.indexOf(l) !== -1)
                return o = Hu(this, l),
                this.l = l + 1,
                a = m1.call(this, e - c, o ? "dbcs-cont" : "sbcs-cont"),
                s.join("") + a;
            s.push(V3(p1(this, l))),
            l += 2
        }
        n = s.join(""),
        e *= 2;
        break;
    case "cpstr":
        if (typeof un < "u") {
            n = un.utils.decode(e0, this.slice(this.l, this.l + e));
            break
        }
    case "sbcs-cont":
        for (n = "",
        l = this.l,
        c = 0; c != e; ++c) {
            if (this.lens && this.lens.indexOf(l) !== -1)
                return o = Hu(this, l),
                this.l = l + 1,
                a = m1.call(this, e - c, o ? "dbcs-cont" : "sbcs-cont"),
                s.join("") + a;
            s.push(V3(Hu(this, l))),
            l += 1
        }
        n = s.join("");
        break;
    default:
        switch (e) {
        case 1:
            return i = Hu(this, this.l),
            this.l++,
            i;
        case 2:
            return i = (t === "i" ? cB : p1)(this, this.l),
            this.l += 2,
            i;
        case 4:
        case -4:
            return t === "i" || !(this[this.l + 3] & 128) ? (i = (e > 0 ? Zl : lB)(this, this.l),
            this.l += 4,
            i) : (r = ki(this, this.l),
            this.l += 4,
            r);
        case 8:
        case -8:
            if (t === "f")
                return e == 8 ? r = t2(this, this.l) : r = t2([this[this.l + 7], this[this.l + 6], this[this.l + 5], this[this.l + 4], this[this.l + 3], this[this.l + 2], this[this.l + 1], this[this.l + 0]], 0),
                this.l += 8,
                r;
            e = 8;
        case 16:
            n = qw(this, this.l, e);
            break
        }
    }
    return this.l += e,
    n
}
var uB = function(e, t, n) {
    e[n] = t & 255,
    e[n + 1] = t >>> 8 & 255,
    e[n + 2] = t >>> 16 & 255,
    e[n + 3] = t >>> 24 & 255
}
  , hB = function(e, t, n) {
    e[n] = t & 255,
    e[n + 1] = t >> 8 & 255,
    e[n + 2] = t >> 16 & 255,
    e[n + 3] = t >> 24 & 255
}
  , dB = function(e, t, n) {
    e[n] = t & 255,
    e[n + 1] = t >>> 8 & 255
};
function fB(e, t, n) {
    var i = 0
      , r = 0;
    if (n === "dbcs") {
        for (r = 0; r != t.length; ++r)
            dB(this, t.charCodeAt(r), this.l + 2 * r);
        i = 2 * t.length
    } else if (n === "sbcs") {
        if (typeof un < "u" && zu == 874)
            for (r = 0; r != t.length; ++r) {
                var s = un.utils.encode(zu, t.charAt(r));
                this[this.l + r] = s[0]
            }
        else
            for (t = t.replace(/[^\x00-\x7F]/g, "_"),
            r = 0; r != t.length; ++r)
                this[this.l + r] = t.charCodeAt(r) & 255;
        i = t.length
    } else if (n === "hex") {
        for (; r < e; ++r)
            this[this.l++] = parseInt(t.slice(2 * r, 2 * r + 2), 16) || 0;
        return this
    } else if (n === "utf16le") {
        var o = Math.min(this.l + e, this.length);
        for (r = 0; r < Math.min(t.length, e); ++r) {
            var a = t.charCodeAt(r);
            this[this.l++] = a & 255,
            this[this.l++] = a >> 8
        }
        for (; this.l < o; )
            this[this.l++] = 0;
        return this
    } else
        switch (e) {
        case 1:
            i = 1,
            this[this.l] = t & 255;
            break;
        case 2:
            i = 2,
            this[this.l] = t & 255,
            t >>>= 8,
            this[this.l + 1] = t & 255;
            break;
        case 3:
            i = 3,
            this[this.l] = t & 255,
            t >>>= 8,
            this[this.l + 1] = t & 255,
            t >>>= 8,
            this[this.l + 2] = t & 255;
            break;
        case 4:
            i = 4,
            uB(this, t, this.l);
            break;
        case 8:
            if (i = 8,
            n === "f") {
                oB(this, t, this.l);
                break
            }
        case 16:
            break;
        case -4:
            i = 4,
            hB(this, t, this.l);
            break
        }
    return this.l += i,
    this
}
function Zw(e, t) {
    var n = qw(this, this.l, e.length >> 1);
    if (n !== e)
        throw new Error(t + "Expected " + e + " saw " + n);
    this.l += e.length >> 1
}
function bs(e, t) {
    e.l = t,
    e.read_shift = m1,
    e.chk = Zw,
    e.write_shift = fB
}
function Zo(e, t) {
    e.l += t
}
function ce(e) {
    var t = n0(e);
    return bs(t, 0),
    t
}
function Yr() {
    var e = []
      , t = zt ? 256 : 2048
      , n = function(l) {
        var u = ce(l);
        return bs(u, 0),
        u
    }
      , i = n(t)
      , r = function() {
        i && (i.length > i.l && (i = i.slice(0, i.l),
        i.l = i.length),
        i.length > 0 && e.push(i),
        i = null)
    }
      , s = function(l) {
        return i && l < i.length - i.l ? i : (r(),
        i = n(Math.max(l + 1, t)))
    }
      , o = function() {
        return r(),
        $i(e)
    }
      , a = function(l) {
        r(),
        i = l,
        i.l == null && (i.l = i.length),
        s(t)
    };
    return {
        next: s,
        push: a,
        end: o,
        _bufs: e
    }
}
function pe(e, t, n, i) {
    var r = +t, s;
    if (!isNaN(r)) {
        i || (i = o$[r].p || (n || []).length || 0),
        s = 1 + (r >= 128 ? 1 : 0) + 1,
        i >= 128 && ++s,
        i >= 16384 && ++s,
        i >= 2097152 && ++s;
        var o = e.next(s);
        r <= 127 ? o.write_shift(1, r) : (o.write_shift(1, (r & 127) + 128),
        o.write_shift(1, r >> 7));
        for (var a = 0; a != 4; ++a)
            if (i >= 128)
                o.write_shift(1, (i & 127) + 128),
                i >>= 7;
            else {
                o.write_shift(1, i);
                break
            }
        i > 0 && I7(n) && e.push(n)
    }
}
function v1(e, t, n) {
    var i = Jr(e);
    if (t.s ? (i.cRel && (i.c += t.s.c),
    i.rRel && (i.r += t.s.r)) : (i.cRel && (i.c += t.c),
    i.rRel && (i.r += t.r)),
    !n || n.biff < 12) {
        for (; i.c >= 256; )
            i.c -= 256;
        for (; i.r >= 65536; )
            i.r -= 65536
    }
    return i
}
function aw(e, t, n) {
    var i = Jr(e);
    return i.s = v1(i.s, t.s, n),
    i.e = v1(i.e, t.s, n),
    i
}
function _1(e, t) {
    if (e.cRel && e.c < 0)
        for (e = Jr(e); e.c < 0; )
            e.c += t > 8 ? 16384 : 256;
    if (e.rRel && e.r < 0)
        for (e = Jr(e); e.r < 0; )
            e.r += t > 8 ? 1048576 : t > 5 ? 65536 : 16384;
    var n = tn(e);
    return !e.cRel && e.cRel != null && (n = mB(n)),
    !e.rRel && e.rRel != null && (n = pB(n)),
    n
}
function h7(e, t) {
    return e.s.r == 0 && !e.s.rRel && e.e.r == (t.biff >= 12 ? 1048575 : t.biff >= 8 ? 65536 : 16384) && !e.e.rRel ? (e.s.cRel ? "" : "$") + lr(e.s.c) + ":" + (e.e.cRel ? "" : "$") + lr(e.e.c) : e.s.c == 0 && !e.s.cRel && e.e.c == (t.biff >= 12 ? 16383 : 255) && !e.e.cRel ? (e.s.rRel ? "" : "$") + qi(e.s.r) + ":" + (e.e.rRel ? "" : "$") + qi(e.e.r) : _1(e.s, t.biff) + ":" + _1(e.e, t.biff)
}
function R7(e) {
    return parseInt(gB(e), 10) - 1
}
function qi(e) {
    return "" + (e + 1)
}
function pB(e) {
    return e.replace(/([A-Z]|^)(\d+)$/, "$1$$$2")
}
function gB(e) {
    return e.replace(/\$(\d+)$/, "$1")
}
function D7(e) {
    for (var t = vB(e), n = 0, i = 0; i !== t.length; ++i)
        n = 26 * n + t.charCodeAt(i) - 64;
    return n - 1
}
function lr(e) {
    if (e < 0)
        throw new Error("invalid column " + e);
    var t = "";
    for (++e; e; e = Math.floor((e - 1) / 26))
        t = String.fromCharCode((e - 1) % 26 + 65) + t;
    return t
}
function mB(e) {
    return e.replace(/^([A-Z])/, "$$$1")
}
function vB(e) {
    return e.replace(/^\$([A-Z])/, "$1")
}
function _B(e) {
    return e.replace(/(\$?[A-Z]*)(\$?\d*)/, "$1,$2").split(",")
}
function Ii(e) {
    for (var t = 0, n = 0, i = 0; i < e.length; ++i) {
        var r = e.charCodeAt(i);
        r >= 48 && r <= 57 ? t = 10 * t + (r - 48) : r >= 65 && r <= 90 && (n = 26 * n + (r - 64))
    }
    return {
        c: n - 1,
        r: t - 1
    }
}
function tn(e) {
    for (var t = e.c + 1, n = ""; t; t = (t - 1) / 26 | 0)
        n = String.fromCharCode((t - 1) % 26 + 65) + n;
    return n + (e.r + 1)
}
function xs(e) {
    var t = e.indexOf(":");
    return t == -1 ? {
        s: Ii(e),
        e: Ii(e)
    } : {
        s: Ii(e.slice(0, t)),
        e: Ii(e.slice(t + 1))
    }
}
function si(e, t) {
    return typeof t > "u" || typeof t == "number" ? si(e.s, e.e) : (typeof e != "string" && (e = tn(e)),
    typeof t != "string" && (t = tn(t)),
    e == t ? e : e + ":" + t)
}
function bn(e) {
    var t = {
        s: {
            c: 0,
            r: 0
        },
        e: {
            c: 0,
            r: 0
        }
    }
      , n = 0
      , i = 0
      , r = 0
      , s = e.length;
    for (n = 0; i < s && !((r = e.charCodeAt(i) - 64) < 1 || r > 26); ++i)
        n = 26 * n + r;
    for (t.s.c = --n,
    n = 0; i < s && !((r = e.charCodeAt(i) - 48) < 0 || r > 9); ++i)
        n = 10 * n + r;
    if (t.s.r = --n,
    i === s || r != 10)
        return t.e.c = t.s.c,
        t.e.r = t.s.r,
        t;
    for (++i,
    n = 0; i != s && !((r = e.charCodeAt(i) - 64) < 1 || r > 26); ++i)
        n = 26 * n + r;
    for (t.e.c = --n,
    n = 0; i != s && !((r = e.charCodeAt(i) - 48) < 0 || r > 9); ++i)
        n = 10 * n + r;
    return t.e.r = --n,
    t
}
function cw(e, t) {
    var n = e.t == "d" && t instanceof Date;
    if (e.z != null)
        try {
            return e.w = Vc(e.z, n ? Qr(t) : t)
        } catch {}
    try {
        return e.w = Vc((e.XF || {}).numFmtId || (n ? 14 : 0), n ? Qr(t) : t)
    } catch {
        return "" + t
    }
}
function Ua(e, t, n) {
    return e == null || e.t == null || e.t == "z" ? "" : e.w !== void 0 ? e.w : (e.t == "d" && !e.z && n && n.dateNF && (e.z = n.dateNF),
    e.t == "e" ? M1[e.v] || e.v : t == null ? cw(e, e.v) : cw(e, t))
}
function s0(e, t) {
    var n = t && t.sheet ? t.sheet : "Sheet1"
      , i = {};
    return i[n] = e,
    {
        SheetNames: [n],
        Sheets: i
    }
}
function eC(e, t, n) {
    var i = n || {}
      , r = e ? Array.isArray(e) : i.dense;
    Jo != null && r == null && (r = Jo);
    var s = e || (r ? [] : {})
      , o = 0
      , a = 0;
    if (s && i.origin != null) {
        if (typeof i.origin == "number")
            o = i.origin;
        else {
            var c = typeof i.origin == "string" ? Ii(i.origin) : i.origin;
            o = c.r,
            a = c.c
        }
        s["!ref"] || (s["!ref"] = "A1:A1")
    }
    var l = {
        s: {
            c: 1e7,
            r: 1e7
        },
        e: {
            c: 0,
            r: 0
        }
    };
    if (s["!ref"]) {
        var u = bn(s["!ref"]);
        l.s.c = u.s.c,
        l.s.r = u.s.r,
        l.e.c = Math.max(l.e.c, u.e.c),
        l.e.r = Math.max(l.e.r, u.e.r),
        o == -1 && (l.e.r = o = u.e.r + 1)
    }
    for (var h = 0; h != t.length; ++h)
        if (t[h]) {
            if (!Array.isArray(t[h]))
                throw new Error("aoa_to_sheet expects an array of arrays");
            for (var d = 0; d != t[h].length; ++d)
                if (!(typeof t[h][d] > "u")) {
                    var f = {
                        v: t[h][d]
                    }
                      , g = o + h
                      , p = a + d;
                    if (l.s.r > g && (l.s.r = g),
                    l.s.c > p && (l.s.c = p),
                    l.e.r < g && (l.e.r = g),
                    l.e.c < p && (l.e.c = p),
                    t[h][d] && typeof t[h][d] == "object" && !Array.isArray(t[h][d]) && !(t[h][d]instanceof Date))
                        f = t[h][d];
                    else if (Array.isArray(f.v) && (f.f = t[h][d][1],
                    f.v = f.v[0]),
                    f.v === null)
                        if (f.f)
                            f.t = "n";
                        else if (i.nullError)
                            f.t = "e",
                            f.v = 0;
                        else if (i.sheetStubs)
                            f.t = "z";
                        else
                            continue;
                    else
                        typeof f.v == "number" ? f.t = "n" : typeof f.v == "boolean" ? f.t = "b" : f.v instanceof Date ? (f.z = i.dateNF || Bn[14],
                        i.cellDates ? (f.t = "d",
                        f.w = Vc(f.z, Qr(f.v))) : (f.t = "n",
                        f.v = Qr(f.v),
                        f.w = Vc(f.z, f.v))) : f.t = "s";
                    if (r)
                        s[g] || (s[g] = []),
                        s[g][p] && s[g][p].z && (f.z = s[g][p].z),
                        s[g][p] = f;
                    else {
                        var v = tn({
                            c: p,
                            r: g
                        });
                        s[v] && s[v].z && (f.z = s[v].z),
                        s[v] = f
                    }
                }
        }
    return l.s.c < 1e7 && (s["!ref"] = si(l)),
    s
}
function Qu(e, t) {
    return eC(null, e, t)
}
function yB(e) {
    return e.read_shift(4, "i")
}
function fo(e, t) {
    return t || (t = ce(4)),
    t.write_shift(4, e),
    t
}
function ur(e) {
    var t = e.read_shift(4);
    return t === 0 ? "" : e.read_shift(t, "dbcs")
}
function Ri(e, t) {
    var n = !1;
    return t == null && (n = !0,
    t = ce(4 + 2 * e.length)),
    t.write_shift(4, e.length),
    e.length > 0 && t.write_shift(0, e, "dbcs"),
    n ? t.slice(0, t.l) : t
}
function bB(e) {
    return {
        ich: e.read_shift(2),
        ifnt: e.read_shift(2)
    }
}
function SB(e, t) {
    return t || (t = ce(4)),
    t.write_shift(2, e.ich || 0),
    t.write_shift(2, e.ifnt || 0),
    t
}
function N7(e, t) {
    var n = e.l
      , i = e.read_shift(1)
      , r = ur(e)
      , s = []
      , o = {
        t: r,
        h: r
    };
    if (i & 1) {
        for (var a = e.read_shift(4), c = 0; c != a; ++c)
            s.push(bB(e));
        o.r = s
    } else
        o.r = [{
            ich: 0,
            ifnt: 0
        }];
    return e.l = n + t,
    o
}
function xB(e, t) {
    var n = !1;
    return t == null && (n = !0,
    t = ce(15 + 4 * e.t.length)),
    t.write_shift(1, 0),
    Ri(e.t, t),
    n ? t.slice(0, t.l) : t
}
var wB = N7;
function CB(e, t) {
    var n = !1;
    return t == null && (n = !0,
    t = ce(23 + 4 * e.t.length)),
    t.write_shift(1, 1),
    Ri(e.t, t),
    t.write_shift(4, 1),
    SB({
        ich: 0,
        ifnt: 0
    }, t),
    n ? t.slice(0, t.l) : t
}
function Bs(e) {
    var t = e.read_shift(4)
      , n = e.read_shift(2);
    return n += e.read_shift(1) << 16,
    e.l++,
    {
        c: t,
        iStyleRef: n
    }
}
function o0(e, t) {
    return t == null && (t = ce(8)),
    t.write_shift(-4, e.c),
    t.write_shift(3, e.iStyleRef || e.s),
    t.write_shift(1, 0),
    t
}
function a0(e) {
    var t = e.read_shift(2);
    return t += e.read_shift(1) << 16,
    e.l++,
    {
        c: -1,
        iStyleRef: t
    }
}
function c0(e, t) {
    return t == null && (t = ce(4)),
    t.write_shift(3, e.iStyleRef || e.s),
    t.write_shift(1, 0),
    t
}
var EB = ur
  , tC = Ri;
function F7(e) {
    var t = e.read_shift(4);
    return t === 0 || t === 4294967295 ? "" : e.read_shift(t, "dbcs")
}
function n2(e, t) {
    var n = !1;
    return t == null && (n = !0,
    t = ce(127)),
    t.write_shift(4, e.length > 0 ? e.length : 4294967295),
    e.length > 0 && t.write_shift(0, e, "dbcs"),
    n ? t.slice(0, t.l) : t
}
var TB = ur
  , y7 = F7
  , L7 = n2;
function nC(e) {
    var t = e.slice(e.l, e.l + 4)
      , n = t[0] & 1
      , i = t[0] & 2;
    e.l += 4;
    var r = i === 0 ? t2([0, 0, 0, 0, t[0] & 252, t[1], t[2], t[3]], 0) : Zl(t, 0) >> 2;
    return n ? r / 100 : r
}
function iC(e, t) {
    t == null && (t = ce(4));
    var n = 0
      , i = 0
      , r = e * 100;
    if (e == (e | 0) && e >= -(1 << 29) && e < 1 << 29 ? i = 1 : r == (r | 0) && r >= -(1 << 29) && r < 1 << 29 && (i = 1,
    n = 1),
    i)
        t.write_shift(-4, ((n ? r : e) << 2) + (n + 2));
    else
        throw new Error("unsupported RkNumber " + e)
}
function rC(e) {
    var t = {
        s: {},
        e: {}
    };
    return t.s.r = e.read_shift(4),
    t.e.r = e.read_shift(4),
    t.s.c = e.read_shift(4),
    t.e.c = e.read_shift(4),
    t
}
function OB(e, t) {
    return t || (t = ce(16)),
    t.write_shift(4, e.s.r),
    t.write_shift(4, e.e.r),
    t.write_shift(4, e.s.c),
    t.write_shift(4, e.e.c),
    t
}
var l0 = rC
  , Ju = OB;
function Zu(e) {
    if (e.length - e.l < 8)
        throw "XLS Xnum Buffer underflow";
    return e.read_shift(8, "f")
}
function i0(e, t) {
    return (t || ce(8)).write_shift(8, e, "f")
}
function PB(e) {
    var t = {}
      , n = e.read_shift(1)
      , i = n >>> 1
      , r = e.read_shift(1)
      , s = e.read_shift(2, "i")
      , o = e.read_shift(1)
      , a = e.read_shift(1)
      , c = e.read_shift(1);
    switch (e.l++,
    i) {
    case 0:
        t.auto = 1;
        break;
    case 1:
        t.index = r;
        var l = LB[r];
        l && (t.rgb = yw(l));
        break;
    case 2:
        t.rgb = yw([o, a, c]);
        break;
    case 3:
        t.theme = r;
        break
    }
    return s != 0 && (t.tint = s > 0 ? s / 32767 : s / 32768),
    t
}
function i2(e, t) {
    if (t || (t = ce(8)),
    !e || e.auto)
        return t.write_shift(4, 0),
        t.write_shift(4, 0),
        t;
    e.index != null ? (t.write_shift(1, 2),
    t.write_shift(1, e.index)) : e.theme != null ? (t.write_shift(1, 6),
    t.write_shift(1, e.theme)) : (t.write_shift(1, 5),
    t.write_shift(1, 0));
    var n = e.tint || 0;
    if (n > 0 ? n *= 32767 : n < 0 && (n *= 32768),
    t.write_shift(2, n),
    !e.rgb || e.theme != null)
        t.write_shift(2, 0),
        t.write_shift(1, 0),
        t.write_shift(1, 0);
    else {
        var i = e.rgb || "FFFFFF";
        typeof i == "number" && (i = ("000000" + i.toString(16)).slice(-6)),
        t.write_shift(1, parseInt(i.slice(0, 2), 16)),
        t.write_shift(1, parseInt(i.slice(2, 4), 16)),
        t.write_shift(1, parseInt(i.slice(4, 6), 16)),
        t.write_shift(1, 255)
    }
    return t
}
function MB(e) {
    var t = e.read_shift(1);
    e.l++;
    var n = {
        fBold: t & 1,
        fItalic: t & 2,
        fUnderline: t & 4,
        fStrikeout: t & 8,
        fOutline: t & 16,
        fShadow: t & 32,
        fCondense: t & 64,
        fExtend: t & 128
    };
    return n
}
function kB(e, t) {
    t || (t = ce(2));
    var n = (e.italic ? 2 : 0) | (e.strike ? 8 : 0) | (e.outline ? 16 : 0) | (e.shadow ? 32 : 0) | (e.condense ? 64 : 0) | (e.extend ? 128 : 0);
    return t.write_shift(1, n),
    t.write_shift(1, 0),
    t
}
var sC = 2
  , ys = 3
  , z3 = 11;
var r2 = 19;
var X3 = 64
  , AB = 65
  , IB = 71;
var RB = 4108
  , DB = 4126
  , Wi = 80;
var lw = {
    1: {
        n: "CodePage",
        t: sC
    },
    2: {
        n: "Category",
        t: Wi
    },
    3: {
        n: "PresentationFormat",
        t: Wi
    },
    4: {
        n: "ByteCount",
        t: ys
    },
    5: {
        n: "LineCount",
        t: ys
    },
    6: {
        n: "ParagraphCount",
        t: ys
    },
    7: {
        n: "SlideCount",
        t: ys
    },
    8: {
        n: "NoteCount",
        t: ys
    },
    9: {
        n: "HiddenCount",
        t: ys
    },
    10: {
        n: "MultimediaClipCount",
        t: ys
    },
    11: {
        n: "ScaleCrop",
        t: z3
    },
    12: {
        n: "HeadingPairs",
        t: RB
    },
    13: {
        n: "TitlesOfParts",
        t: DB
    },
    14: {
        n: "Manager",
        t: Wi
    },
    15: {
        n: "Company",
        t: Wi
    },
    16: {
        n: "LinksUpToDate",
        t: z3
    },
    17: {
        n: "CharacterCount",
        t: ys
    },
    19: {
        n: "SharedDoc",
        t: z3
    },
    22: {
        n: "HyperlinksChanged",
        t: z3
    },
    23: {
        n: "AppVersion",
        t: ys,
        p: "version"
    },
    24: {
        n: "DigSig",
        t: AB
    },
    26: {
        n: "ContentType",
        t: Wi
    },
    27: {
        n: "ContentStatus",
        t: Wi
    },
    28: {
        n: "Language",
        t: Wi
    },
    29: {
        n: "Version",
        t: Wi
    },
    255: {},
    2147483648: {
        n: "Locale",
        t: r2
    },
    2147483651: {
        n: "Behavior",
        t: r2
    },
    1919054434: {}
}
  , uw = {
    1: {
        n: "CodePage",
        t: sC
    },
    2: {
        n: "Title",
        t: Wi
    },
    3: {
        n: "Subject",
        t: Wi
    },
    4: {
        n: "Author",
        t: Wi
    },
    5: {
        n: "Keywords",
        t: Wi
    },
    6: {
        n: "Comments",
        t: Wi
    },
    7: {
        n: "Template",
        t: Wi
    },
    8: {
        n: "LastAuthor",
        t: Wi
    },
    9: {
        n: "RevNumber",
        t: Wi
    },
    10: {
        n: "EditTime",
        t: X3
    },
    11: {
        n: "LastPrinted",
        t: X3
    },
    12: {
        n: "CreatedDate",
        t: X3
    },
    13: {
        n: "ModifiedDate",
        t: X3
    },
    14: {
        n: "PageCount",
        t: ys
    },
    15: {
        n: "WordCount",
        t: ys
    },
    16: {
        n: "CharCount",
        t: ys
    },
    17: {
        n: "Thumbnail",
        t: IB
    },
    18: {
        n: "Application",
        t: Wi
    },
    19: {
        n: "DocSecurity",
        t: ys
    },
    255: {},
    2147483648: {
        n: "Locale",
        t: r2
    },
    2147483651: {
        n: "Behavior",
        t: r2
    },
    1919054434: {}
};
function NB(e) {
    return e.map(function(t) {
        return [t >> 16 & 255, t >> 8 & 255, t & 255]
    })
}
var FB = NB([0, 16777215, 16711680, 65280, 255, 16776960, 16711935, 65535, 0, 16777215, 16711680, 65280, 255, 16776960, 16711935, 65535, 8388608, 32768, 128, 8421376, 8388736, 32896, 12632256, 8421504, 10066431, 10040166, 16777164, 13434879, 6684774, 16744576, 26316, 13421823, 128, 16711935, 16776960, 65535, 8388736, 8388608, 32896, 255, 52479, 13434879, 13434828, 16777113, 10079487, 16751052, 13408767, 16764057, 3368703, 3394764, 10079232, 16763904, 16750848, 16737792, 6710937, 9868950, 13158, 3381606, 13056, 3355392, 10040064, 10040166, 3355545, 3355443, 16777215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
  , LB = Jr(FB)
  , M1 = {
    0: "#NULL!",
    7: "#DIV/0!",
    15: "#VALUE!",
    23: "#REF!",
    29: "#NAME?",
    36: "#NUM!",
    42: "#N/A",
    43: "#GETTING_DATA",
    255: "#WTF?"
};
var BB = {
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": "workbooks",
    "application/vnd.ms-excel.sheet.macroEnabled.main+xml": "workbooks",
    "application/vnd.ms-excel.sheet.binary.macroEnabled.main": "workbooks",
    "application/vnd.ms-excel.addin.macroEnabled.main+xml": "workbooks",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": "workbooks",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": "sheets",
    "application/vnd.ms-excel.worksheet": "sheets",
    "application/vnd.ms-excel.binIndexWs": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": "charts",
    "application/vnd.ms-excel.chartsheet": "charts",
    "application/vnd.ms-excel.macrosheet+xml": "macros",
    "application/vnd.ms-excel.macrosheet": "macros",
    "application/vnd.ms-excel.intlmacrosheet": "TODO",
    "application/vnd.ms-excel.binIndexMs": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": "dialogs",
    "application/vnd.ms-excel.dialogsheet": "dialogs",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml": "strs",
    "application/vnd.ms-excel.sharedStrings": "strs",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": "styles",
    "application/vnd.ms-excel.styles": "styles",
    "application/vnd.openxmlformats-package.core-properties+xml": "coreprops",
    "application/vnd.openxmlformats-officedocument.custom-properties+xml": "custprops",
    "application/vnd.openxmlformats-officedocument.extended-properties+xml": "extprops",
    "application/vnd.openxmlformats-officedocument.customXmlProperties+xml": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.customProperty": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": "comments",
    "application/vnd.ms-excel.comments": "comments",
    "application/vnd.ms-excel.threadedcomments+xml": "threadedcomments",
    "application/vnd.ms-excel.person+xml": "people",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml": "metadata",
    "application/vnd.ms-excel.sheetMetadata": "metadata",
    "application/vnd.ms-excel.pivotTable": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTable+xml": "TODO",
    "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": "TODO",
    "application/vnd.ms-office.chartcolorstyle+xml": "TODO",
    "application/vnd.ms-office.chartstyle+xml": "TODO",
    "application/vnd.ms-office.chartex+xml": "TODO",
    "application/vnd.ms-excel.calcChain": "calcchains",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.calcChain+xml": "calcchains",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings": "TODO",
    "application/vnd.ms-office.activeX": "TODO",
    "application/vnd.ms-office.activeX+xml": "TODO",
    "application/vnd.ms-excel.attachedToolbars": "TODO",
    "application/vnd.ms-excel.connections": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": "TODO",
    "application/vnd.ms-excel.externalLink": "links",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.externalLink+xml": "links",
    "application/vnd.ms-excel.pivotCacheDefinition": "TODO",
    "application/vnd.ms-excel.pivotCacheRecords": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheDefinition+xml": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheRecords+xml": "TODO",
    "application/vnd.ms-excel.queryTable": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.queryTable+xml": "TODO",
    "application/vnd.ms-excel.userNames": "TODO",
    "application/vnd.ms-excel.revisionHeaders": "TODO",
    "application/vnd.ms-excel.revisionLog": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionHeaders+xml": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionLog+xml": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.userNames+xml": "TODO",
    "application/vnd.ms-excel.tableSingleCells": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.tableSingleCells+xml": "TODO",
    "application/vnd.ms-excel.slicer": "TODO",
    "application/vnd.ms-excel.slicerCache": "TODO",
    "application/vnd.ms-excel.slicer+xml": "TODO",
    "application/vnd.ms-excel.slicerCache+xml": "TODO",
    "application/vnd.ms-excel.wsSortMap": "TODO",
    "application/vnd.ms-excel.table": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": "TODO",
    "application/vnd.openxmlformats-officedocument.theme+xml": "themes",
    "application/vnd.openxmlformats-officedocument.themeOverride+xml": "TODO",
    "application/vnd.ms-excel.Timeline+xml": "TODO",
    "application/vnd.ms-excel.TimelineCache+xml": "TODO",
    "application/vnd.ms-office.vbaProject": "vba",
    "application/vnd.ms-office.vbaProjectSignature": "TODO",
    "application/vnd.ms-office.volatileDependencies": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.volatileDependencies+xml": "TODO",
    "application/vnd.ms-excel.controlproperties+xml": "TODO",
    "application/vnd.openxmlformats-officedocument.model+data": "TODO",
    "application/vnd.ms-excel.Survey+xml": "TODO",
    "application/vnd.openxmlformats-officedocument.drawing+xml": "drawings",
    "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": "TODO",
    "application/vnd.openxmlformats-officedocument.drawingml.diagramColors+xml": "TODO",
    "application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml": "TODO",
    "application/vnd.openxmlformats-officedocument.drawingml.diagramLayout+xml": "TODO",
    "application/vnd.openxmlformats-officedocument.drawingml.diagramStyle+xml": "TODO",
    "application/vnd.openxmlformats-officedocument.vmlDrawing": "TODO",
    "application/vnd.openxmlformats-package.relationships+xml": "rels",
    "application/vnd.openxmlformats-officedocument.oleObject": "TODO",
    "image/png": "TODO",
    sheet: "js"
}
  , K3 = {
    workbooks: {
        xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml",
        xlsm: "application/vnd.ms-excel.sheet.macroEnabled.main+xml",
        xlsb: "application/vnd.ms-excel.sheet.binary.macroEnabled.main",
        xlam: "application/vnd.ms-excel.addin.macroEnabled.main+xml",
        xltx: "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml"
    },
    strs: {
        xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml",
        xlsb: "application/vnd.ms-excel.sharedStrings"
    },
    comments: {
        xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml",
        xlsb: "application/vnd.ms-excel.comments"
    },
    sheets: {
        xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml",
        xlsb: "application/vnd.ms-excel.worksheet"
    },
    charts: {
        xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml",
        xlsb: "application/vnd.ms-excel.chartsheet"
    },
    dialogs: {
        xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml",
        xlsb: "application/vnd.ms-excel.dialogsheet"
    },
    macros: {
        xlsx: "application/vnd.ms-excel.macrosheet+xml",
        xlsb: "application/vnd.ms-excel.macrosheet"
    },
    metadata: {
        xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml",
        xlsb: "application/vnd.ms-excel.sheetMetadata"
    },
    styles: {
        xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml",
        xlsb: "application/vnd.ms-excel.styles"
    }
};
function oC() {
    return {
        workbooks: [],
        sheets: [],
        charts: [],
        dialogs: [],
        macros: [],
        rels: [],
        strs: [],
        comments: [],
        threadedcomments: [],
        links: [],
        coreprops: [],
        extprops: [],
        custprops: [],
        themes: [],
        styles: [],
        calcchains: [],
        vba: [],
        drawings: [],
        metadata: [],
        people: [],
        TODO: [],
        xmlns: ""
    }
}
function aC(e, t) {
    var n = zL(BB), i = [], r;
    i[i.length] = oi,
    i[i.length] = Pe("Types", null, {
        xmlns: Ai.CT,
        "xmlns:xsd": Ai.xsd,
        "xmlns:xsi": Ai.xsi
    }),
    i = i.concat([["xml", "application/xml"], ["bin", "application/vnd.ms-excel.sheet.binary.macroEnabled.main"], ["vml", "application/vnd.openxmlformats-officedocument.vmlDrawing"], ["data", "application/vnd.openxmlformats-officedocument.model+data"], ["bmp", "image/bmp"], ["png", "image/png"], ["gif", "image/gif"], ["emf", "image/x-emf"], ["wmf", "image/x-wmf"], ["jpg", "image/jpeg"], ["jpeg", "image/jpeg"], ["tif", "image/tiff"], ["tiff", "image/tiff"], ["pdf", "application/pdf"], ["rels", "application/vnd.openxmlformats-package.relationships+xml"]].map(function(c) {
        return Pe("Default", null, {
            Extension: c[0],
            ContentType: c[1]
        })
    }));
    var s = function(c) {
        e[c] && e[c].length > 0 && (r = e[c][0],
        i[i.length] = Pe("Override", null, {
            PartName: (r[0] == "/" ? "" : "/") + r,
            ContentType: K3[c][t.bookType] || K3[c].xlsx
        }))
    }
      , o = function(c) {
        (e[c] || []).forEach(function(l) {
            i[i.length] = Pe("Override", null, {
                PartName: (l[0] == "/" ? "" : "/") + l,
                ContentType: K3[c][t.bookType] || K3[c].xlsx
            })
        })
    }
      , a = function(c) {
        (e[c] || []).forEach(function(l) {
            i[i.length] = Pe("Override", null, {
                PartName: (l[0] == "/" ? "" : "/") + l,
                ContentType: n[c][0]
            })
        })
    };
    return s("workbooks"),
    o("sheets"),
    o("charts"),
    a("themes"),
    ["strs", "styles"].forEach(s),
    ["coreprops", "extprops", "custprops"].forEach(a),
    a("vba"),
    a("comments"),
    a("threadedcomments"),
    a("drawings"),
    o("metadata"),
    a("people"),
    i.length > 2 && (i[i.length] = "</Types>",
    i[1] = i[1].replace("/>", ">")),
    i.join("")
}
var qt = {
    WB: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
    SHEET: "http://sheetjs.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
    HLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
    VML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing",
    XPATH: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLinkPath",
    XMISS: "http://schemas.microsoft.com/office/2006/relationships/xlExternalLinkPath/xlPathMissing",
    XLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLink",
    CXML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXml",
    CXMLP: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXmlProps",
    CMNT: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",
    CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
    EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties",
    CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties",
    SST: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings",
    STY: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
    THEME: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
    CHART: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart",
    CHARTEX: "http://schemas.microsoft.com/office/2014/relationships/chartEx",
    CS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartsheet",
    WS: ["http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet", "http://purl.oclc.org/ooxml/officeDocument/relationships/worksheet"],
    DS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/dialogsheet",
    MS: "http://schemas.microsoft.com/office/2006/relationships/xlMacrosheet",
    IMG: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
    DRAW: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing",
    XLMETA: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sheetMetadata",
    TCMNT: "http://schemas.microsoft.com/office/2017/10/relationships/threadedComment",
    PEOPLE: "http://schemas.microsoft.com/office/2017/10/relationships/person",
    VBA: "http://schemas.microsoft.com/office/2006/relationships/vbaProject"
};
function cC(e) {
    var t = e.lastIndexOf("/");
    return e.slice(0, t + 1) + "_rels/" + e.slice(t + 1) + ".rels"
}
function $u(e) {
    var t = [oi, Pe("Relationships", null, {
        xmlns: Ai.RELS
    })];
    return zi(e["!id"]).forEach(function(n) {
        t[t.length] = Pe("Relationship", null, e["!id"][n])
    }),
    t.length > 2 && (t[t.length] = "</Relationships>",
    t[1] = t[1].replace("/>", ">")),
    t.join("")
}
function Zt(e, t, n, i, r, s) {
    if (r || (r = {}),
    e["!id"] || (e["!id"] = {}),
    e["!idx"] || (e["!idx"] = 1),
    t < 0)
        for (t = e["!idx"]; e["!id"]["rId" + t]; ++t)
            ;
    if (e["!idx"] = t + 1,
    r.Id = "rId" + t,
    r.Type = i,
    r.Target = n,
    s ? r.TargetMode = s : [qt.HLINK, qt.XPATH, qt.XMISS].indexOf(r.Type) > -1 && (r.TargetMode = "External"),
    e["!id"][r.Id])
        throw new Error("Cannot rewrite rId " + t);
    return e["!id"][r.Id] = r,
    e[("/" + r.Target).replace("//", "/")] = r,
    t
}
function UB(e) {
    var t = [oi];
    t.push(`<manifest:manifest xmlns:manifest="urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" manifest:version="1.2">
`),
    t.push(`  <manifest:file-entry manifest:full-path="/" manifest:version="1.2" manifest:media-type="application/vnd.oasis.opendocument.spreadsheet"/>
`);
    for (var n = 0; n < e.length; ++n)
        t.push('  <manifest:file-entry manifest:full-path="' + e[n][0] + '" manifest:media-type="' + e[n][1] + `"/>
`);
    return t.push("</manifest:manifest>"),
    t.join("")
}
function hw(e, t, n) {
    return ['  <rdf:Description rdf:about="' + e + `">
`, '    <rdf:type rdf:resource="http://docs.oasis-open.org/ns/office/1.2/meta/' + (n || "odf") + "#" + t + `"/>
`, `  </rdf:Description>
`].join("")
}
function HB(e, t) {
    return ['  <rdf:Description rdf:about="' + e + `">
`, '    <ns0:hasPart xmlns:ns0="http://docs.oasis-open.org/ns/office/1.2/meta/pkg#" rdf:resource="' + t + `"/>
`, `  </rdf:Description>
`].join("")
}
function GB(e) {
    var t = [oi];
    t.push(`<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
`);
    for (var n = 0; n != e.length; ++n)
        t.push(hw(e[n][0], e[n][1])),
        t.push(HB("", e[n][0]));
    return t.push(hw("", "Document", "pkg")),
    t.push("</rdf:RDF>"),
    t.join("")
}
function lC() {
    return '<office:document-meta xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0" xmlns:meta="urn:oasis:names:tc:opendocument:xmlns:meta:1.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:xlink="http://www.w3.org/1999/xlink" office:version="1.2"><office:meta><meta:generator>SheetJS ' + b1.version + "</meta:generator></office:meta></office:document-meta>"
}
var t0 = [["cp:category", "Category"], ["cp:contentStatus", "ContentStatus"], ["cp:keywords", "Keywords"], ["cp:lastModifiedBy", "LastAuthor"], ["cp:lastPrinted", "LastPrinted"], ["cp:revision", "RevNumber"], ["cp:version", "Version"], ["dc:creator", "Author"], ["dc:description", "Comments"], ["dc:identifier", "Identifier"], ["dc:language", "Language"], ["dc:subject", "Subject"], ["dc:title", "Title"], ["dcterms:created", "CreatedDate", "date"], ["dcterms:modified", "ModifiedDate", "date"]];
function d7(e, t, n, i, r) {
    r[e] != null || t == null || t === "" || (r[e] = t,
    t = en(t),
    i[i.length] = n ? Pe(e, t, n) : ji(e, t))
}
function uC(e, t) {
    var n = t || {}
      , i = [oi, Pe("cp:coreProperties", null, {
        "xmlns:cp": Ai.CORE_PROPS,
        "xmlns:dc": Ai.dc,
        "xmlns:dcterms": Ai.dcterms,
        "xmlns:dcmitype": Ai.dcmitype,
        "xmlns:xsi": Ai.xsi
    })]
      , r = {};
    if (!e && !n.Props)
        return i.join("");
    e && (e.CreatedDate != null && d7("dcterms:created", typeof e.CreatedDate == "string" ? e.CreatedDate : _7(e.CreatedDate, n.WTF), {
        "xsi:type": "dcterms:W3CDTF"
    }, i, r),
    e.ModifiedDate != null && d7("dcterms:modified", typeof e.ModifiedDate == "string" ? e.ModifiedDate : _7(e.ModifiedDate, n.WTF), {
        "xsi:type": "dcterms:W3CDTF"
    }, i, r));
    for (var s = 0; s != t0.length; ++s) {
        var o = t0[s]
          , a = n.Props && n.Props[o[1]] != null ? n.Props[o[1]] : e ? e[o[1]] : null;
        a === !0 ? a = "1" : a === !1 ? a = "0" : typeof a == "number" && (a = String(a)),
        a != null && d7(o[0], a, null, i, r)
    }
    return i.length > 2 && (i[i.length] = "</cp:coreProperties>",
    i[1] = i[1].replace("/>", ">")),
    i.join("")
}
var ju = [["Application", "Application", "string"], ["AppVersion", "AppVersion", "string"], ["Company", "Company", "string"], ["DocSecurity", "DocSecurity", "string"], ["Manager", "Manager", "string"], ["HyperlinksChanged", "HyperlinksChanged", "bool"], ["SharedDoc", "SharedDoc", "bool"], ["LinksUpToDate", "LinksUpToDate", "bool"], ["ScaleCrop", "ScaleCrop", "bool"], ["HeadingPairs", "HeadingPairs", "raw"], ["TitlesOfParts", "TitlesOfParts", "raw"]]
  , hC = ["Worksheets", "SheetNames", "NamedRanges", "DefinedNames", "Chartsheets", "ChartNames"];
function dC(e) {
    var t = []
      , n = Pe;
    return e || (e = {}),
    e.Application = "SheetJS",
    t[t.length] = oi,
    t[t.length] = Pe("Properties", null, {
        xmlns: Ai.EXT_PROPS,
        "xmlns:vt": Ai.vt
    }),
    ju.forEach(function(i) {
        if (e[i[1]] !== void 0) {
            var r;
            switch (i[2]) {
            case "string":
                r = en(String(e[i[1]]));
                break;
            case "bool":
                r = e[i[1]] ? "true" : "false";
                break
            }
            r !== void 0 && (t[t.length] = n(i[0], r))
        }
    }),
    t[t.length] = n("HeadingPairs", n("vt:vector", n("vt:variant", "<vt:lpstr>Worksheets</vt:lpstr>") + n("vt:variant", n("vt:i4", String(e.Worksheets))), {
        size: 2,
        baseType: "variant"
    })),
    t[t.length] = n("TitlesOfParts", n("vt:vector", e.SheetNames.map(function(i) {
        return "<vt:lpstr>" + en(i) + "</vt:lpstr>"
    }).join(""), {
        size: e.Worksheets,
        baseType: "lpstr"
    })),
    t.length > 2 && (t[t.length] = "</Properties>",
    t[1] = t[1].replace("/>", ">")),
    t.join("")
}
function fC(e) {
    var t = [oi, Pe("Properties", null, {
        xmlns: Ai.CUST_PROPS,
        "xmlns:vt": Ai.vt
    })];
    if (!e)
        return t.join("");
    var n = 1;
    return zi(e).forEach(function(r) {
        ++n,
        t[t.length] = Pe("property", rB(e[r], !0), {
            fmtid: "{D5CDD505-2E9C-101B-9397-08002B2CF9AE}",
            pid: n,
            name: en(r)
        })
    }),
    t.length > 2 && (t[t.length] = "</Properties>",
    t[1] = t[1].replace("/>", ">")),
    t.join("")
}
var dw = {
    Title: "Title",
    Subject: "Subject",
    Author: "Author",
    Keywords: "Keywords",
    Comments: "Description",
    LastAuthor: "LastAuthor",
    RevNumber: "Revision",
    Application: "AppName",
    LastPrinted: "LastPrinted",
    CreatedDate: "Created",
    ModifiedDate: "LastSaved",
    Category: "Category",
    Manager: "Manager",
    Company: "Company",
    AppVersion: "Version",
    ContentStatus: "ContentStatus",
    Identifier: "Identifier",
    Language: "Language"
};
function VB(e, t) {
    var n = [];
    return zi(dw).map(function(i) {
        for (var r = 0; r < t0.length; ++r)
            if (t0[r][1] == i)
                return t0[r];
        for (r = 0; r < ju.length; ++r)
            if (ju[r][1] == i)
                return ju[r];
        throw i
    }).forEach(function(i) {
        if (e[i[1]] != null) {
            var r = t && t.Props && t.Props[i[1]] != null ? t.Props[i[1]] : e[i[1]];
            switch (i[2]) {
            case "date":
                r = new Date(r).toISOString().replace(/\.\d*Z/, "Z");
                break
            }
            typeof r == "number" ? r = String(r) : r === !0 || r === !1 ? r = r ? "1" : "0" : r instanceof Date && (r = new Date(r).toISOString().replace(/\.\d*Z/, "")),
            n.push(ji(dw[i[1]] || i[1], r))
        }
    }),
    Pe("DocumentProperties", n.join(""), {
        xmlns: Ss.o
    })
}
